{"version":3,"sources":["webpack:///./node_modules/ol/geom/flat/textpath.js","webpack:///./node_modules/ol/geom/LinearRing.js","webpack:///./node_modules/ol/geom/flat/interiorpoint.js","webpack:///./node_modules/ol/geom/flat/simplify.js","webpack:///./node_modules/ol/geom/flat/contains.js","webpack:///./node_modules/ol/geom/MultiLineString.js","webpack:///./node_modules/ol/geom/flat/reverse.js","webpack:///./node_modules/ol/geom/flat/orient.js","webpack:///./node_modules/ol/geom/GeometryLayout.js","webpack:///./node_modules/ol/functions.js","webpack:///./node_modules/ol/geom/flat/length.js","webpack:///./node_modules/ol/geom/Polygon.js","webpack:///./node_modules/ol/geom/LineString.js","webpack:///./node_modules/ol/geom/flat/straightchunk.js","webpack:///./node_modules/ol/geom/flat/center.js","webpack:///./node_modules/ol/geom/MultiPolygon.js","webpack:///./node_modules/ol/geom/Geometry.js","webpack:///./node_modules/ol/geom/flat/closest.js","webpack:///./node_modules/ol/geom/MultiPoint.js","webpack:///./node_modules/ol/geom/SimpleGeometry.js","webpack:///./node_modules/ol/geom/flat/deflate.js","webpack:///./node_modules/ol/geom/flat/interpolate.js","webpack:///./node_modules/ol/geom/flat/area.js","webpack:///./node_modules/ol/geom/flat/inflate.js","webpack:///./node_modules/ol/geom/flat/transform.js","webpack:///./node_modules/ol/geom/flat/intersectsextent.js","webpack:///./node_modules/ol/geom/GeometryCollection.js","webpack:///./node_modules/ol/geom/Point.js","webpack:///./node_modules/ol/geom/GeometryType.js","webpack:///./node_modules/ol/geom/Circle.js","webpack:///./node_modules/ol/geom/flat/segments.js"],"names":["drawTextOnPath","flatCoordinates","offset","end","stride","text","startM","maxAngle","scale","measureAndCacheTextWidth","font","cache","rotation","x2","y2","x1","y1","segmentLength","segmentM","advance","Math","sqrt","interpolate","beginX","beginY","startOffset","startLength","endM","reverse","endX","endY","flat","previousAngle","PI","result","singleSegment","previousAngle_1","atan2","x","y","i","ii","length","angle","undefined","delta","abs","iStart","charLength","index","len","chars","substring","push","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","LinearRing","_super","coordinates","opt_layout","_this","maxDelta_","maxDeltaRevision_","isArray","setCoordinates","setFlatCoordinates","clone","slice","layout","closestPointXY","closestPoint","minSquaredDistance","getExtent","getRevision","getArea","getCoordinates","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","XY","getType","LINEAR_RING","intersectsExtent","extent","setLayout","changed","getInteriorPointOfArray","ends","flatCenters","flatCentersOffset","opt_dest","intersections","r","rr","pointX","NaN","maxSegmentLength","Infinity","sort","isNaN","getInteriorPointsOfMultiArray","endss","interiorPoints","douglasPeucker","simplifiedOffset","n","markers","stack","last","pop","first","maxSquaredDistance","squaredDistance_1","douglasPeuckerArray","simplifiedEnds","snap","value","tolerance","round","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeArray","quantizeMultiArray","simplifiedEndss","linearRingContainsExtent","outside","coordinate","linearRingContainsXY","wn","linearRingsContainsXY","linearRingssContainsXY","MultiLineString","opt_ends","ends_","getLayout","lineStrings","lineString","getFlatCoordinates","appendLineString","multiLineString","applyProperties","getCoordinateAtM","m","opt_extrapolate","opt_interpolate","XYM","XYZM","extrapolate","getEnds","getLineString","getLineStrings","getFlatMidpoints","midpoints","midpoint","MULTI_LINE_STRING","tmp","linearRingIsClockwise","edge","linearRingsAreOriented","opt_right","right","isClockwise","linearRingssAreOriented","orientLinearRings","orientLinearRingsArray","XYZ","TRUE","FALSE","VOID","memoizeOne","fn","lastResult","lastArgs","lastThis","called","nextArgs","arguments","apply","lineStringLength","Polygon","flatInteriorPointRevision_","flatInteriorPoint_","orientedRevision_","orientedFlatCoordinates_","appendLinearRing","linearRing","polygon","containsXY","getOrientedFlatCoordinates","getFlatInteriorPoint","flatCenter","getInteriorPoint","getLinearRingCount","getLinearRing","getLinearRings","linearRings","POLYGON","fromExtent","minX","minY","maxX","maxY","fromCircle","circle","opt_sides","opt_angle","sides","getStride","center","getCenter","arrayLength","j","makeRegular","getRadius","radius","startAngle","cos","sin","LineString","flatMidpoint_","flatMidpointRevision_","appendCoordinate","forEachSegment","callback","getCoordinateAt","fraction","getLength","getFlatMidpoint","LINE_STRING","matchingChunk","acos","m12","m23","x12","y12","x23","y23","chunkStart","chunkEnd","chunkM","start","linearRingss","MultiPolygon","opt_endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","polygons","jj","appendPolygon","newEndss","multiPolygon","orient","inflate","getEndss","getFlatInteriorPoints","getInteriorPoints","MultiPoint","GeometryLayout","getPolygon","prevEnds","getPolygons","GeometryType","MULTI_POLYGON","deflate","lastEnds","SimpleGeometry","tmpTransform","Geometry","extent_","extentRevision_","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","simplifyTransformedInternal","revision","opt_transform","getSimplifiedGeometry","applyTransform","simplifyTransformed","coord","getClosestPoint","point","opt_closestPoint","intersectsCoordinate","computeExtent","opt_extent","rotate","anchor","sx","opt_sy","opt_anchor","simplify","transformFn","translate","deltaX","deltaY","transform","source","destination","sourceProj","getUnits","TILE_PIXELS","inCoordinates","outCoordinates","pixelExtent","projectedExtent","getWorldExtent","assignClosest","offset1","offset2","dx","dy","t","maxSquaredDelta","max","squaredDelta","arrayMaxSquaredDelta","multiArrayMaxSquaredDelta","assignClosestPoint","maxDelta","isRing","opt_tmpPoint","squaredDistance","tmpPoint","assignClosestArrayPoint","assignClosestMultiArrayPoint","appendPoint","multiPoint","getPoint","getPoints","points","MULTI_POINT","getFirstCoordinate","getLastCoordinate","simplifiedGeometry","getStrideForLayout","nesting","getLayoutForStride","sy","transformGeom2D","simpleGeometry","deflateCoordinate","deflateCoordinates","deflateCoordinatesArray","coordinatess","deflateMultiCoordinatesArray","coordinatesss","interpolatePoint","opt_dimension","o","length_1","cumulativeLengths","target","dimension","dest","lineStringCoordinateAtM","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","twiceArea","area","inflateCoordinates","opt_coordinates","inflateCoordinatesArray","opt_coordinatess","inflateMultiCoordinatesArray","opt_coordinatesss","transform2D","anchorX","anchorY","k","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","GeometryCollection","opt_geometries","geometries_","changeEventsKeys_","listenGeometriesChange_","unlistenGeometriesChange_","forEach","CHANGE","geometryCollection","setGeometries","geometries","getGeometries","cloneGeometries","getGeometriesArray","getGeometriesArrayRecursive","geometriesArray","concat","simplifiedGeometries","simplified","geometry","simplifiedGeometryCollection","setGeometriesArray","GEOMETRY_COLLECTION","isEmpty","disposeInternal","clonedGeometries","Point","POINT","CIRCLE","Circle","opt_radius","setCenterAndRadius","getRadiusSquared_","circleExtent","bind","setCenter","setRadius","ret"],"mappings":"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","file":"js/chunk-7c914176.8f1824a1.js","sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var x1 = 0;\n    var y1 = 0;\n    var segmentLength = 0;\n    var segmentM = 0;\n    function advance() {\n        x1 = x2;\n        y1 = y2;\n        offset += stride;\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        segmentM += segmentLength;\n        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    do {\n        advance();\n    } while (offset < end - stride && segmentM + segmentLength < startM);\n    var interpolate = (startM - segmentM) / segmentLength;\n    var beginX = lerp(x1, x2, interpolate);\n    var beginY = lerp(y1, y2, interpolate);\n    var startOffset = offset - stride;\n    var startLength = segmentM;\n    var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n    while (offset < end - stride && segmentM + segmentLength < endM) {\n        advance();\n    }\n    interpolate = (endM - segmentM) / segmentLength;\n    var endX = lerp(x1, x2, interpolate);\n    var endY = lerp(y1, y2, interpolate);\n    // Keep text upright\n    var reverse;\n    if (rotation) {\n        var flat = [beginX, beginY, endX, endY];\n        rotate(flat, 0, 4, 2, rotation, flat, flat);\n        reverse = flat[0] > flat[2];\n    }\n    else {\n        reverse = beginX > endX;\n    }\n    var PI = Math.PI;\n    var result = [];\n    var singleSegment = startOffset + stride === offset;\n    offset = startOffset;\n    segmentLength = 0;\n    segmentM = startLength;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    // All on the same segment\n    if (singleSegment) {\n        advance();\n        var previousAngle_1 = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            previousAngle_1 += previousAngle_1 > 0 ? -PI : PI;\n        }\n        var x = (endX + beginX) / 2;\n        var y = (endY + beginY) / 2;\n        result[0] = [x, y, (endM - startM) / 2, previousAngle_1, text];\n        return result;\n    }\n    var previousAngle;\n    for (var i = 0, ii = text.length; i < ii;) {\n        advance();\n        var angle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            angle += angle > 0 ? -PI : PI;\n        }\n        if (previousAngle !== undefined) {\n            var delta = angle - previousAngle;\n            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n            if (Math.abs(delta) > maxAngle) {\n                return null;\n            }\n        }\n        previousAngle = angle;\n        var iStart = i;\n        var charLength = 0;\n        for (; i < ii; ++i) {\n            var index = reverse ? ii - i - 1 : i;\n            var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n            if (offset + stride < end &&\n                segmentM + segmentLength < startM + charLength + len / 2) {\n                break;\n            }\n            charLength += len;\n        }\n        if (i === iStart) {\n            continue;\n        }\n        var chars = reverse\n            ? text.substring(ii - iStart, ii - i)\n            : text.substring(iStart, i);\n        interpolate = (startM + charLength / 2 - segmentM) / segmentLength;\n        var x = lerp(x1, x2, interpolate);\n        var y = lerp(y1, y2, interpolate);\n        result.push([x, y, charLength / 2, angle, chars]);\n        startM += charLength;\n    }\n    return result;\n}\n//# sourceMappingURL=textpath.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/LinearRing\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { douglasPeucker } from './flat/simplify.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { linearRing as linearRingArea } from './flat/area.js';\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nvar LinearRing = /** @class */ (function (_super) {\n    __extends(LinearRing, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function LinearRing(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!LinearRing} Clone.\n     * @api\n     */\n    LinearRing.prototype.clone = function () {\n        return new LinearRing(this.flatCoordinates.slice(), this.layout);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Return the area of the linear ring on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    LinearRing.prototype.getArea = function () {\n        return linearRingArea(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the coordinates of the linear ring.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    LinearRing.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LinearRing} Simplified LinearRing.\n     * @protected\n     */\n    LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    LinearRing.prototype.getType = function () {\n        return GeometryType.LINEAR_RING;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    LinearRing.prototype.intersectsExtent = function (extent) {\n        return false;\n    };\n    /**\n     * Set the coordinates of the linear ring.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return LinearRing;\n}(SimpleGeometry));\nexport default LinearRing;\n//# sourceMappingURL=LinearRing.js.map","/**\n * @module ol/geom/flat/interiorpoint\n */\nimport { linearRingsContainsXY } from './contains.js';\nimport { numberSafeCompareFunction } from '../../array.js';\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n    var i, ii, x, x1, x2, y1, y2;\n    var y = flatCenters[flatCentersOffset + 1];\n    /** @type {Array<number>} */\n    var intersections = [];\n    // Calculate intersections with the horizontal line\n    for (var r = 0, rr = ends.length; r < rr; ++r) {\n        var end = ends[r];\n        x1 = flatCoordinates[end - stride];\n        y1 = flatCoordinates[end - stride + 1];\n        for (i = offset; i < end; i += stride) {\n            x2 = flatCoordinates[i];\n            y2 = flatCoordinates[i + 1];\n            if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n                x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n                intersections.push(x);\n            }\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n    // Find the longest segment of the horizontal line that has its center point\n    // inside the linear ring.\n    var pointX = NaN;\n    var maxSegmentLength = -Infinity;\n    intersections.sort(numberSafeCompareFunction);\n    x1 = intersections[0];\n    for (i = 1, ii = intersections.length; i < ii; ++i) {\n        x2 = intersections[i];\n        var segmentLength = Math.abs(x2 - x1);\n        if (segmentLength > maxSegmentLength) {\n            x = (x1 + x2) / 2;\n            if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n                pointX = x;\n                maxSegmentLength = segmentLength;\n            }\n        }\n        x1 = x2;\n    }\n    if (isNaN(pointX)) {\n        // There is no horizontal line that has its center point inside the linear\n        // ring.  Use the center of the the linear ring's extent.\n        pointX = flatCenters[flatCentersOffset];\n    }\n    if (opt_dest) {\n        opt_dest.push(pointX, y, maxSegmentLength);\n        return opt_dest;\n    }\n    else {\n        return [pointX, y, maxSegmentLength];\n    }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\n    var interiorPoints = [];\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n        offset = ends[ends.length - 1];\n    }\n    return interiorPoints;\n}\n//# sourceMappingURL=interiorpoint.js.map","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport { squaredDistance, squaredSegmentDistance } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [opt_simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n    var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined\n        ? opt_simplifiedFlatCoordinates\n        : [];\n    if (!highQuality) {\n        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        flatCoordinates = simplifiedFlatCoordinates;\n        offset = 0;\n        stride = 2;\n    }\n    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    var n = (end - offset) / stride;\n    if (n < 3) {\n        for (; offset < end; offset += stride) {\n            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + 1];\n        }\n        return simplifiedOffset;\n    }\n    /** @type {Array<number>} */\n    var markers = new Array(n);\n    markers[0] = 1;\n    markers[n - 1] = 1;\n    /** @type {Array<number>} */\n    var stack = [offset, end - stride];\n    var index = 0;\n    while (stack.length > 0) {\n        var last = stack.pop();\n        var first = stack.pop();\n        var maxSquaredDistance = 0;\n        var x1 = flatCoordinates[first];\n        var y1 = flatCoordinates[first + 1];\n        var x2 = flatCoordinates[last];\n        var y2 = flatCoordinates[last + 1];\n        for (var i = first + stride; i < last; i += stride) {\n            var x = flatCoordinates[i];\n            var y = flatCoordinates[i + 1];\n            var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n            if (squaredDistance_1 > maxSquaredDistance) {\n                index = i;\n                maxSquaredDistance = squaredDistance_1;\n            }\n        }\n        if (maxSquaredDistance > squaredTolerance) {\n            markers[(index - offset) / stride] = 1;\n            if (first + stride < index) {\n                stack.push(first, index);\n            }\n            if (index + stride < last) {\n                stack.push(index, last);\n            }\n        }\n    }\n    for (var i = 0; i < n; ++i) {\n        if (markers[i]) {\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + i * stride];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + i * stride + 1];\n        }\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    if (end <= offset + stride) {\n        // zero or one point, no simplification possible, so copy and return\n        for (; offset < end; offset += stride) {\n            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + 1];\n        }\n        return simplifiedOffset;\n    }\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    // copy first point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    var x2 = x1;\n    var y2 = y1;\n    for (offset += stride; offset < end; offset += stride) {\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n            // copy point at offset\n            simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n            simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n    if (x2 != x1 || y2 != y1) {\n        // copy last point\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n    return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    // do nothing if the line is empty\n    if (offset == end) {\n        return simplifiedOffset;\n    }\n    // snap the first coordinate (P1)\n    var x1 = snap(flatCoordinates[offset], tolerance);\n    var y1 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // add the first coordinate to the output\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    // find the next coordinate that does not snap to the same value as the first\n    // coordinate (P2)\n    var x2, y2;\n    do {\n        x2 = snap(flatCoordinates[offset], tolerance);\n        y2 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n        if (offset == end) {\n            // all coordinates snap to the same value, the line collapses to a point\n            // push the last snapped value anyway to ensure that the output contains\n            // at least two points\n            // FIXME should we really return at least two points anyway?\n            simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n            simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n            return simplifiedOffset;\n        }\n    } while (x2 == x1 && y2 == y1);\n    while (offset < end) {\n        // snap the next coordinate (P3)\n        var x3 = snap(flatCoordinates[offset], tolerance);\n        var y3 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n        // skip P3 if it is equal to P2\n        if (x3 == x2 && y3 == y2) {\n            continue;\n        }\n        // calculate the delta between P1 and P2\n        var dx1 = x2 - x1;\n        var dy1 = y2 - y1;\n        // calculate the delta between P3 and P1\n        var dx2 = x3 - x1;\n        var dy2 = y3 - y1;\n        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n        // P1 in the same direction then P2 is on the straight line between P1 and\n        // P3\n        if (dx1 * dy2 == dy1 * dx2 &&\n            ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n            ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n            // discard P2 and set P2 = P3\n            x2 = x3;\n            y2 = y3;\n            continue;\n        }\n        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n        // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n        // and continue with P1 = P2 and P2 = P3\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n        x1 = x2;\n        y1 = y2;\n        x2 = x3;\n        y2 = y3;\n    }\n    // add the last point (P2)\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n}\n//# sourceMappingURL=simplify.js.map","/**\n * @module ol/geom/flat/contains\n */\nimport { forEachCorner } from '../../extent.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {\n    var outside = forEachCorner(extent, \n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);\n    });\n    return !outside;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {\n    // https://geomalgorithms.com/a03-_inclusion.html\n    // Copyright 2000 softSurfer, 2012 Dan Sunday\n    // This code may be freely used and modified for any purpose\n    // providing that this copyright notice is included with it.\n    // SoftSurfer makes no warranty for this code, and cannot be held\n    // liable for any real or imagined damage resulting from its use.\n    // Users of this code must verify correctness for their application.\n    var wn = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        if (y1 <= y) {\n            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n                wn++;\n            }\n        }\n        else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n            wn--;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return wn !== 0;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {\n    if (ends.length === 0) {\n        return false;\n    }\n    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n        return false;\n    }\n    for (var i = 1, ii = ends.length; i < ii; ++i) {\n        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {\n    if (endss.length === 0) {\n        return false;\n    }\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n            return true;\n        }\n        offset = ends[ends.length - 1];\n    }\n    return false;\n}\n//# sourceMappingURL=contains.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiLineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { douglasPeuckerArray } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { interpolatePoint, lineStringsCoordinateAtM, } from './flat/interpolate.js';\nimport { intersectsLineStringArray } from './flat/intersectsextent.js';\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /** @class */ (function (_super) {\n    __extends(MultiLineString, _super);\n    /**\n     * @param {Array<Array<import(\"../coordinate.js\").Coordinate>|LineString>|Array<number>} coordinates\n     *     Coordinates or LineString geometries. (For internal use, flat coordinates in\n     *     combination with `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.\n     */\n    function MultiLineString(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (Array.isArray(coordinates[0])) {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        else if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            var layout = _this.getLayout();\n            var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n            var flatCoordinates = [];\n            var ends = [];\n            for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n                var lineString = lineStrings[i];\n                if (i === 0) {\n                    layout = lineString.getLayout();\n                }\n                extend(flatCoordinates, lineString.getFlatCoordinates());\n                ends.push(flatCoordinates.length);\n            }\n            _this.setFlatCoordinates(layout, flatCoordinates);\n            _this.ends_ = ends;\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linestring to the multilinestring.\n     * @param {LineString} lineString LineString.\n     * @api\n     */\n    MultiLineString.prototype.appendLineString = function (lineString) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = lineString.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiLineString} Clone.\n     * @api\n     */\n    MultiLineString.prototype.clone = function () {\n        var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        multiLineString.applyProperties(this);\n        return multiLineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * `opt_interpolate` controls interpolation between consecutive LineStrings\n     * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n     * will be linearly interpolated between the last coordinate of one LineString\n     * and the first coordinate of the next LineString.  If `opt_interpolate` is\n     * `false` then the function will return `null` for Ms falling between\n     * LineStrings.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {\n        if ((this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) ||\n            this.flatCoordinates.length === 0) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n        return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n    };\n    /**\n     * Return the coordinates of the multilinestring.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    MultiLineString.prototype.getCoordinates = function () {\n        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    MultiLineString.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * Return the linestring at the specified index.\n     * @param {number} index Index.\n     * @return {LineString} LineString.\n     * @api\n     */\n    MultiLineString.prototype.getLineString = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linestrings of this multilinestring.\n     * @return {Array<LineString>} LineStrings.\n     * @api\n     */\n    MultiLineString.prototype.getLineStrings = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var layout = this.layout;\n        /** @type {Array<LineString>} */\n        var lineStrings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n            lineStrings.push(lineString);\n            offset = end;\n        }\n        return lineStrings;\n    };\n    /**\n     * @return {Array<number>} Flat midpoints.\n     */\n    MultiLineString.prototype.getFlatMidpoints = function () {\n        var midpoints = [];\n        var flatCoordinates = this.flatCoordinates;\n        var offset = 0;\n        var ends = this.ends_;\n        var stride = this.stride;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n            extend(midpoints, midpoint);\n            offset = end;\n        }\n        return midpoints;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiLineString} Simplified MultiLineString.\n     * @protected\n     */\n    MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    MultiLineString.prototype.getType = function () {\n        return GeometryType.MULTI_LINE_STRING;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiLineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multilinestring.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {GeometryLayout} [opt_layout] Layout.\n     * @api\n     */\n    MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return MultiLineString;\n}(SimpleGeometry));\nexport default MultiLineString;\n//# sourceMappingURL=MultiLineString.js.map","/**\n * @module ol/geom/flat/reverse\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n    while (offset < end - stride) {\n        for (var i = 0; i < stride; ++i) {\n            var tmp = flatCoordinates[offset + i];\n            flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n            flatCoordinates[end - stride + i] = tmp;\n        }\n        offset += stride;\n        end -= stride;\n    }\n}\n//# sourceMappingURL=reverse.js.map","/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n    // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n    var edge = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        edge += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    return edge === 0 ? undefined : edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        if (i === 0) {\n            if ((right && isClockwise) || (!right && !isClockwise)) {\n                return false;\n            }\n        }\n        else {\n            if ((right && !isClockwise) || (!right && isClockwise)) {\n                return false;\n            }\n        }\n        offset = end;\n    }\n    return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n            return false;\n        }\n        if (ends.length) {\n            offset = ends[ends.length - 1];\n        }\n    }\n    return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        var reverse = i === 0\n            ? (right && isClockwise) || (!right && !isClockwise)\n            : (right && !isClockwise) || (!right && isClockwise);\n        if (reverse) {\n            reverseCoordinates(flatCoordinates, offset, end, stride);\n        }\n        offset = end;\n    }\n    return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n    }\n    return offset;\n}\n//# sourceMappingURL=orient.js.map","/**\n * @module ol/geom/GeometryLayout\n */\n/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\nexport default {\n    XY: 'XY',\n    XYZ: 'XYZ',\n    XYM: 'XYM',\n    XYZM: 'XYZM',\n};\n//# sourceMappingURL=GeometryLayout.js.map","/**\n * @module ol/functions\n */\nimport { equals as arrayEquals } from './array.js';\n/**\n * Always returns true.\n * @return {boolean} true.\n */\nexport function TRUE() {\n    return true;\n}\n/**\n * Always returns false.\n * @return {boolean} false.\n */\nexport function FALSE() {\n    return false;\n}\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\nexport function VOID() { }\n/**\n * Wrap a function in another function that remembers the last return.  If the\n * returned function is called twice in a row with the same arguments and the same\n * this object, it will return the value from the first call in the second call.\n *\n * @param {function(...any): ReturnType} fn The function to memoize.\n * @return {function(...any): ReturnType} The memoized function.\n * @template ReturnType\n */\nexport function memoizeOne(fn) {\n    var called = false;\n    /** @type {ReturnType} */\n    var lastResult;\n    /** @type {Array<any>} */\n    var lastArgs;\n    var lastThis;\n    return function () {\n        var nextArgs = Array.prototype.slice.call(arguments);\n        if (!called || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\n            called = true;\n            lastThis = this;\n            lastArgs = nextArgs;\n            lastResult = fn.apply(this, arguments);\n        }\n        return lastResult;\n    };\n}\n//# sourceMappingURL=functions.js.map","/**\n * @module ol/geom/flat/length\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    for (var i = offset + stride; i < end; i += stride) {\n        var x2 = flatCoordinates[i];\n        var y2 = flatCoordinates[i + 1];\n        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n        x1 = x2;\n        y1 = y2;\n    }\n    return length;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n    var perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n    var dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n    var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n    perimeter += Math.sqrt(dx * dx + dy * dy);\n    return perimeter;\n}\n//# sourceMappingURL=length.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Polygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY, getCenter } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray } from './flat/interiorpoint.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingArray } from './flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRings } from './flat/orient.js';\nimport { linearRings as linearRingsArea } from './flat/area.js';\nimport { linearRingsContainsXY } from './flat/contains.js';\nimport { modulo } from '../math.js';\nimport { quantizeArray } from './flat/simplify.js';\nimport { offset as sphereOffset } from '../sphere.js';\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    /**\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n     *     Array of linear rings that define the polygon. The first linear ring of the\n     *     array defines the outer-boundary or surface of the polygon. Each subsequent\n     *     linear ring defines a hole in the surface of the polygon. A linear ring is\n     *     an array of vertices' coordinates where the first coordinate and the last are\n     *     equivalent. (For internal use, flat coordinates in combination with\n     *     `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).\n     */\n    function Polygon(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointRevision_ = -1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatInteriorPoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linear ring to this polygon.\n     * @param {LinearRing} linearRing Linear ring.\n     * @api\n     */\n    Polygon.prototype.appendLinearRing = function (linearRing) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Polygon} Clone.\n     * @api\n     */\n    Polygon.prototype.clone = function () {\n        var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        polygon.applyProperties(this);\n        return polygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Polygon.prototype.containsXY = function (x, y) {\n        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the polygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    Polygon.prototype.getArea = function () {\n        return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    Polygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    Polygon.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * @return {Array<number>} Interior point.\n     */\n    Polygon.prototype.getFlatInteriorPoint = function () {\n        if (this.flatInteriorPointRevision_ != this.getRevision()) {\n            var flatCenter = getCenter(this.getExtent());\n            this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n            this.flatInteriorPointRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoint_;\n    };\n    /**\n     * Return an interior point of the polygon.\n     * @return {Point} Interior point as XYM coordinate, where M is the\n     * length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    Polygon.prototype.getInteriorPoint = function () {\n        return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n    };\n    /**\n     * Return the number of rings of the polygon,  this includes the exterior\n     * ring and any interior rings.\n     *\n     * @return {number} Number of rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRingCount = function () {\n        return this.ends_.length;\n    };\n    /**\n     * Return the Nth linear ring of the polygon geometry. Return `null` if the\n     * given index is out of range.\n     * The exterior linear ring is available at index `0` and the interior rings\n     * at index `1` and beyond.\n     *\n     * @param {number} index Index.\n     * @return {LinearRing} Linear ring.\n     * @api\n     */\n    Polygon.prototype.getLinearRing = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linear rings of the polygon.\n     * @return {Array<LinearRing>} Linear rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRings = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var linearRings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n            linearRings.push(linearRing);\n            offset = end;\n        }\n        return linearRings;\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    Polygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Polygon} Simplified Polygon.\n     * @protected\n     */\n    Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    Polygon.prototype.getType = function () {\n        return GeometryType.POLYGON;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Polygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the polygon.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return Polygon;\n}(SimpleGeometry));\nexport default Polygon;\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [opt_n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n    var n = opt_n ? opt_n : 32;\n    /** @type {Array<number>} */\n    var flatCoordinates = [];\n    for (var i = 0; i < n; ++i) {\n        extend(flatCoordinates, sphereOffset(center, radius, (2 * Math.PI * i) / n, opt_sphereRadius));\n    }\n    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var flatCoordinates = [\n        minX,\n        minY,\n        minX,\n        maxY,\n        maxX,\n        maxY,\n        maxX,\n        minY,\n        minX,\n        minY,\n    ];\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, opt_sides, opt_angle) {\n    var sides = opt_sides ? opt_sides : 32;\n    var stride = circle.getStride();\n    var layout = circle.getLayout();\n    var center = circle.getCenter();\n    var arrayLength = stride * (sides + 1);\n    var flatCoordinates = new Array(arrayLength);\n    for (var i = 0; i < arrayLength; i += stride) {\n        flatCoordinates[i] = 0;\n        flatCoordinates[i + 1] = 0;\n        for (var j = 2; j < stride; j++) {\n            flatCoordinates[i + j] = center[j];\n        }\n    }\n    var ends = [flatCoordinates.length];\n    var polygon = new Polygon(flatCoordinates, layout, ends);\n    makeRegular(polygon, center, circle.getRadius(), opt_angle);\n    return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [opt_angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, opt_angle) {\n    var flatCoordinates = polygon.getFlatCoordinates();\n    var stride = polygon.getStride();\n    var sides = flatCoordinates.length / stride - 1;\n    var startAngle = opt_angle ? opt_angle : 0;\n    for (var i = 0; i <= sides; ++i) {\n        var offset = i * stride;\n        var angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n    }\n    polygon.changed();\n}\n//# sourceMappingURL=Polygon.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/LineString\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { douglasPeucker } from './flat/simplify.js';\nimport { extend } from '../array.js';\nimport { forEach as forEachSegment } from './flat/segments.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { interpolatePoint, lineStringCoordinateAtM } from './flat/interpolate.js';\nimport { intersectsLineString } from './flat/intersectsextent.js';\nimport { lineStringLength } from './flat/length.js';\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /** @class */ (function (_super) {\n    __extends(LineString, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function LineString(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatMidpoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatMidpointRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed coordinate to the coordinates of the linestring.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @api\n     */\n    LineString.prototype.appendCoordinate = function (coordinate) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = coordinate.slice();\n        }\n        else {\n            extend(this.flatCoordinates, coordinate);\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!LineString} Clone.\n     * @api\n     */\n    LineString.prototype.clone = function () {\n        var lineString = new LineString(this.flatCoordinates.slice(), this.layout);\n        lineString.applyProperties(this);\n        return lineString;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Iterate over each segment, calling the provided callback.\n     * If the callback returns a truthy value the function returns that\n     * value immediately. Otherwise the function returns `false`.\n     *\n     * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.\n     * @return {T|boolean} Value.\n     * @template T,S\n     * @api\n     */\n    LineString.prototype.forEachSegment = function (callback) {\n        return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n    };\n    /**\n     * Returns the coordinate at `m` using linear interpolation, or `null` if no\n     * such coordinate exists.\n     *\n     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n     * M will return the first coordinate and Ms greater than the last M will\n     * return the last coordinate.\n     *\n     * @param {number} m M.\n     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n     * @api\n     */\n    LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {\n        if (this.layout != GeometryLayout.XYM &&\n            this.layout != GeometryLayout.XYZM) {\n            return null;\n        }\n        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n        return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n    };\n    /**\n     * Return the coordinates of the linestring.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    LineString.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the coordinate at the provided fraction along the linestring.\n     * The `fraction` is a number between 0 and 1, where 0 is the start of the\n     * linestring and 1 is the end.\n     * @param {number} fraction Fraction.\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_dest] Optional coordinate whose values will\n     *     be modified. If not provided, a new coordinate will be returned.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n     * @api\n     */\n    LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {\n        return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);\n    };\n    /**\n     * Return the length of the linestring on projected plane.\n     * @return {number} Length (on projected plane).\n     * @api\n     */\n    LineString.prototype.getLength = function () {\n        return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * @return {Array<number>} Flat midpoint.\n     */\n    LineString.prototype.getFlatMidpoint = function () {\n        if (this.flatMidpointRevision_ != this.getRevision()) {\n            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n            this.flatMidpointRevision_ = this.getRevision();\n        }\n        return this.flatMidpoint_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} Simplified LineString.\n     * @protected\n     */\n    LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    LineString.prototype.getType = function () {\n        return GeometryType.LINE_STRING;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    LineString.prototype.intersectsExtent = function (extent) {\n        return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the linestring.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    LineString.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return LineString;\n}(SimpleGeometry));\nexport default LineString;\n//# sourceMappingURL=LineString.js.map","/**\n * @module ol/geom/flat/straightchunk\n */\n/**\n * @param {number} maxAngle Maximum acceptable angle delta between segments.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Array<number>} Start and end of the first suitable chunk of the\n * given `flatCoordinates`.\n */\nexport function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {\n    var chunkStart = offset;\n    var chunkEnd = offset;\n    var chunkM = 0;\n    var m = 0;\n    var start = offset;\n    var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\n    for (i = offset; i < end; i += stride) {\n        var x2 = flatCoordinates[i];\n        var y2 = flatCoordinates[i + 1];\n        if (x1 !== undefined) {\n            x23 = x2 - x1;\n            y23 = y2 - y1;\n            m23 = Math.sqrt(x23 * x23 + y23 * y23);\n            if (x12 !== undefined) {\n                m += m12;\n                acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n                if (acos > maxAngle) {\n                    if (m > chunkM) {\n                        chunkM = m;\n                        chunkStart = start;\n                        chunkEnd = i;\n                    }\n                    m = 0;\n                    start = i - stride;\n                }\n            }\n            m12 = m23;\n            x12 = x23;\n            y12 = y23;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    m += m23;\n    return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\n}\n//# sourceMappingURL=straightchunk.js.map","/**\n * @module ol/geom/flat/center\n */\nimport { createEmpty, createOrUpdateFromFlatCoordinates } from '../../extent.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n    var flatCenters = [];\n    var extent = createEmpty();\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n        offset = ends[ends.length - 1];\n    }\n    return flatCenters;\n}\n//# sourceMappingURL=center.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPolygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta, } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingssAreOriented, orientLinearRingsArray, } from './flat/orient.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /** @class */ (function (_super) {\n    __extends(MultiPolygon, _super);\n    /**\n     * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.\n     */\n    function MultiPolygon(coordinates, opt_layout, opt_endss) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<Array<number>>}\n         * @private\n         */\n        _this.endss_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointsRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.flatInteriorPoints_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (!opt_endss && !Array.isArray(coordinates[0])) {\n            var layout = _this.getLayout();\n            var polygons = /** @type {Array<Polygon>} */ (coordinates);\n            var flatCoordinates = [];\n            var endss = [];\n            for (var i = 0, ii = polygons.length; i < ii; ++i) {\n                var polygon = polygons[i];\n                if (i === 0) {\n                    layout = polygon.getLayout();\n                }\n                var offset = flatCoordinates.length;\n                var ends = polygon.getEnds();\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] += offset;\n                }\n                extend(flatCoordinates, polygon.getFlatCoordinates());\n                endss.push(ends);\n            }\n            opt_layout = layout;\n            coordinates = flatCoordinates;\n            opt_endss = endss;\n        }\n        if (opt_layout !== undefined && opt_endss) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.endss_ = opt_endss;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed polygon to this multipolygon.\n     * @param {Polygon} polygon Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.appendPolygon = function (polygon) {\n        /** @type {Array<number>} */\n        var ends;\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = polygon.getFlatCoordinates().slice();\n            ends = polygon.getEnds().slice();\n            this.endss_.push();\n        }\n        else {\n            var offset = this.flatCoordinates.length;\n            extend(this.flatCoordinates, polygon.getFlatCoordinates());\n            ends = polygon.getEnds().slice();\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] += offset;\n            }\n        }\n        this.endss_.push(ends);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPolygon} Clone.\n     * @api\n     */\n    MultiPolygon.prototype.clone = function () {\n        var len = this.endss_.length;\n        var newEndss = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            newEndss[i] = this.endss_[i].slice();\n        }\n        var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n        multiPolygon.applyProperties(this);\n        return multiPolygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    MultiPolygon.prototype.containsXY = function (x, y) {\n        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the multipolygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    MultiPolygon.prototype.getArea = function () {\n        return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for multi-polygons.\n     *\n     * @param {boolean} [opt_right] Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n     * @api\n     */\n    MultiPolygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n    };\n    /**\n     * @return {Array<Array<number>>} Endss.\n     */\n    MultiPolygon.prototype.getEndss = function () {\n        return this.endss_;\n    };\n    /**\n     * @return {Array<number>} Flat interior points.\n     */\n    MultiPolygon.prototype.getFlatInteriorPoints = function () {\n        if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n            var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n            this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n            this.flatInteriorPointsRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoints_;\n    };\n    /**\n     * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n     * @return {MultiPoint} Interior points as XYM coordinates, where M is\n     * the length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    MultiPolygon.prototype.getInteriorPoints = function () {\n        return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    MultiPolygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {MultiPolygon} Simplified MultiPolygon.\n     * @protected\n     */\n    MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEndss = [];\n        simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n        return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n    };\n    /**\n     * Return the polygon at the specified index.\n     * @param {number} index Index.\n     * @return {Polygon} Polygon.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygon = function (index) {\n        if (index < 0 || this.endss_.length <= index) {\n            return null;\n        }\n        var offset;\n        if (index === 0) {\n            offset = 0;\n        }\n        else {\n            var prevEnds = this.endss_[index - 1];\n            offset = prevEnds[prevEnds.length - 1];\n        }\n        var ends = this.endss_[index].slice();\n        var end = ends[ends.length - 1];\n        if (offset !== 0) {\n            for (var i = 0, ii = ends.length; i < ii; ++i) {\n                ends[i] -= offset;\n            }\n        }\n        return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n    };\n    /**\n     * Return the polygons of this multipolygon.\n     * @return {Array<Polygon>} Polygons.\n     * @api\n     */\n    MultiPolygon.prototype.getPolygons = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var endss = this.endss_;\n        var polygons = [];\n        var offset = 0;\n        for (var i = 0, ii = endss.length; i < ii; ++i) {\n            var ends = endss[i].slice();\n            var end = ends[ends.length - 1];\n            if (offset !== 0) {\n                for (var j = 0, jj = ends.length; j < jj; ++j) {\n                    ends[j] -= offset;\n                }\n            }\n            var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n            polygons.push(polygon);\n            offset = end;\n        }\n        return polygons;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    MultiPolygon.prototype.getType = function () {\n        return GeometryType.MULTI_POLYGON;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPolygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the multipolygon.\n     * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 3);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n        if (endss.length === 0) {\n            this.flatCoordinates.length = 0;\n        }\n        else {\n            var lastEnds = endss[endss.length - 1];\n            this.flatCoordinates.length =\n                lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n        }\n        this.changed();\n    };\n    return MultiPolygon;\n}(SimpleGeometry));\nexport default MultiPolygon;\n//# sourceMappingURL=MultiPolygon.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport Units from '../proj/Units.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, create as createTransform, } from '../transform.js';\nimport { createEmpty, createOrUpdateEmpty, getHeight, returnOrUpdate, } from '../extent.js';\nimport { get as getProjection, getTransform } from '../proj.js';\nimport { memoizeOne } from '../functions.js';\nimport { transform2D } from './flat/transform.js';\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nvar Geometry = /** @class */ (function (_super) {\n    __extends(Geometry, _super);\n    function Geometry() {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        _this.extent_ = createEmpty();\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.extentRevision_ = -1;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.simplifiedGeometryRevision = 0;\n        /**\n         * Get a transformed and simplified version of the geometry.\n         * @abstract\n         * @param {number} revision The geometry revision.\n         * @param {number} squaredTolerance Squared tolerance.\n         * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n         * @return {Geometry} Simplified geometry.\n         */\n        _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, opt_transform) {\n            if (!opt_transform) {\n                return this.getSimplifiedGeometry(squaredTolerance);\n            }\n            var clone = this.clone();\n            clone.applyTransform(opt_transform);\n            return clone.getSimplifiedGeometry(squaredTolerance);\n        });\n        return _this;\n    }\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {\n        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @abstract\n     * @return {!Geometry} Clone.\n     */\n    Geometry.prototype.clone = function () {\n        return abstract();\n    };\n    /**\n     * @abstract\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        return abstract();\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Geometry.prototype.containsXY = function (x, y) {\n        var coord = this.getClosestPoint([x, y]);\n        return coord[0] === x && coord[1] === y;\n    };\n    /**\n     * Return the closest point of the geometry to the passed point as\n     * {@link module:ol/coordinate~Coordinate coordinate}.\n     * @param {import(\"../coordinate.js\").Coordinate} point Point.\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_closestPoint] Closest point.\n     * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n     * @api\n     */\n    Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {\n        var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n        this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n        return closestPoint;\n    };\n    /**\n     * Returns true if this geometry includes the specified coordinate. If the\n     * coordinate is on the boundary of the geometry, returns false.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains coordinate.\n     * @api\n     */\n    Geometry.prototype.intersectsCoordinate = function (coordinate) {\n        return this.containsXY(coordinate[0], coordinate[1]);\n    };\n    /**\n     * @abstract\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Geometry.prototype.computeExtent = function (extent) {\n        return abstract();\n    };\n    /**\n     * Get the extent of the geometry.\n     * @param {import(\"../extent.js\").Extent} [opt_extent] Extent.\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     * @api\n     */\n    Geometry.prototype.getExtent = function (opt_extent) {\n        if (this.extentRevision_ != this.getRevision()) {\n            var extent = this.computeExtent(this.extent_);\n            if (isNaN(extent[0]) || isNaN(extent[1])) {\n                createOrUpdateEmpty(extent);\n            }\n            this.extentRevision_ = this.getRevision();\n        }\n        return returnOrUpdate(this.extent_, opt_extent);\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} angle Rotation angle in radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    Geometry.prototype.rotate = function (angle, anchor) {\n        abstract();\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        abstract();\n    };\n    /**\n     * Create a simplified version of this geometry.  For linestrings, this uses\n     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n     * algorithm.  For polygons, a quantization-based\n     * simplification is used to preserve topology.\n     * @param {number} tolerance The tolerance distance for simplification.\n     * @return {Geometry} A new, simplified version of the original geometry.\n     * @api\n     */\n    Geometry.prototype.simplify = function (tolerance) {\n        return this.getSimplifiedGeometry(tolerance * tolerance);\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker\n     * algorithm.\n     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n     * @abstract\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Geometry} Simplified geometry.\n     */\n    Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        return abstract();\n    };\n    /**\n     * Get the type of this geometry.\n     * @abstract\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     */\n    Geometry.prototype.getType = function () {\n        return abstract();\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @abstract\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     */\n    Geometry.prototype.applyTransform = function (transformFn) {\n        abstract();\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @abstract\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     */\n    Geometry.prototype.intersectsExtent = function (extent) {\n        return abstract();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @abstract\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    Geometry.prototype.translate = function (deltaX, deltaY) {\n        abstract();\n    };\n    /**\n     * Transform each coordinate of the geometry from one coordinate reference\n     * system to another. The geometry is modified in place.\n     * For example, a line will be transformed to a line and a circle to a circle.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @return {Geometry} This geometry.  Note that original geometry is\n     *     modified in place.\n     * @api\n     */\n    Geometry.prototype.transform = function (source, destination) {\n        /** @type {import(\"../proj/Projection.js\").default} */\n        var sourceProj = getProjection(source);\n        var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS\n            ? function (inCoordinates, outCoordinates, stride) {\n                var pixelExtent = sourceProj.getExtent();\n                var projectedExtent = sourceProj.getWorldExtent();\n                var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n                composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n                transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n                return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n            }\n            : getTransform(sourceProj, destination);\n        this.applyTransform(transformFn);\n        return this;\n    };\n    return Geometry;\n}(BaseObject));\nexport default Geometry;\n//# sourceMappingURL=Geometry.js.map","/**\n * @module ol/geom/flat/closest\n */\nimport { lerp, squaredDistance as squaredDx } from '../../math.js';\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n    var x1 = flatCoordinates[offset1];\n    var y1 = flatCoordinates[offset1 + 1];\n    var dx = flatCoordinates[offset2] - x1;\n    var dy = flatCoordinates[offset2 + 1] - y1;\n    var offset;\n    if (dx === 0 && dy === 0) {\n        offset = offset1;\n    }\n    else {\n        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            offset = offset2;\n        }\n        else if (t > 0) {\n            for (var i = 0; i < stride; ++i) {\n                closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n            }\n            closestPoint.length = stride;\n            return;\n        }\n        else {\n            offset = offset1;\n        }\n    }\n    for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n    }\n    closestPoint.length = stride;\n}\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    for (offset += stride; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        var squaredDelta = squaredDx(x1, y1, x2, y2);\n        if (squaredDelta > max) {\n            max = squaredDelta;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n        offset = end;\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n        offset = ends[ends.length - 1];\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    if (offset == end) {\n        return minSquaredDistance;\n    }\n    var i, squaredDistance;\n    if (maxDelta === 0) {\n        // All points are identical, so just test the first point.\n        squaredDistance = squaredDx(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n        if (squaredDistance < minSquaredDistance) {\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = flatCoordinates[offset + i];\n            }\n            closestPoint.length = stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    }\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    var index = offset + stride;\n    while (index < end) {\n        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n        squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n        if (squaredDistance < minSquaredDistance) {\n            minSquaredDistance = squaredDistance;\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = tmpPoint[i];\n            }\n            closestPoint.length = stride;\n            index += stride;\n        }\n        else {\n            // Skip ahead multiple points, because we know that all the skipped\n            // points cannot be any closer than the closest point we have found so\n            // far.  We know this because we know how close the current point is, how\n            // close the closest point we have found so far is, and the maximum\n            // distance between consecutive points.  For example, if we're currently\n            // at distance 10, the best we've found so far is 3, and that the maximum\n            // distance between consecutive points is 2, then we'll need to skip at\n            // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n            // finding a closer point.  We use Math.max(..., 1) to ensure that we\n            // always advance at least one point, to avoid an infinite loop.\n            index +=\n                stride *\n                    Math.max(((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n                        maxDelta) |\n                        0, 1);\n        }\n    }\n    if (isRing) {\n        // Check the closing segment.\n        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n        squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n        if (squaredDistance < minSquaredDistance) {\n            minSquaredDistance = squaredDistance;\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = tmpPoint[i];\n            }\n            closestPoint.length = stride;\n        }\n    }\n    return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = end;\n    }\n    return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = ends[ends.length - 1];\n    }\n    return minSquaredDistance;\n}\n//# sourceMappingURL=closest.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/MultiPoint\n */\nimport GeometryType from './GeometryType.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { closestSquaredDistanceXY, containsXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nvar MultiPoint = /** @class */ (function (_super) {\n    __extends(MultiPoint, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function MultiPoint(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        if (opt_layout && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed point to this multipoint.\n     * @param {Point} point Point.\n     * @api\n     */\n    MultiPoint.prototype.appendPoint = function (point) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = point.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, point.getFlatCoordinates());\n        }\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!MultiPoint} Clone.\n     * @api\n     */\n    MultiPoint.prototype.clone = function () {\n        var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n        multiPoint.applyProperties(this);\n        return multiPoint;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var squaredDistance = squaredDx(x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n            if (squaredDistance < minSquaredDistance) {\n                minSquaredDistance = squaredDistance;\n                for (var j = 0; j < stride; ++j) {\n                    closestPoint[j] = flatCoordinates[i + j];\n                }\n                closestPoint.length = stride;\n            }\n        }\n        return minSquaredDistance;\n    };\n    /**\n     * Return the coordinates of the multipoint.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    MultiPoint.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the point at the specified index.\n     * @param {number} index Index.\n     * @return {Point} Point.\n     * @api\n     */\n    MultiPoint.prototype.getPoint = function (index) {\n        var n = !this.flatCoordinates\n            ? 0\n            : this.flatCoordinates.length / this.stride;\n        if (index < 0 || n <= index) {\n            return null;\n        }\n        return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);\n    };\n    /**\n     * Return the points of this multipoint.\n     * @return {Array<Point>} Points.\n     * @api\n     */\n    MultiPoint.prototype.getPoints = function () {\n        var flatCoordinates = this.flatCoordinates;\n        var layout = this.layout;\n        var stride = this.stride;\n        /** @type {Array<Point>} */\n        var points = [];\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n            points.push(point);\n        }\n        return points;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    MultiPoint.prototype.getType = function () {\n        return GeometryType.MULTI_POINT;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    MultiPoint.prototype.intersectsExtent = function (extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var stride = this.stride;\n        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n            var x = flatCoordinates[i];\n            var y = flatCoordinates[i + 1];\n            if (containsXY(extent, x, y)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Set the coordinates of the multipoint.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return MultiPoint;\n}(SimpleGeometry));\nexport default MultiPoint;\n//# sourceMappingURL=MultiPoint.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport { abstract } from '../util.js';\nimport { createOrUpdateFromFlatCoordinates, getCenter } from '../extent.js';\nimport { rotate, scale, transform2D, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nvar SimpleGeometry = /** @class */ (function (_super) {\n    __extends(SimpleGeometry, _super);\n    function SimpleGeometry() {\n        var _this = _super.call(this) || this;\n        /**\n         * @protected\n         * @type {import(\"./GeometryLayout.js\").default}\n         */\n        _this.layout = GeometryLayout.XY;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.stride = 2;\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        _this.flatCoordinates = null;\n        return _this;\n    }\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    SimpleGeometry.prototype.computeExtent = function (extent) {\n        return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    };\n    /**\n     * @abstract\n     * @return {Array<*>} Coordinates.\n     */\n    SimpleGeometry.prototype.getCoordinates = function () {\n        return abstract();\n    };\n    /**\n     * Return the first coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n     * @api\n     */\n    SimpleGeometry.prototype.getFirstCoordinate = function () {\n        return this.flatCoordinates.slice(0, this.stride);\n    };\n    /**\n     * @return {Array<number>} Flat coordinates.\n     */\n    SimpleGeometry.prototype.getFlatCoordinates = function () {\n        return this.flatCoordinates;\n    };\n    /**\n     * Return the last coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} Last point.\n     * @api\n     */\n    SimpleGeometry.prototype.getLastCoordinate = function () {\n        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n    };\n    /**\n     * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.\n     * @return {import(\"./GeometryLayout.js\").default} Layout.\n     * @api\n     */\n    SimpleGeometry.prototype.getLayout = function () {\n        return this.layout;\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     */\n    SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        if (this.simplifiedGeometryRevision !== this.getRevision()) {\n            this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n            this.simplifiedGeometryRevision = this.getRevision();\n        }\n        // If squaredTolerance is negative or if we know that simplification will not\n        // have any effect then just return this.\n        if (squaredTolerance < 0 ||\n            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n                squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {\n            return this;\n        }\n        var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n        var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n            return simplifiedGeometry;\n        }\n        else {\n            // Simplification did not actually remove any coordinates.  We now know\n            // that any calls to getSimplifiedGeometry with a squaredTolerance less\n            // than or equal to the current squaredTolerance will also not have any\n            // effect.  This allows us to short circuit simplification (saving CPU\n            // cycles) and prevents the cache of simplified geometries from filling\n            // up with useless identical copies of this geometry (saving memory).\n            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n            return this;\n        }\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     * @protected\n     */\n    SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        return this;\n    };\n    /**\n     * @return {number} Stride.\n     */\n    SimpleGeometry.prototype.getStride = function () {\n        return this.stride;\n    };\n    /**\n     * @param {import(\"./GeometryLayout.js\").default} layout Layout.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     */\n    SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {\n        this.stride = getStrideForLayout(layout);\n        this.layout = layout;\n        this.flatCoordinates = flatCoordinates;\n    };\n    /**\n     * @abstract\n     * @param {!Array<*>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {\n        abstract();\n    };\n    /**\n     * @param {import(\"./GeometryLayout.js\").default|undefined} layout Layout.\n     * @param {Array<*>} coordinates Coordinates.\n     * @param {number} nesting Nesting.\n     * @protected\n     */\n    SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {\n        /** @type {number} */\n        var stride;\n        if (layout) {\n            stride = getStrideForLayout(layout);\n        }\n        else {\n            for (var i = 0; i < nesting; ++i) {\n                if (coordinates.length === 0) {\n                    this.layout = GeometryLayout.XY;\n                    this.stride = 2;\n                    return;\n                }\n                else {\n                    coordinates = /** @type {Array} */ (coordinates[0]);\n                }\n            }\n            stride = coordinates.length;\n            layout = getLayoutForStride(stride);\n        }\n        this.layout = layout;\n        this.stride = stride;\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     * @api\n     */\n    SimpleGeometry.prototype.applyTransform = function (transformFn) {\n        if (this.flatCoordinates) {\n            transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n            this.changed();\n        }\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    SimpleGeometry.prototype.rotate = function (angle, anchor) {\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n            this.changed();\n        }\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        var sy = opt_sy;\n        if (sy === undefined) {\n            sy = sx;\n        }\n        var anchor = opt_anchor;\n        if (!anchor) {\n            anchor = getCenter(this.getExtent());\n        }\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n            this.changed();\n        }\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    SimpleGeometry.prototype.translate = function (deltaX, deltaY) {\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n            this.changed();\n        }\n    };\n    return SimpleGeometry;\n}(Geometry));\n/**\n * @param {number} stride Stride.\n * @return {import(\"./GeometryLayout.js\").default} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n    var layout;\n    if (stride == 2) {\n        layout = GeometryLayout.XY;\n    }\n    else if (stride == 3) {\n        layout = GeometryLayout.XYZ;\n    }\n    else if (stride == 4) {\n        layout = GeometryLayout.XYZM;\n    }\n    return /** @type {import(\"./GeometryLayout.js\").default} */ (layout);\n}\n/**\n * @param {import(\"./GeometryLayout.js\").default} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n    var stride;\n    if (layout == GeometryLayout.XY) {\n        stride = 2;\n    }\n    else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\n        stride = 3;\n    }\n    else if (layout == GeometryLayout.XYZM) {\n        stride = 4;\n    }\n    return /** @type {number} */ (stride);\n}\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, opt_dest) {\n    var flatCoordinates = simpleGeometry.getFlatCoordinates();\n    if (!flatCoordinates) {\n        return null;\n    }\n    else {\n        var stride = simpleGeometry.getStride();\n        return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);\n    }\n}\nexport default SimpleGeometry;\n//# sourceMappingURL=SimpleGeometry.js.map","/**\n * @module ol/geom/flat/deflate\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n    for (var i = 0, ii = coordinate.length; i < ii; ++i) {\n        flatCoordinates[offset++] = coordinate[i];\n    }\n    return offset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        var coordinate = coordinates[i];\n        for (var j = 0; j < stride; ++j) {\n            flatCoordinates[offset++] = coordinate[j];\n        }\n    }\n    return offset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>} [opt_ends] Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {\n    var ends = opt_ends ? opt_ends : [];\n    var i = 0;\n    for (var j = 0, jj = coordinatess.length; j < jj; ++j) {\n        var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);\n        ends[i++] = end;\n        offset = end;\n    }\n    ends.length = i;\n    return ends;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>} [opt_endss] Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\n    var endss = opt_endss ? opt_endss : [];\n    var i = 0;\n    for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {\n        var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\n        endss[i++] = ends;\n        offset = ends[ends.length - 1];\n    }\n    endss.length = i;\n    return endss;\n}\n//# sourceMappingURL=deflate.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport { binarySearch } from '../../array.js';\nimport { lerp } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>} [opt_dest] Destination.\n * @param {number} [opt_dimension] Destination dimension (default is `2`)\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {\n    var o, t;\n    var n = (end - offset) / stride;\n    if (n === 1) {\n        o = offset;\n    }\n    else if (n === 2) {\n        o = offset;\n        t = fraction;\n    }\n    else if (n !== 0) {\n        var x1 = flatCoordinates[offset];\n        var y1 = flatCoordinates[offset + 1];\n        var length_1 = 0;\n        var cumulativeLengths = [0];\n        for (var i = offset + stride; i < end; i += stride) {\n            var x2 = flatCoordinates[i];\n            var y2 = flatCoordinates[i + 1];\n            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            cumulativeLengths.push(length_1);\n            x1 = x2;\n            y1 = y2;\n        }\n        var target = fraction * length_1;\n        var index = binarySearch(cumulativeLengths, target);\n        if (index < 0) {\n            t =\n                (target - cumulativeLengths[-index - 2]) /\n                    (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n            o = offset + (-index - 2) * stride;\n        }\n        else {\n            o = offset + index * stride;\n        }\n    }\n    var dimension = opt_dimension > 1 ? opt_dimension : 2;\n    var dest = opt_dest ? opt_dest : new Array(dimension);\n    for (var i = 0; i < dimension; ++i) {\n        dest[i] =\n            o === undefined\n                ? NaN\n                : t === undefined\n                    ? flatCoordinates[o + i]\n                    : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n    if (end == offset) {\n        return null;\n    }\n    var coordinate;\n    if (m < flatCoordinates[offset + stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(offset, offset + stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    else if (flatCoordinates[end - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(end - stride, end);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    // FIXME use O(1) search\n    if (m == flatCoordinates[offset + stride - 1]) {\n        return flatCoordinates.slice(offset, offset + stride);\n    }\n    var lo = offset / stride;\n    var hi = end / stride;\n    while (lo < hi) {\n        var mid = (lo + hi) >> 1;\n        if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    var m0 = flatCoordinates[lo * stride - 1];\n    if (m == m0) {\n        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n    }\n    var m1 = flatCoordinates[(lo + 1) * stride - 1];\n    var t = (m - m0) / (m1 - m0);\n    coordinate = [];\n    for (var i = 0; i < stride - 1; ++i) {\n        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n    }\n    coordinate.push(m);\n    return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n    if (interpolate) {\n        return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n    }\n    var coordinate;\n    if (m < flatCoordinates[stride - 1]) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(0, stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    if (flatCoordinates[flatCoordinates.length - 1] < m) {\n        if (extrapolate) {\n            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n            coordinate[stride - 1] = m;\n            return coordinate;\n        }\n        else {\n            return null;\n        }\n    }\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        if (offset == end) {\n            continue;\n        }\n        if (m < flatCoordinates[offset + stride - 1]) {\n            return null;\n        }\n        else if (m <= flatCoordinates[end - 1]) {\n            return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n        }\n        offset = end;\n    }\n    return null;\n}\n//# sourceMappingURL=interpolate.js.map","/**\n * @module ol/geom/flat/area\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n    var twiceArea = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        twiceArea += y1 * x2 - x1 * y2;\n        x1 = x2;\n        y1 = y2;\n    }\n    return twiceArea / 2;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n    var area = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        area += linearRing(flatCoordinates, offset, end, stride);\n        offset = end;\n    }\n    return area;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n    var area = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        area += linearRings(flatCoordinates, offset, ends, stride);\n        offset = ends[ends.length - 1];\n    }\n    return area;\n}\n//# sourceMappingURL=area.js.map","/**\n * @module ol/geom/flat/inflate\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [opt_coordinates] Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {\n    var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        coordinates[i++] = flatCoordinates.slice(j, j + stride);\n    }\n    coordinates.length = i;\n    return coordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [opt_coordinatess] Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n    var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n    var i = 0;\n    for (var j = 0, jj = ends.length; j < jj; ++j) {\n        var end = ends[j];\n        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);\n        offset = end;\n    }\n    coordinatess.length = i;\n    return coordinatess;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [opt_coordinatesss]\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n    var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n    var i = 0;\n    for (var j = 0, jj = endss.length; j < jj; ++j) {\n        var ends = endss[j];\n        coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);\n        offset = ends[ends.length - 1];\n    }\n    coordinatesss.length = i;\n    return coordinatesss;\n}\n//# sourceMappingURL=inflate.js.map","/**\n * @module ol/geom/flat/transform\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var x = flatCoordinates[j];\n        var y = flatCoordinates[j + 1];\n        dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n        dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var anchorX = anchor[0];\n    var anchorY = anchor[1];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var deltaX = flatCoordinates[j] - anchorX;\n        var deltaY = flatCoordinates[j + 1] - anchorY;\n        dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n        dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var anchorX = anchor[0];\n    var anchorY = anchor[1];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var deltaX = flatCoordinates[j] - anchorX;\n        var deltaY = flatCoordinates[j + 1] - anchorY;\n        dest[i++] = anchorX + sx * deltaX;\n        dest[i++] = anchorY + sy * deltaY;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>} [opt_dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        dest[i++] = flatCoordinates[j] + deltaX;\n        dest[i++] = flatCoordinates[j + 1] + deltaY;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n//# sourceMappingURL=transform.js.map","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport { containsExtent, createEmpty, extendFlatCoordinates, intersects, intersectsSegment, } from '../../extent.js';\nimport { forEach as forEachSegment } from './segments.js';\nimport { linearRingContainsExtent, linearRingContainsXY } from './contains.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(flatCoordinates, offset, end, stride, extent) {\n    var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n    if (!intersects(extent, coordinatesExtent)) {\n        return false;\n    }\n    if (containsExtent(extent, coordinatesExtent)) {\n        return true;\n    }\n    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n        return true;\n    }\n    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n        return true;\n    }\n    return forEachSegment(flatCoordinates, offset, end, stride, \n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n        return intersectsSegment(extent, point1, point2);\n    });\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {\n            return true;\n        }\n        offset = ends[i];\n    }\n    return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {\n    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n        return true;\n    }\n    return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {\n    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n        return false;\n    }\n    if (ends.length === 1) {\n        return true;\n    }\n    for (var i = 1, ii = ends.length; i < ii; ++i) {\n        if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n            if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {\n            return true;\n        }\n        offset = ends[ends.length - 1];\n    }\n    return false;\n}\n//# sourceMappingURL=intersectsextent.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport Geometry from './Geometry.js';\nimport GeometryType from './GeometryType.js';\nimport { closestSquaredDistanceXY, createOrUpdateEmpty, extend, getCenter, } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry} objects.\n *\n * @api\n */\nvar GeometryCollection = /** @class */ (function (_super) {\n    __extends(GeometryCollection, _super);\n    /**\n     * @param {Array<Geometry>} [opt_geometries] Geometries.\n     */\n    function GeometryCollection(opt_geometries) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {Array<Geometry>}\n         */\n        _this.geometries_ = opt_geometries ? opt_geometries : null;\n        /**\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.changeEventsKeys_ = [];\n        _this.listenGeometriesChange_();\n        return _this;\n    }\n    /**\n     * @private\n     */\n    GeometryCollection.prototype.unlistenGeometriesChange_ = function () {\n        this.changeEventsKeys_.forEach(unlistenByKey);\n        this.changeEventsKeys_.length = 0;\n    };\n    /**\n     * @private\n     */\n    GeometryCollection.prototype.listenGeometriesChange_ = function () {\n        if (!this.geometries_) {\n            return;\n        }\n        for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {\n            this.changeEventsKeys_.push(listen(this.geometries_[i], EventType.CHANGE, this.changed, this));\n        }\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!GeometryCollection} Clone.\n     * @api\n     */\n    GeometryCollection.prototype.clone = function () {\n        var geometryCollection = new GeometryCollection(null);\n        geometryCollection.setGeometries(this.geometries_);\n        geometryCollection.applyProperties(this);\n        return geometryCollection;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    GeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);\n        }\n        return minSquaredDistance;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    GeometryCollection.prototype.containsXY = function (x, y) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].containsXY(x, y)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    GeometryCollection.prototype.computeExtent = function (extent) {\n        createOrUpdateEmpty(extent);\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            extend(extent, geometries[i].getExtent());\n        }\n        return extent;\n    };\n    /**\n     * Return the geometries that make up this geometry collection.\n     * @return {Array<Geometry>} Geometries.\n     * @api\n     */\n    GeometryCollection.prototype.getGeometries = function () {\n        return cloneGeometries(this.geometries_);\n    };\n    /**\n     * @return {Array<Geometry>} Geometries.\n     */\n    GeometryCollection.prototype.getGeometriesArray = function () {\n        return this.geometries_;\n    };\n    /**\n     * @return {Array<Geometry>} Geometries.\n     */\n    GeometryCollection.prototype.getGeometriesArrayRecursive = function () {\n        /** @type {Array<Geometry>} */\n        var geometriesArray = [];\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].getType() === this.getType()) {\n                geometriesArray = geometriesArray.concat(\n                /** @type {GeometryCollection} */ (geometries[i]).getGeometriesArrayRecursive());\n            }\n            else {\n                geometriesArray.push(geometries[i]);\n            }\n        }\n        return geometriesArray;\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {GeometryCollection} Simplified GeometryCollection.\n     */\n    GeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        if (this.simplifiedGeometryRevision !== this.getRevision()) {\n            this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n            this.simplifiedGeometryRevision = this.getRevision();\n        }\n        if (squaredTolerance < 0 ||\n            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n                squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {\n            return this;\n        }\n        var simplifiedGeometries = [];\n        var geometries = this.geometries_;\n        var simplified = false;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            var geometry = geometries[i];\n            var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n            simplifiedGeometries.push(simplifiedGeometry);\n            if (simplifiedGeometry !== geometry) {\n                simplified = true;\n            }\n        }\n        if (simplified) {\n            var simplifiedGeometryCollection = new GeometryCollection(null);\n            simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n            return simplifiedGeometryCollection;\n        }\n        else {\n            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n            return this;\n        }\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    GeometryCollection.prototype.getType = function () {\n        return GeometryType.GEOMETRY_COLLECTION;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    GeometryCollection.prototype.intersectsExtent = function (extent) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].intersectsExtent(extent)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {boolean} Is empty.\n     */\n    GeometryCollection.prototype.isEmpty = function () {\n        return this.geometries_.length === 0;\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    GeometryCollection.prototype.rotate = function (angle, anchor) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].rotate(angle, anchor);\n        }\n        this.changed();\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    GeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        var anchor = opt_anchor;\n        if (!anchor) {\n            anchor = getCenter(this.getExtent());\n        }\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].scale(sx, opt_sy, anchor);\n        }\n        this.changed();\n    };\n    /**\n     * Set the geometries that make up this geometry collection.\n     * @param {Array<Geometry>} geometries Geometries.\n     * @api\n     */\n    GeometryCollection.prototype.setGeometries = function (geometries) {\n        this.setGeometriesArray(cloneGeometries(geometries));\n    };\n    /**\n     * @param {Array<Geometry>} geometries Geometries.\n     */\n    GeometryCollection.prototype.setGeometriesArray = function (geometries) {\n        this.unlistenGeometriesChange_();\n        this.geometries_ = geometries;\n        this.listenGeometriesChange_();\n        this.changed();\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     * @api\n     */\n    GeometryCollection.prototype.applyTransform = function (transformFn) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].applyTransform(transformFn);\n        }\n        this.changed();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    GeometryCollection.prototype.translate = function (deltaX, deltaY) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].translate(deltaX, deltaY);\n        }\n        this.changed();\n    };\n    /**\n     * Clean up.\n     */\n    GeometryCollection.prototype.disposeInternal = function () {\n        this.unlistenGeometriesChange_();\n        _super.prototype.disposeInternal.call(this);\n    };\n    return GeometryCollection;\n}(Geometry));\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n    var clonedGeometries = [];\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        clonedGeometries.push(geometries[i].clone());\n    }\n    return clonedGeometries;\n}\nexport default GeometryCollection;\n//# sourceMappingURL=GeometryCollection.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Point\n */\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { containsXY, createOrUpdateFromCoordinate } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nvar Point = /** @class */ (function (_super) {\n    __extends(Point, _super);\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function Point(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        _this.setCoordinates(coordinates, opt_layout);\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Point} Clone.\n     * @api\n     */\n    Point.prototype.clone = function () {\n        var point = new Point(this.flatCoordinates.slice(), this.layout);\n        point.applyProperties(this);\n        return point;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var squaredDistance = squaredDx(x, y, flatCoordinates[0], flatCoordinates[1]);\n        if (squaredDistance < minSquaredDistance) {\n            var stride = this.stride;\n            for (var i = 0; i < stride; ++i) {\n                closestPoint[i] = flatCoordinates[i];\n            }\n            closestPoint.length = stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    };\n    /**\n     * Return the coordinate of the point.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n     * @api\n     */\n    Point.prototype.getCoordinates = function () {\n        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Point.prototype.computeExtent = function (extent) {\n        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    Point.prototype.getType = function () {\n        return GeometryType.POINT;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Point.prototype.intersectsExtent = function (extent) {\n        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n    };\n    /**\n     * @param {!Array<*>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Point.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 0);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return Point;\n}(SimpleGeometry));\nexport default Point;\n//# sourceMappingURL=Point.js.map","/**\n * @module ol/geom/GeometryType\n */\n/**\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, `'Circle'`.\n * @enum {string}\n */\nexport default {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    LINEAR_RING: 'LinearRing',\n    POLYGON: 'Polygon',\n    MULTI_POINT: 'MultiPoint',\n    MULTI_LINE_STRING: 'MultiLineString',\n    MULTI_POLYGON: 'MultiPolygon',\n    GEOMETRY_COLLECTION: 'GeometryCollection',\n    CIRCLE: 'Circle',\n};\n//# sourceMappingURL=GeometryType.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Circle\n */\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { createOrUpdate, forEachCorner, intersects } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { rotate, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    /**\n     * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n     *     For internal use, flat coordinates in combination with `opt_layout` and no\n     *     `opt_radius` are also accepted.\n     * @param {number} [opt_radius] Radius.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     */\n    function Circle(center, opt_radius, opt_layout) {\n        var _this = _super.call(this) || this;\n        if (opt_layout !== undefined && opt_radius === undefined) {\n            _this.setFlatCoordinates(opt_layout, center);\n        }\n        else {\n            var radius = opt_radius ? opt_radius : 0;\n            _this.setCenterAndRadius(center, radius, opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Circle} Clone.\n     * @api\n     */\n    Circle.prototype.clone = function () {\n        var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n        circle.applyProperties(this);\n        return circle;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        var squaredDistance = dx * dx + dy * dy;\n        if (squaredDistance < minSquaredDistance) {\n            if (squaredDistance === 0) {\n                for (var i = 0; i < this.stride; ++i) {\n                    closestPoint[i] = flatCoordinates[i];\n                }\n            }\n            else {\n                var delta = this.getRadius() / Math.sqrt(squaredDistance);\n                closestPoint[0] = flatCoordinates[0] + delta * dx;\n                closestPoint[1] = flatCoordinates[1] + delta * dy;\n                for (var i = 2; i < this.stride; ++i) {\n                    closestPoint[i] = flatCoordinates[i];\n                }\n            }\n            closestPoint.length = this.stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Circle.prototype.containsXY = function (x, y) {\n        var flatCoordinates = this.flatCoordinates;\n        var dx = x - flatCoordinates[0];\n        var dy = y - flatCoordinates[1];\n        return dx * dx + dy * dy <= this.getRadiusSquared_();\n    };\n    /**\n     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n     * @return {import(\"../coordinate.js\").Coordinate} Center.\n     * @api\n     */\n    Circle.prototype.getCenter = function () {\n        return this.flatCoordinates.slice(0, this.stride);\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Circle.prototype.computeExtent = function (extent) {\n        var flatCoordinates = this.flatCoordinates;\n        var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n        return createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);\n    };\n    /**\n     * Return the radius of the circle.\n     * @return {number} Radius.\n     * @api\n     */\n    Circle.prototype.getRadius = function () {\n        return Math.sqrt(this.getRadiusSquared_());\n    };\n    /**\n     * @private\n     * @return {number} Radius squared.\n     */\n    Circle.prototype.getRadiusSquared_ = function () {\n        var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n        var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n        return dx * dx + dy * dy;\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    Circle.prototype.getType = function () {\n        return GeometryType.CIRCLE;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Circle.prototype.intersectsExtent = function (extent) {\n        var circleExtent = this.getExtent();\n        if (intersects(extent, circleExtent)) {\n            var center = this.getCenter();\n            if (extent[0] <= center[0] && extent[2] >= center[0]) {\n                return true;\n            }\n            if (extent[1] <= center[1] && extent[3] >= center[1]) {\n                return true;\n            }\n            return forEachCorner(extent, this.intersectsCoordinate.bind(this));\n        }\n        return false;\n    };\n    /**\n     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n     * @param {import(\"../coordinate.js\").Coordinate} center Center.\n     * @api\n     */\n    Circle.prototype.setCenter = function (center) {\n        var stride = this.stride;\n        var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n        var flatCoordinates = center.slice();\n        flatCoordinates[stride] = flatCoordinates[0] + radius;\n        for (var i = 1; i < stride; ++i) {\n            flatCoordinates[stride + i] = center[i];\n        }\n        this.setFlatCoordinates(this.layout, flatCoordinates);\n        this.changed();\n    };\n    /**\n     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n     * number) of the circle.\n     * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n     * @param {number} radius Radius.\n     * @param {import(\"./GeometryLayout.js\").default} [opt_layout] Layout.\n     * @api\n     */\n    Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {\n        this.setLayout(opt_layout, center, 0);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        /** @type {Array<number>} */\n        var flatCoordinates = this.flatCoordinates;\n        var offset = deflateCoordinate(flatCoordinates, 0, center, this.stride);\n        flatCoordinates[offset++] = flatCoordinates[0] + radius;\n        for (var i = 1, ii = this.stride; i < ii; ++i) {\n            flatCoordinates[offset++] = flatCoordinates[i];\n        }\n        flatCoordinates.length = offset;\n        this.changed();\n    };\n    Circle.prototype.getCoordinates = function () {\n        return null;\n    };\n    Circle.prototype.setCoordinates = function (coordinates, opt_layout) { };\n    /**\n     * Set the radius of the circle. The radius is in the units of the projection.\n     * @param {number} radius Radius.\n     * @api\n     */\n    Circle.prototype.setRadius = function (radius) {\n        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n        this.changed();\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    Circle.prototype.rotate = function (angle, anchor) {\n        var center = this.getCenter();\n        var stride = this.getStride();\n        this.setCenter(rotate(center, 0, center.length, stride, angle, anchor, center));\n        this.changed();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    Circle.prototype.translate = function (deltaX, deltaY) {\n        var center = this.getCenter();\n        var stride = this.getStride();\n        this.setCenter(translate(center, 0, center.length, stride, deltaX, deltaY, center));\n        this.changed();\n    };\n    return Circle;\n}(SimpleGeometry));\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n//# sourceMappingURL=Circle.js.map","/**\n * @module ol/geom/flat/segments\n */\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n    var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    var point2 = [];\n    var ret;\n    for (; offset + stride < end; offset += stride) {\n        point2[0] = flatCoordinates[offset + stride];\n        point2[1] = flatCoordinates[offset + stride + 1];\n        ret = callback(point1, point2);\n        if (ret) {\n            return ret;\n        }\n        point1[0] = point2[0];\n        point1[1] = point2[1];\n    }\n    return false;\n}\n//# sourceMappingURL=segments.js.map"],"sourceRoot":""}