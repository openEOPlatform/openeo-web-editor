{"version":3,"sources":["webpack:///./node_modules/ol/ViewHint.js","webpack:///./node_modules/ol/TileQueue.js","webpack:///./node_modules/ol/Tile.js","webpack:///./node_modules/ol/TileCache.js","webpack:///./node_modules/ol/ViewProperty.js","webpack:///./node_modules/ol/View.js","webpack:///./node_modules/ol/TileState.js","webpack:///./node_modules/ol/TileRange.js"],"names":["ANIMATING","INTERACTING","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","TileQueue","_super","tilePriorityFunction","tileChangeCallback","_this","element","apply","getKey","boundHandleTileChange_","handleTileChange","bind","tileChangeCallback_","tilesLoading_","tilesLoadingKeys_","enqueue","added","tile","addEventListener","CHANGE","getTilesLoading","event","state","getState","LOADED","ERROR","EMPTY","removeEventListener","tileKey","loadMoreTiles","maxTotalLoading","maxNewLoads","newLoads","getCount","dequeue","IDLE","load","getTilePriority","frameState","tileSourceKey","tileCenter","tileResolution","wantedTiles","center","viewState","deltaX","deltaY","Math","log","sqrt","Tile","tileCoord","opt_options","options","interimTile","key","transition_","undefined","transition","transitionStarts_","interpolate","changed","dispatchEvent","release","getInterimTile","refreshInterimChain","prev","LOADING","getTileCoord","setState","Error","getAlpha","id","time","start","delta","inTransition","endTransition","TileCache","arguments","expireCache","usedTiles","canExpireCache","peekLast","pop","pruneExceptNewestZ","peekFirstKey","z","forEach","remove","CENTER","RESOLUTION","ROTATION","DEFAULT_MIN_ZOOM","View","on","once","un","hints_","animations_","updateAnimationKey_","projection_","projection","viewportSize_","targetCenter_","targetResolution_","targetRotation_","nextCenter_","nextResolution_","nextRotation_","cancelAnchor_","extent","applyOptions_","properties","ViewProperty","setProperties","resolutionConstraintInfo","createResolutionConstraint","maxResolution_","maxResolution","minResolution_","minResolution","zoomFactor_","zoomFactor","resolutions_","resolutions","padding_","padding","minZoom_","minZoom","centerConstraint","createCenterConstraint","resolutionConstraint","constraint","rotationConstraint","createRotationConstraint","constraints_","resolution","rotation","setRotation","setCenterInternal","setResolution","zoom","setZoom","defineProperty","get","set","oldPadding","getCenter","newPadding","getResolution","offsetX","offsetY","enumerable","configurable","getUpdatedOptions_","newOptions","getProperties","getZoom","getCenterInternal","getRotation","animate","var_args","isDef","getAnimating","resolveConstraints","args","length","i","getProjection","anchor","animateInternal","callback","animationCount","Date","now","slice","series","animation","complete","duration","easing","sourceCenter","targetCenter","sourceResolution","targetResolution","getResolutionForZoom","sourceRotation","PI","targetRotation","isNoopAnimation","push","setHint","ViewHint","updateAnimations_","animationCallback","getInteracting","cancelAnimations","ii","j","jj","NaN","cancelAnimationFrame","more","seriesComplete","elapsed","fraction","progress","x0","y0","x1","y1","x","y","size","getViewportSize_","constrainedResolution","calculateCenterZoom","applyTargetState_","constrainedRotation","calculateCenterRotate","filter","Boolean","requestAnimationFrame","currentCenter","currentResolution","opt_rotation","w","h","abs","cos","sin","setViewportSize","opt_size","isArray","getConstraints","getConstrainResolution","getHints","opt_hints","calculateExtent","calculateExtentInternal","getViewportSizeMinusPadding_","getMaxResolution","getMinResolution","getMaxZoom","getZoomForResolution","setMaxZoom","maxZoom","getMinZoom","setMinZoom","setConstrainResolution","enabled","constrainResolution","getResolutions","getResolutionForExtent","getResolutionForExtentInternal","xResolution","yResolution","max","getResolutionForValueFunction","opt_power","power","getConstrainedResolution","value","pow","getValueForResolutionFunction","logPower","reducedSize","calculateCenterOn","nextCenter","nextResolution","nextRotation","offset","nearest","baseLevel","floor","fit","geometryOrExtent","geometry","getType","GeometryType","CIRCLE","getExtent","rotate","userProjection","clone","transform","fitInternal","rotatedExtentForGeometry","cosAngle","sinAngle","coords","getFlatCoordinates","stride","getStride","minRotX","Infinity","minRotY","maxRotX","maxRotY","rotX","rotY","min","rotatedExtent","isNaN","centerRot","centerX","centerY","getConstrainedCenter","centerOn","coordinate","position","centerOnInternal","calculateCenterShift","centerShift","shiftedCenter","adjustCenter","deltaCoordinates","setCenter","adjustCenterInternal","adjustResolution","ratio","opt_anchor","adjustResolutionInternal","isMoving","newResolution","adjustZoom","adjustRotation","adjustRotationInternal","newRotation","hint","opt_doNotCancelAnims","opt_forceMoving","newCenter","opt_duration","opt_resolutionDirection","direction","beginInteraction","endInteraction","endInteractionInternal","opt_targetResolution","getConstrainedZoom","targetZoom","opt_direction","targetRes","returnValue","setTimeout","smooth","smoothExtentConstraint","constrainOnlyCenter","multiWorld","isGlobal","defaultMaxZoom","defaultZoomFactor","smoothResolutionConstraint","showFullExtent","projExtent","Units","DEGREES","getMetersPerUnit","defaultMaxResolution","defaultMinResolution","enableRotation","constrainRotation","TileRange","minX","maxX","minY","maxY","contains","containsXY","containsTileRange","tileRange","equals","extend","getHeight","getSize","getWidth","intersects","createOrUpdate"],"mappings":"qKAMe,QACXA,UAAW,EACXC,YAAa,I,oCCRjB,0EAAIC,EAAwC,WACxC,IAAIC,EAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,KACzFP,EAAcC,EAAGC,IAE5B,OAAO,SAAUD,EAAGC,GAChB,GAAiB,oBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIS,UAAU,uBAAyBC,OAAOV,GAAK,iCAE7D,SAASW,IAAOC,KAAKC,YAAcd,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOa,OAAOd,IAAMW,EAAGL,UAAYN,EAAEM,UAAW,IAAIK,IAZ3C,GAwBxCI,EAA2B,SAAUC,GAMrC,SAASD,EAAUE,EAAsBC,GACrC,IAAIC,EAAQH,EAAOR,KAAKI,MAKxB,SAAUQ,GACN,OAAOH,EAAqBI,MAAM,KAAMD,MAM5C,SAAUA,GACN,OAAmDA,EAAQ,GAAIE,aAC7DV,KAkBN,OAhBAO,EAAMI,uBAAyBJ,EAAMK,iBAAiBC,KAAKN,GAK3DA,EAAMO,oBAAsBR,EAK5BC,EAAMQ,cAAgB,EAKtBR,EAAMS,kBAAoB,GACnBT,EA4DX,OAlGAtB,EAAUkB,EAAWC,GA4CrBD,EAAUT,UAAUuB,QAAU,SAAUT,GACpC,IAAIU,EAAQd,EAAOV,UAAUuB,QAAQrB,KAAKI,KAAMQ,GAChD,GAAIU,EAAO,CACP,IAAIC,EAAOX,EAAQ,GACnBW,EAAKC,iBAAiB,OAAUC,OAAQrB,KAAKW,wBAEjD,OAAOO,GAKXf,EAAUT,UAAU4B,gBAAkB,WAClC,OAAOtB,KAAKe,eAMhBZ,EAAUT,UAAUkB,iBAAmB,SAAUW,GAC7C,IAAIJ,EAAmDI,EAAY,OAC/DC,EAAQL,EAAKM,WACjB,GAAID,IAAU,OAAUE,QACpBF,IAAU,OAAUG,OACpBH,IAAU,OAAUI,MAAO,CAC3BT,EAAKU,oBAAoB,OAAUR,OAAQrB,KAAKW,wBAChD,IAAImB,EAAUX,EAAKT,SACfoB,KAAW9B,KAAKgB,2BACThB,KAAKgB,kBAAkBc,KAC5B9B,KAAKe,eAEXf,KAAKc,wBAObX,EAAUT,UAAUqC,cAAgB,SAAUC,EAAiBC,GAC3D,IACIT,EAAOL,EAAMW,EADbI,EAAW,EAEf,MAAOlC,KAAKe,cAAgBiB,GACxBE,EAAWD,GACXjC,KAAKmC,WAAa,EAClBhB,EAAmDnB,KAAKoC,UAAU,GAClEN,EAAUX,EAAKT,SACfc,EAAQL,EAAKM,WACTD,IAAU,OAAUa,MAAUP,KAAW9B,KAAKgB,oBAC9ChB,KAAKgB,kBAAkBc,IAAW,IAChC9B,KAAKe,gBACLmB,EACFf,EAAKmB,SAIVnC,EAnGmB,CAoG5B,QAUK,SAASoC,EAAgBC,EAAYrB,EAAMsB,EAAeC,EAAYC,GAGzE,IAAKH,KAAgBC,KAAiBD,EAAWI,aAC7C,OAAO,OAEX,IAAKJ,EAAWI,YAAYH,GAAetB,EAAKT,UAC5C,OAAO,OAQX,IAAImC,EAASL,EAAWM,UAAUD,OAC9BE,EAASL,EAAW,GAAKG,EAAO,GAChCG,EAASN,EAAW,GAAKG,EAAO,GACpC,OAAQ,MAAQI,KAAKC,IAAIP,GACrBM,KAAKE,KAAKJ,EAASA,EAASC,EAASA,GAAUL,EA5BxC,U,oCC7Hf,gEAAI1D,EAAwC,WACxC,IAAIC,EAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,KACzFP,EAAcC,EAAGC,IAE5B,OAAO,SAAUD,EAAGC,GAChB,GAAiB,oBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIS,UAAU,uBAAyBC,OAAOV,GAAK,iCAE7D,SAASW,IAAOC,KAAKC,YAAcd,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOa,OAAOd,IAAMW,EAAGL,UAAYN,EAAEM,UAAW,IAAIK,IAZ3C,GAuFxCqD,EAAsB,SAAUhD,GAOhC,SAASgD,EAAKC,EAAW7B,EAAO8B,GAC5B,IAAI/C,EAAQH,EAAOR,KAAKI,OAASA,KAC7BuD,EAAUD,GAA4B,GAwC1C,OApCA/C,EAAM8C,UAAYA,EAKlB9C,EAAMiB,MAAQA,EAOdjB,EAAMiD,YAAc,KAOpBjD,EAAMkD,IAAM,GAKZlD,EAAMmD,iBACqBC,IAAvBJ,EAAQK,WAA2B,IAAML,EAAQK,WAMrDrD,EAAMsD,kBAAoB,GAI1BtD,EAAMuD,cAAgBP,EAAQO,YACvBvD,EAwKX,OAxNAtB,EAAUmE,EAAMhD,GAqDhBgD,EAAK1D,UAAUqE,QAAU,WACrB/D,KAAKgE,cAAc,OAAU3C,SAKjC+B,EAAK1D,UAAUuE,QAAU,aAIzBb,EAAK1D,UAAUgB,OAAS,WACpB,OAAOV,KAAKyD,IAAM,IAAMzD,KAAKqD,WAQjCD,EAAK1D,UAAUwE,eAAiB,WAC5B,IAAKlE,KAAKwD,YAEN,OAAOxD,KAEX,IAAImB,EAAOnB,KAAKwD,YAKhB,EAAG,CACC,GAAIrC,EAAKM,YAAc,OAAUC,OAI7B,OADA1B,KAAK0D,YAAc,EACZvC,EAEXA,EAAOA,EAAKqC,kBACPrC,GAET,OAAOnB,MAMXoD,EAAK1D,UAAUyE,oBAAsB,WACjC,GAAKnE,KAAKwD,YAAV,CAGA,IAAIrC,EAAOnB,KAAKwD,YAIZY,EAAOpE,KACX,EAAG,CACC,GAAImB,EAAKM,YAAc,OAAUC,OAAQ,CAIrCP,EAAKqC,YAAc,KACnB,MAEKrC,EAAKM,YAAc,OAAU4C,QAGlCD,EAAOjD,EAEFA,EAAKM,YAAc,OAAUY,KAGlC+B,EAAKZ,YAAcrC,EAAKqC,YAGxBY,EAAOjD,EAEXA,EAAOiD,EAAKZ,kBACPrC,KAObiC,EAAK1D,UAAU4E,aAAe,WAC1B,OAAOtE,KAAKqD,WAKhBD,EAAK1D,UAAU+B,SAAW,WACtB,OAAOzB,KAAKwB,OAUhB4B,EAAK1D,UAAU6E,SAAW,SAAU/C,GAChC,GAAIxB,KAAKwB,QAAU,OAAUG,OAAS3B,KAAKwB,MAAQA,EAC/C,MAAM,IAAIgD,MAAM,gCAEpBxE,KAAKwB,MAAQA,EACbxB,KAAK+D,WASTX,EAAK1D,UAAU4C,KAAO,WAClB,kBAQJc,EAAK1D,UAAU+E,SAAW,SAAUC,EAAIC,GACpC,IAAK3E,KAAK0D,YACN,OAAO,EAEX,IAAIkB,EAAQ5E,KAAK6D,kBAAkBa,GACnC,GAAKE,GAIA,IAAe,IAAXA,EACL,OAAO,OAJPA,EAAQD,EACR3E,KAAK6D,kBAAkBa,GAAME,EAKjC,IAAIC,EAAQF,EAAOC,EAAQ,IAAO,GAClC,OAAIC,GAAS7E,KAAK0D,YACP,EAEJ,eAAOmB,EAAQ7E,KAAK0D,cAS/BN,EAAK1D,UAAUoF,aAAe,SAAUJ,GACpC,QAAK1E,KAAK0D,cAG6B,IAAhC1D,KAAK6D,kBAAkBa,IAMlCtB,EAAK1D,UAAUqF,cAAgB,SAAUL,GACjC1E,KAAK0D,cACL1D,KAAK6D,kBAAkBa,IAAO,IAG/BtB,EAzNc,CA0NvB,QACa,U,oCClTf,4BAAInE,EAAwC,WACxC,IAAIC,EAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,KACzFP,EAAcC,EAAGC,IAE5B,OAAO,SAAUD,EAAGC,GAChB,GAAiB,oBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIS,UAAU,uBAAyBC,OAAOV,GAAK,iCAE7D,SAASW,IAAOC,KAAKC,YAAcd,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOa,OAAOd,IAAMW,EAAGL,UAAYN,EAAEM,UAAW,IAAIK,IAZ3C,GAoBxCiF,EAA2B,SAAU5E,GAErC,SAAS4E,IACL,OAAkB,OAAX5E,GAAmBA,EAAOK,MAAMT,KAAMiF,YAAcjF,KAiC/D,OAnCAf,EAAU+F,EAAW5E,GAOrB4E,EAAUtF,UAAUwF,YAAc,SAAUC,GACxC,MAAOnF,KAAKoF,iBAAkB,CAC1B,IAAIjE,EAAOnB,KAAKqF,WAChB,GAAIlE,EAAKT,WAAYyE,EACjB,MAGAnF,KAAKsF,MAAMrB,YAOvBe,EAAUtF,UAAU6F,mBAAqB,WACrC,GAAwB,IAApBvF,KAAKmC,WAAT,CAGA,IAAIsB,EAAMzD,KAAKwF,eACXnC,EAAY,eAAQI,GACpBgC,EAAIpC,EAAU,GAClBrD,KAAK0F,QAAQ,SAAUvE,GACfA,EAAKkC,UAAU,KAAOoC,IACtBzF,KAAK2F,OAAO,eAAOxE,EAAKkC,YACxBlC,EAAK8C,YAEXpD,KAAKb,SAEJgF,EApCmB,CAqC5B,QACa,U,sFCpDA,GACXY,OAAQ,SACRC,WAAY,aACZC,SAAU,Y,wKCTV7G,EAAwC,WACxC,IAAIC,EAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,KACzFP,EAAcC,EAAGC,IAE5B,OAAO,SAAUD,EAAGC,GAChB,GAAiB,oBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIS,UAAU,uBAAyBC,OAAOV,GAAK,iCAE7D,SAASW,IAAOC,KAAKC,YAAcd,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOa,OAAOd,IAAMW,EAAGL,UAAYN,EAAEM,UAAW,IAAIK,IAZ3C,GAwMxCgG,EAAmB,EAkFnB,EAAsB,SAAU3F,GAKhC,SAAS4F,EAAK1C,GACV,IAAI/C,EAAQH,EAAOR,KAAKI,OAASA,KAIjCO,EAAM0F,GAIN1F,EAAM2F,KAIN3F,EAAM4F,GACN,IAAI5C,EAAU,eAAO,GAAID,GAwEzB,OAnEA/C,EAAM6F,OAAS,CAAC,EAAG,GAKnB7F,EAAM8F,YAAc,GAKpB9F,EAAM+F,oBAMN/F,EAAMgG,YAAc,eAAiBhD,EAAQiD,WAAY,aAKzDjG,EAAMkG,cAAgB,CAAC,IAAK,KAK5BlG,EAAMmG,cAAgB,KAKtBnG,EAAMoG,kBAKNpG,EAAMqG,gBAKNrG,EAAMsG,YAAc,KAKpBtG,EAAMuG,gBAKNvG,EAAMwG,cAKNxG,EAAMyG,mBAAgBrD,EAClBJ,EAAQiD,YACR,iBAEAjD,EAAQV,SACRU,EAAQV,OAAS,eAAmBU,EAAQV,OAAQtC,EAAMgG,cAE1DhD,EAAQ0D,SACR1D,EAAQ0D,OAAS,eAAe1D,EAAQ0D,OAAQ1G,EAAMgG,cAE1DhG,EAAM2G,cAAc3D,GACbhD,EAkuCX,OA5zCAtB,EAAU+G,EAAM5F,GAgGhB4F,EAAKtG,UAAUwH,cAAgB,SAAU3D,GACrC,IAAI4D,EAAa,eAAO,GAAI5D,GAC5B,IAAK,IAAIE,KAAO2D,SACLD,EAAW1D,GAEtBzD,KAAKqH,cAAcF,GAAY,GAC/B,IAAIG,EAA2BC,EAA2BhE,GAK1DvD,KAAKwH,eAAiBF,EAAyBG,cAK/CzH,KAAK0H,eAAiBJ,EAAyBK,cAK/C3H,KAAK4H,YAAcN,EAAyBO,WAK5C7H,KAAK8H,aAAevE,EAAQwE,YAK5B/H,KAAKgI,SAAWzE,EAAQ0E,QAKxBjI,KAAKkI,SAAWZ,EAAyBa,QACzC,IAAIC,EAAmBC,EAAuB9E,GAC1C+E,EAAuBhB,EAAyBiB,WAChDC,EAAqBC,EAAyBlF,GAKlDvD,KAAK0I,aAAe,CAChB7F,OAAQuF,EACRO,WAAYL,EACZM,SAAUJ,GAEdxI,KAAK6I,iBAAiClF,IAArBJ,EAAQqF,SAAyBrF,EAAQqF,SAAW,GACrE5I,KAAK8I,uBAAqCnF,IAAnBJ,EAAQV,OAAuBU,EAAQV,OAAS,WAC5Cc,IAAvBJ,EAAQoF,WACR3I,KAAK+I,cAAcxF,EAAQoF,iBAELhF,IAAjBJ,EAAQyF,MACbhJ,KAAKiJ,QAAQ1F,EAAQyF,OAG7B3J,OAAO6J,eAAelD,EAAKtG,UAAW,UAAW,CAU7CyJ,IAAK,WACD,OAAOnJ,KAAKgI,UAEhBoB,IAAK,SAAUnB,GACX,IAAIoB,EAAarJ,KAAKgI,SACtBhI,KAAKgI,SAAWC,EAChB,IAAIpF,EAAS7C,KAAKsJ,YAClB,GAAIzG,EAAQ,CACR,IAAI0G,EAAatB,GAAW,CAAC,EAAG,EAAG,EAAG,GACtCoB,EAAaA,GAAc,CAAC,EAAG,EAAG,EAAG,GACrC,IAAIV,EAAa3I,KAAKwJ,gBAClBC,EAAWd,EAAa,GACvBY,EAAW,GAAKF,EAAW,GAAKA,EAAW,GAAKE,EAAW,IAC5DG,EAAWf,EAAa,GACvBY,EAAW,GAAKF,EAAW,GAAKA,EAAW,GAAKE,EAAW,IAChEvJ,KAAK8I,kBAAkB,CAACjG,EAAO,GAAK4G,EAAS5G,EAAO,GAAK6G,MAGjEC,YAAY,EACZC,cAAc,IAUlB5D,EAAKtG,UAAUmK,mBAAqB,SAAUC,GAC1C,IAAIvG,EAAUvD,KAAK+J,gBAYnB,YAV2BpG,IAAvBJ,EAAQoF,WACRpF,EAAQoF,WAAa3I,KAAKwJ,gBAG1BjG,EAAQyF,KAAOhJ,KAAKgK,UAGxBzG,EAAQV,OAAS7C,KAAKiK,oBAEtB1G,EAAQqF,SAAW5I,KAAKkK,cACjB,eAAO,GAAI3G,EAASuG,IAmC/B9D,EAAKtG,UAAUyK,QAAU,SAAUC,GAC3BpK,KAAKqK,UAAYrK,KAAKsK,gBACtBtK,KAAKuK,mBAAmB,GAG5B,IADA,IAAIC,EAAO,IAAIhL,MAAMyF,UAAUwF,QACtBC,EAAI,EAAGA,EAAIF,EAAKC,SAAUC,EAAG,CAClC,IAAInH,EAAU0B,UAAUyF,GACpBnH,EAAQV,SACRU,EAAU,eAAO,GAAIA,GACrBA,EAAQV,OAAS,eAAmBU,EAAQV,OAAQ7C,KAAK2K,kBAEzDpH,EAAQqH,SACRrH,EAAU,eAAO,GAAIA,GACrBA,EAAQqH,OAAS,eAAmBrH,EAAQqH,OAAQ5K,KAAK2K,kBAE7DH,EAAKE,GAAKnH,EAEdvD,KAAK6K,gBAAgBpK,MAAMT,KAAMwK,IAKrCxE,EAAKtG,UAAUmL,gBAAkB,SAAUT,GACvC,IACIU,EADAC,EAAiB9F,UAAUwF,OAE3BM,EAAiB,GACwB,oBAAlC9F,UAAU8F,EAAiB,KAClCD,EAAW7F,UAAU8F,EAAiB,KACpCA,GAGN,IADA,IAAIL,EAAI,EACDA,EAAIK,IAAmB/K,KAAKqK,UAAWK,EAAG,CAE7C,IAAIlJ,EAAQyD,UAAUyF,GAClBlJ,EAAMqB,QACN7C,KAAK8I,kBAAkBtH,EAAMqB,aAEdc,IAAfnC,EAAMwH,KACNhJ,KAAKiJ,QAAQzH,EAAMwH,MAEdxH,EAAMmH,YACX3I,KAAK+I,cAAcvH,EAAMmH,iBAENhF,IAAnBnC,EAAMoH,UACN5I,KAAK6I,YAAYrH,EAAMoH,UAG/B,GAAI8B,IAAMK,EAAV,CAWA,IALA,IAAInG,EAAQoG,KAAKC,MACbpI,EAAS7C,KAAK0G,cAAcwE,QAC5BvC,EAAa3I,KAAK2G,kBAClBiC,EAAW5I,KAAK4G,gBAChBuE,EAAS,GACNT,EAAIK,IAAkBL,EAAG,CAC5B,IAAInH,EAA2C0B,UAAUyF,GACrDU,EAAY,CACZxG,MAAOA,EACPyG,UAAU,EACVT,OAAQrH,EAAQqH,OAChBU,cAA+B3H,IAArBJ,EAAQ+H,SAAyB/H,EAAQ+H,SAAW,IAC9DC,OAAQhI,EAAQgI,QAAU,OAC1BT,SAAUA,GAiBd,GAfIvH,EAAQV,SACRuI,EAAUI,aAAe3I,EACzBuI,EAAUK,aAAelI,EAAQV,OAAOqI,QACxCrI,EAASuI,EAAUK,mBAEF9H,IAAjBJ,EAAQyF,MACRoC,EAAUM,iBAAmB/C,EAC7ByC,EAAUO,iBAAmB3L,KAAK4L,qBAAqBrI,EAAQyF,MAC/DL,EAAayC,EAAUO,kBAElBpI,EAAQoF,aACbyC,EAAUM,iBAAmB/C,EAC7ByC,EAAUO,iBAAmBpI,EAAQoF,WACrCA,EAAayC,EAAUO,uBAEFhI,IAArBJ,EAAQqF,SAAwB,CAChCwC,EAAUS,eAAiBjD,EAC3B,IAAI/D,EAAQ,eAAOtB,EAAQqF,SAAWA,EAAW3F,KAAK6I,GAAI,EAAI7I,KAAK6I,IAAM7I,KAAK6I,GAC9EV,EAAUW,eAAiBnD,EAAW/D,EACtC+D,EAAWwC,EAAUW,eAGrBC,EAAgBZ,GAChBA,EAAUC,UAAW,EAIrBzG,GAASwG,EAAUE,SAEvBH,EAAOc,KAAKb,GAEhBpL,KAAKqG,YAAY4F,KAAKd,GACtBnL,KAAKkM,QAAQC,EAAA,KAASpN,UAAW,GACjCiB,KAAKoM,yBArDGtB,GACAuB,EAAkBvB,GAAU,IA2DxC9E,EAAKtG,UAAU4K,aAAe,WAC1B,OAAOtK,KAAKoG,OAAO+F,EAAA,KAASpN,WAAa,GAO7CiH,EAAKtG,UAAU4M,eAAiB,WAC5B,OAAOtM,KAAKoG,OAAO+F,EAAA,KAASnN,aAAe,GAM/CgH,EAAKtG,UAAU6M,iBAAmB,WAE9B,IAAI3B,EADJ5K,KAAKkM,QAAQC,EAAA,KAASpN,WAAYiB,KAAKoG,OAAO+F,EAAA,KAASpN,YAEvD,IAAK,IAAI2L,EAAI,EAAG8B,EAAKxM,KAAKqG,YAAYoE,OAAQC,EAAI8B,IAAM9B,EAAG,CACvD,IAAIS,EAASnL,KAAKqG,YAAYqE,GAI9B,GAHIS,EAAO,GAAGL,UACVuB,EAAkBlB,EAAO,GAAGL,UAAU,IAErCF,EACD,IAAK,IAAI6B,EAAI,EAAGC,EAAKvB,EAAOV,OAAQgC,EAAIC,IAAMD,EAAG,CAC7C,IAAIrB,EAAYD,EAAOsB,GACvB,IAAKrB,EAAUC,SAAU,CACrBT,EAASQ,EAAUR,OACnB,QAKhB5K,KAAKqG,YAAYoE,OAAS,EAC1BzK,KAAKgH,cAAgB4D,EACrB5K,KAAK6G,YAAc,KACnB7G,KAAK8G,gBAAkB6F,IACvB3M,KAAK+G,cAAgB4F,KAKzB3G,EAAKtG,UAAU0M,kBAAoB,WAK/B,QAJiCzI,IAA7B3D,KAAKsG,sBACLsG,qBAAqB5M,KAAKsG,qBAC1BtG,KAAKsG,yBAAsB3C,GAE1B3D,KAAKsK,eAAV,CAKA,IAFA,IAAIW,EAAMD,KAAKC,MACX4B,GAAO,EACFnC,EAAI1K,KAAKqG,YAAYoE,OAAS,EAAGC,GAAK,IAAKA,EAAG,CAGnD,IAFA,IAAIS,EAASnL,KAAKqG,YAAYqE,GAC1BoC,GAAiB,EACZL,EAAI,EAAGC,EAAKvB,EAAOV,OAAQgC,EAAIC,IAAMD,EAAG,CAC7C,IAAIrB,EAAYD,EAAOsB,GACvB,IAAIrB,EAAUC,SAAd,CAGA,IAAI0B,EAAU9B,EAAMG,EAAUxG,MAC1BoI,EAAW5B,EAAUE,SAAW,EAAIyB,EAAU3B,EAAUE,SAAW,EACnE0B,GAAY,GACZ5B,EAAUC,UAAW,EACrB2B,EAAW,GAGXF,GAAiB,EAErB,IAAIG,EAAW7B,EAAUG,OAAOyB,GAChC,GAAI5B,EAAUI,aAAc,CACxB,IAAI0B,EAAK9B,EAAUI,aAAa,GAC5B2B,EAAK/B,EAAUI,aAAa,GAC5B4B,EAAKhC,EAAUK,aAAa,GAC5B4B,EAAKjC,EAAUK,aAAa,GAChCzL,KAAK6G,YAAcuE,EAAUK,aAC7B,IAAI6B,EAAIJ,EAAKD,GAAYG,EAAKF,GAC1BK,EAAIJ,EAAKF,GAAYI,EAAKF,GAC9BnN,KAAK0G,cAAgB,CAAC4G,EAAGC,GAE7B,GAAInC,EAAUM,kBAAoBN,EAAUO,iBAAkB,CAC1D,IAAIhD,EAA0B,IAAbsE,EACX7B,EAAUO,iBACVP,EAAUM,iBACRuB,GACK7B,EAAUO,iBAAmBP,EAAUM,kBACpD,GAAIN,EAAUR,OAAQ,CAClB,IAAI4C,EAAOxN,KAAKyN,iBAAiBzN,KAAKkK,eAClCwD,EAAwB1N,KAAK0I,aAAaC,WAAWA,EAAY,EAAG6E,GAAM,GAC9ExN,KAAK0G,cAAgB1G,KAAK2N,oBAAoBD,EAAuBtC,EAAUR,QAEnF5K,KAAK8G,gBAAkBsE,EAAUO,iBACjC3L,KAAK2G,kBAAoBgC,EACzB3I,KAAK4N,mBAAkB,GAE3B,QAAiCjK,IAA7ByH,EAAUS,qBACmBlI,IAA7ByH,EAAUW,eAA8B,CACxC,IAAInD,EAAwB,IAAbqE,EACT,eAAO7B,EAAUW,eAAiB9I,KAAK6I,GAAI,EAAI7I,KAAK6I,IAClD7I,KAAK6I,GACPV,EAAUS,eACRoB,GACK7B,EAAUW,eAAiBX,EAAUS,gBAClD,GAAIT,EAAUR,OAAQ,CAClB,IAAIiD,EAAsB7N,KAAK0I,aAAaE,SAASA,GAAU,GAC/D5I,KAAK0G,cAAgB1G,KAAK8N,sBAAsBD,EAAqBzC,EAAUR,QAEnF5K,KAAK+G,cAAgBqE,EAAUW,eAC/B/L,KAAK4G,gBAAkBgC,EAI3B,GAFA5I,KAAK4N,mBAAkB,GACvBf,GAAO,GACFzB,EAAUC,SACX,OAGR,GAAIyB,EAAgB,CAChB9M,KAAKqG,YAAYqE,GAAK,KACtB1K,KAAKkM,QAAQC,EAAA,KAASpN,WAAY,GAClCiB,KAAK6G,YAAc,KACnB7G,KAAK8G,gBAAkB6F,IACvB3M,KAAK+G,cAAgB4F,IACrB,IAAI7B,EAAWK,EAAO,GAAGL,SACrBA,GACAuB,EAAkBvB,GAAU,IAKxC9K,KAAKqG,YAAcrG,KAAKqG,YAAY0H,OAAOC,SACvCnB,QAAqClJ,IAA7B3D,KAAKsG,sBACbtG,KAAKsG,oBAAsB2H,sBAAsBjO,KAAKoM,kBAAkBvL,KAAKb,UAQrFgG,EAAKtG,UAAUoO,sBAAwB,SAAUlF,EAAUgC,GACvD,IAAI/H,EACAqL,EAAgBlO,KAAKiK,oBAMzB,YALsBtG,IAAlBuK,IACArL,EAAS,CAACqL,EAAc,GAAKtD,EAAO,GAAIsD,EAAc,GAAKtD,EAAO,IAClE,eAAiB/H,EAAQ+F,EAAW5I,KAAKkK,eACzC,eAAcrH,EAAQ+H,IAEnB/H,GAOXmD,EAAKtG,UAAUiO,oBAAsB,SAAUhF,EAAYiC,GACvD,IAAI/H,EACAqL,EAAgBlO,KAAKiK,oBACrBkE,EAAoBnO,KAAKwJ,gBAC7B,QAAsB7F,IAAlBuK,QAAqDvK,IAAtBwK,EAAiC,CAChE,IAAIb,EAAI1C,EAAO,GACVjC,GAAciC,EAAO,GAAKsD,EAAc,IAAOC,EAChDZ,EAAI3C,EAAO,GACVjC,GAAciC,EAAO,GAAKsD,EAAc,IAAOC,EACpDtL,EAAS,CAACyK,EAAGC,GAEjB,OAAO1K,GAQXmD,EAAKtG,UAAU+N,iBAAmB,SAAUW,GACxC,IAAIZ,EAAOxN,KAAKyG,cAChB,GAAI2H,EAAc,CACd,IAAIC,EAAIb,EAAK,GACTc,EAAId,EAAK,GACb,MAAO,CACHvK,KAAKsL,IAAIF,EAAIpL,KAAKuL,IAAIJ,IAClBnL,KAAKsL,IAAID,EAAIrL,KAAKwL,IAAIL,IAC1BnL,KAAKsL,IAAIF,EAAIpL,KAAKwL,IAAIL,IAClBnL,KAAKsL,IAAID,EAAIrL,KAAKuL,IAAIJ,KAI9B,OAAOZ,GAUfxH,EAAKtG,UAAUgP,gBAAkB,SAAUC,GACvC3O,KAAKyG,cAAgBjH,MAAMoP,QAAQD,GAC7BA,EAASzD,QACT,CAAC,IAAK,KACPlL,KAAKsK,gBACNtK,KAAKuK,mBAAmB,IAShCvE,EAAKtG,UAAU4J,UAAY,WACvB,IAAIzG,EAAS7C,KAAKiK,oBAClB,OAAKpH,EAGE,eAAiBA,EAAQ7C,KAAK2K,iBAF1B9H,GAQfmD,EAAKtG,UAAUuK,kBAAoB,WAC/B,OAAsEjK,KAAKmJ,IAAI/B,EAAaxB,SAKhGI,EAAKtG,UAAUmP,eAAiB,WAC5B,OAAO7O,KAAK0I,cAKhB1C,EAAKtG,UAAUoP,uBAAyB,WACpC,OAAO9O,KAAKmJ,IAAI,wBAMpBnD,EAAKtG,UAAUqP,SAAW,SAAUC,GAChC,YAAkBrL,IAAdqL,GACAA,EAAU,GAAKhP,KAAKoG,OAAO,GAC3B4I,EAAU,GAAKhP,KAAKoG,OAAO,GACpB4I,GAGAhP,KAAKoG,OAAO8E,SAa3BlF,EAAKtG,UAAUuP,gBAAkB,SAAUN,GACvC,IAAI1H,EAASjH,KAAKkP,wBAAwBP,GAC1C,OAAO,eAAa1H,EAAQjH,KAAK2K,kBAOrC3E,EAAKtG,UAAUwP,wBAA0B,SAAUP,GAC/C,IAAInB,EAAOmB,GAAY3O,KAAKmP,+BACxBtM,EAA+D7C,KAAKiK,oBACxE,eAAOpH,EAAQ,GACf,IAAI8F,EAAqC3I,KAAKwJ,gBAC9C,oBAAsB7F,IAAfgF,EAA0B,GACjC,IAAIC,EAAmC5I,KAAKkK,cAE5C,OADA,oBAAoBvG,IAAbiF,EAAwB,GACxB,eAAkB/F,EAAQ8F,EAAYC,EAAU4E,IAO3DxH,EAAKtG,UAAU0P,iBAAmB,WAC9B,OAAOpP,KAAKwH,gBAOhBxB,EAAKtG,UAAU2P,iBAAmB,WAC9B,OAAOrP,KAAK0H,gBAOhB1B,EAAKtG,UAAU4P,WAAa,WACxB,OAA8BtP,KAAKuP,qBAAqBvP,KAAK0H,iBAOjE1B,EAAKtG,UAAU8P,WAAa,SAAUxG,GAClChJ,KAAKkH,cAAclH,KAAK6J,mBAAmB,CAAE4F,QAASzG,MAO1DhD,EAAKtG,UAAUgQ,WAAa,WACxB,OAA8B1P,KAAKuP,qBAAqBvP,KAAKwH,iBAOjExB,EAAKtG,UAAUiQ,WAAa,SAAU3G,GAClChJ,KAAKkH,cAAclH,KAAK6J,mBAAmB,CAAE1B,QAASa,MAO1DhD,EAAKtG,UAAUkQ,uBAAyB,SAAUC,GAC9C7P,KAAKkH,cAAclH,KAAK6J,mBAAmB,CAAEiG,oBAAqBD,MAOtE7J,EAAKtG,UAAUiL,cAAgB,WAC3B,OAAO3K,KAAKuG,aAQhBP,EAAKtG,UAAU8J,cAAgB,WAC3B,OAAwCxJ,KAAKmJ,IAAI/B,EAAavB,aAQlEG,EAAKtG,UAAUqQ,eAAiB,WAC5B,OAAO/P,KAAK8H,cAUhB9B,EAAKtG,UAAUsQ,uBAAyB,SAAU/I,EAAQ0H,GACtD,OAAO3O,KAAKiQ,+BAA+B,eAAehJ,EAAQjH,KAAK2K,iBAAkBgE,IAS7F3I,EAAKtG,UAAUuQ,+BAAiC,SAAUhJ,EAAQ0H,GAC9D,IAAInB,EAAOmB,GAAY3O,KAAKmP,+BACxBe,EAAc,eAASjJ,GAAUuG,EAAK,GACtC2C,EAAc,eAAUlJ,GAAUuG,EAAK,GAC3C,OAAOvK,KAAKmN,IAAIF,EAAaC,IAQjCnK,EAAKtG,UAAU2Q,8BAAgC,SAAUC,GACrD,IAAIC,EAAQD,GAAa,EACrB7I,EAAgBzH,KAAKwQ,yBAAyBxQ,KAAKwH,gBACnDG,EAAgB3H,KAAK0H,eACrB0I,EAAMnN,KAAKC,IAAIuE,EAAgBE,GAAiB1E,KAAKC,IAAIqN,GAC7D,OAAO,SAKGE,GACN,IAAI9H,EAAalB,EAAgBxE,KAAKyN,IAAIH,EAAOE,EAAQL,GACzD,OAAOzH,IASf3C,EAAKtG,UAAUwK,YAAc,WACzB,OAA8BlK,KAAKmJ,IAAI/B,EAAatB,WAQxDE,EAAKtG,UAAUiR,8BAAgC,SAAUL,GACrD,IAAIM,EAAW3N,KAAKC,IAAIoN,GAAa,GACjC7I,EAAgBzH,KAAKwQ,yBAAyBxQ,KAAKwH,gBACnDG,EAAgB3H,KAAK0H,eACrB0I,EAAMnN,KAAKC,IAAIuE,EAAgBE,GAAiBiJ,EACpD,OAAO,SAKGjI,GACN,IAAI8H,EAAQxN,KAAKC,IAAIuE,EAAgBkB,GAAciI,EAAWR,EAC9D,OAAOK,IASfzK,EAAKtG,UAAUyP,6BAA+B,SAAUf,GACpD,IAAIZ,EAAOxN,KAAKyN,iBAAiBW,GAC7BnG,EAAUjI,KAAKgI,SAOnB,OANIC,IACAuF,EAAO,CACHA,EAAK,GAAKvF,EAAQ,GAAKA,EAAQ,GAC/BuF,EAAK,GAAKvF,EAAQ,GAAKA,EAAQ,KAGhCuF,GAKXxH,EAAKtG,UAAU+B,SAAW,WACtB,IAAI+E,EAAaxG,KAAK2K,gBAClBhC,EAAa3I,KAAKwJ,gBAClBZ,EAAW5I,KAAKkK,cAChBrH,EAA8D7C,KAAKiK,oBACnEhC,EAAUjI,KAAKgI,SACnB,GAAIC,EAAS,CACT,IAAI4I,EAAc7Q,KAAKmP,+BACvBtM,EAASiO,EAAkBjO,EAAQ7C,KAAKyN,mBAAoB,CAACoD,EAAY,GAAK,EAAI5I,EAAQ,GAAI4I,EAAY,GAAK,EAAI5I,EAAQ,IAAKU,EAAYC,GAEhJ,MAAO,CACH/F,OAAQA,EAAOqI,MAAM,GACrB1E,gBAA2B7C,IAAf6C,EAA2BA,EAAa,KACpDmC,WAAYA,EACZoI,WAAY/Q,KAAK6G,YACjBmK,eAAgBhR,KAAK8G,gBACrBmK,aAAcjR,KAAK+G,cACnB6B,SAAUA,EACVI,KAAMhJ,KAAKgK,YAUnBhE,EAAKtG,UAAUsK,QAAU,WACrB,IAAIhB,EACAL,EAAa3I,KAAKwJ,gBAItB,YAHmB7F,IAAfgF,IACAK,EAAOhJ,KAAKuP,qBAAqB5G,IAE9BK,GAQXhD,EAAKtG,UAAU6P,qBAAuB,SAAU5G,GAC5C,IACIyH,EAAKvI,EADLqJ,EAASlR,KAAKkI,UAAY,EAE9B,GAAIlI,KAAK8H,aAAc,CACnB,IAAIqJ,EAAU,eAAkBnR,KAAK8H,aAAca,EAAY,GAC/DuI,EAASC,EACTf,EAAMpQ,KAAK8H,aAAaqJ,GAEpBtJ,EADAsJ,GAAWnR,KAAK8H,aAAa2C,OAAS,EACzB,EAGA2F,EAAMpQ,KAAK8H,aAAaqJ,EAAU,QAInDf,EAAMpQ,KAAKwH,eACXK,EAAa7H,KAAK4H,YAEtB,OAAOsJ,EAASjO,KAAKC,IAAIkN,EAAMzH,GAAc1F,KAAKC,IAAI2E,IAQ1D7B,EAAKtG,UAAUkM,qBAAuB,SAAU5C,GAC5C,GAAIhJ,KAAK8H,aAAc,CACnB,GAAI9H,KAAK8H,aAAa2C,QAAU,EAC5B,OAAO,EAEX,IAAI2G,EAAY,eAAMnO,KAAKoO,MAAMrI,GAAO,EAAGhJ,KAAK8H,aAAa2C,OAAS,GAClE5C,EAAa7H,KAAK8H,aAAasJ,GAAapR,KAAK8H,aAAasJ,EAAY,GAC9E,OAAQpR,KAAK8H,aAAasJ,GACtBnO,KAAKyN,IAAI7I,EAAY,eAAMmB,EAAOoI,EAAW,EAAG,IAGpD,OAAQpR,KAAKwH,eAAiBvE,KAAKyN,IAAI1Q,KAAK4H,YAAaoB,EAAOhJ,KAAKkI,WAa7ElC,EAAKtG,UAAU4R,IAAM,SAAUC,EAAkBjO,GAE7C,IAAIkO,EAIJ,GAHA,eAAOhS,MAAMoP,QAAQ2C,IAEb,oBADqB,EAAwC,sBACjD,IAChB/R,MAAMoP,QAAQ2C,GAAmB,CACjC,gBAAQ,eAAQA,GAAmB,IACnC,IAAItK,EAAS,eAAesK,EAAkBvR,KAAK2K,iBACnD6G,EAAW,eAAkBvK,QAE5B,GAAIsK,EAAiBE,YAAcC,EAAA,KAAaC,OAAQ,CACrD1K,EAAS,eAAesK,EAAiBK,YAAa5R,KAAK2K,iBAC/D6G,EAAW,eAAkBvK,GAC7BuK,EAASK,OAAO7R,KAAKkK,cAAe,eAAUjD,QAE7C,CACD,IAAI6K,EAAiB,iBAEjBN,EADAM,EACsEP,EACjEQ,QACAC,UAAUF,EAAgB9R,KAAK2K,iBAGzB4G,EAGnBvR,KAAKiS,YAAYT,EAAUlO,IAO/B0C,EAAKtG,UAAUwS,yBAA2B,SAAUV,GAUhD,IATA,IAAI5I,EAAW5I,KAAKkK,cAChBiI,EAAWlP,KAAKuL,IAAI5F,GACpBwJ,EAAWnP,KAAKwL,KAAK7F,GACrByJ,EAASb,EAASc,qBAClBC,EAASf,EAASgB,YAClBC,EAAWC,IACXC,EAAWD,IACXE,GAAWF,IACXG,GAAWH,IACNhI,EAAI,EAAG8B,EAAK6F,EAAO5H,OAAQC,EAAI8B,EAAI9B,GAAK6H,EAAQ,CACrD,IAAIO,EAAOT,EAAO3H,GAAKyH,EAAWE,EAAO3H,EAAI,GAAK0H,EAC9CW,EAAOV,EAAO3H,GAAK0H,EAAWC,EAAO3H,EAAI,GAAKyH,EAClDM,EAAUxP,KAAK+P,IAAIP,EAASK,GAC5BH,EAAU1P,KAAK+P,IAAIL,EAASI,GAC5BH,EAAU3P,KAAKmN,IAAIwC,EAASE,GAC5BD,EAAU5P,KAAKmN,IAAIyC,EAASE,GAEhC,MAAO,CAACN,EAASE,EAASC,EAASC,IAMvC7M,EAAKtG,UAAUuS,YAAc,SAAUT,EAAUlO,GAC7C,IAAIC,EAAUD,GAAe,GACzBkK,EAAOjK,EAAQiK,KACdA,IACDA,EAAOxN,KAAKmP,gCAEhB,IAEIxH,EAFAM,OAA8BtE,IAApBJ,EAAQ0E,QAAwB1E,EAAQ0E,QAAU,CAAC,EAAG,EAAG,EAAG,GACtEkJ,OAA8BxN,IAApBJ,EAAQ4N,SAAwB5N,EAAQ4N,QAGlDxJ,OAD0BhE,IAA1BJ,EAAQoE,cACQpE,EAAQoE,mBAEChE,IAApBJ,EAAQkM,QACGzP,KAAK4L,qBAAqBrI,EAAQkM,SAGlC,EAEpB,IAAIwD,EAAgBjT,KAAKkS,yBAAyBV,GAE9C7I,EAAa3I,KAAKiQ,+BAA+BgD,EAAe,CAChEzF,EAAK,GAAKvF,EAAQ,GAAKA,EAAQ,GAC/BuF,EAAK,GAAKvF,EAAQ,GAAKA,EAAQ,KAEnCU,EAAauK,MAAMvK,GACbhB,EACA1E,KAAKmN,IAAIzH,EAAYhB,GAC3BgB,EAAa3I,KAAKwQ,yBAAyB7H,EAAYwI,EAAU,EAAI,GAErE,IAAIvI,EAAW5I,KAAKkK,cAChBkI,EAAWnP,KAAKwL,IAAI7F,GACpBuJ,EAAWlP,KAAKuL,IAAI5F,GACpBuK,EAAY,eAAUF,GAC1BE,EAAU,KAAQlL,EAAQ,GAAKA,EAAQ,IAAM,EAAKU,EAClDwK,EAAU,KAAQlL,EAAQ,GAAKA,EAAQ,IAAM,EAAKU,EAClD,IAAIyK,EAAUD,EAAU,GAAKhB,EAAWgB,EAAU,GAAKf,EACnDiB,EAAUF,EAAU,GAAKhB,EAAWgB,EAAU,GAAKf,EACnDvP,EAAS7C,KAAKsT,qBAAqB,CAACF,EAASC,GAAU1K,GACvDmC,EAAWvH,EAAQuH,SAAWvH,EAAQuH,SAAW,YAC5BnH,IAArBJ,EAAQ+H,SACRtL,KAAK6K,gBAAgB,CACjBlC,WAAYA,EACZ9F,OAAQA,EACRyI,SAAU/H,EAAQ+H,SAClBC,OAAQhI,EAAQgI,QACjBT,IAGH9K,KAAK2G,kBAAoBgC,EACzB3I,KAAK0G,cAAgB7D,EACrB7C,KAAK4N,mBAAkB,GAAO,GAC9BvB,EAAkBvB,GAAU,KAUpC9E,EAAKtG,UAAU6T,SAAW,SAAUC,EAAYhG,EAAMiG,GAClDzT,KAAK0T,iBAAiB,eAAmBF,EAAYxT,KAAK2K,iBAAkB6C,EAAMiG,IAOtFzN,EAAKtG,UAAUgU,iBAAmB,SAAUF,EAAYhG,EAAMiG,GAC1DzT,KAAK8I,kBAAkBgI,EAAkB0C,EAAYhG,EAAMiG,EAAUzT,KAAKwJ,gBAAiBxJ,KAAKkK,iBAUpGlE,EAAKtG,UAAUiU,qBAAuB,SAAU9Q,EAAQ8F,EAAYC,EAAU4E,GAC1E,IAAIoG,EACA3L,EAAUjI,KAAKgI,SACnB,GAAIC,GAAWpF,EAAQ,CACnB,IAAIgO,EAAc7Q,KAAKmP,8BAA8BvG,GACjDiL,EAAgB/C,EAAkBjO,EAAQ2K,EAAM,CAACqD,EAAY,GAAK,EAAI5I,EAAQ,GAAI4I,EAAY,GAAK,EAAI5I,EAAQ,IAAKU,EAAYC,GACpIgL,EAAc,CACV/Q,EAAO,GAAKgR,EAAc,GAC1BhR,EAAO,GAAKgR,EAAc,IAGlC,OAAOD,GAKX5N,EAAKtG,UAAU2K,MAAQ,WACnB,QAASrK,KAAKiK,0BAAgDtG,IAAzB3D,KAAKwJ,iBAO9CxD,EAAKtG,UAAUoU,aAAe,SAAUC,GACpC,IAAIlR,EAAS,eAAiB7C,KAAK0G,cAAe1G,KAAK2K,iBACvD3K,KAAKgU,UAAU,CACXnR,EAAO,GAAKkR,EAAiB,GAC7BlR,EAAO,GAAKkR,EAAiB,MAOrC/N,EAAKtG,UAAUuU,qBAAuB,SAAUF,GAC5C,IAAIlR,EAAS7C,KAAK0G,cAClB1G,KAAK8I,kBAAkB,CACnBjG,EAAO,GAAKkR,EAAiB,GAC7BlR,EAAO,GAAKkR,EAAiB,MAUrC/N,EAAKtG,UAAUwU,iBAAmB,SAAUC,EAAOC,GAC/C,IAAIxJ,EAASwJ,GAAc,eAAmBA,EAAYpU,KAAK2K,iBAC/D3K,KAAKqU,yBAAyBF,EAAOvJ,IAQzC5E,EAAKtG,UAAU2U,yBAA2B,SAAUF,EAAOC,GACvD,IAAIE,EAAWtU,KAAKsK,gBAAkBtK,KAAKsM,iBACvCkB,EAAOxN,KAAKyN,iBAAiBzN,KAAKkK,eAClCqK,EAAgBvU,KAAK0I,aAAaC,WAAW3I,KAAK2G,kBAAoBwN,EAAO,EAAG3G,EAAM8G,GACtFF,IACApU,KAAK0G,cAAgB1G,KAAK2N,oBAAoB4G,EAAeH,IAEjEpU,KAAK2G,mBAAqBwN,EAC1BnU,KAAK4N,qBAST5H,EAAKtG,UAAU8U,WAAa,SAAU3P,EAAOuP,GACzCpU,KAAKkU,iBAAiBjR,KAAKyN,IAAI1Q,KAAK4H,aAAc/C,GAAQuP,IAS9DpO,EAAKtG,UAAU+U,eAAiB,SAAU5P,EAAOuP,GACzCA,IACAA,EAAa,eAAmBA,EAAYpU,KAAK2K,kBAErD3K,KAAK0U,uBAAuB7P,EAAOuP,IAMvCpO,EAAKtG,UAAUgV,uBAAyB,SAAU7P,EAAOuP,GACrD,IAAIE,EAAWtU,KAAKsK,gBAAkBtK,KAAKsM,iBACvCqI,EAAc3U,KAAK0I,aAAaE,SAAS5I,KAAK4G,gBAAkB/B,EAAOyP,GACvEF,IACApU,KAAK0G,cAAgB1G,KAAK8N,sBAAsB6G,EAAaP,IAEjEpU,KAAK4G,iBAAmB/B,EACxB7E,KAAK4N,qBAQT5H,EAAKtG,UAAUsU,UAAY,SAAUnR,GACjC7C,KAAK8I,kBAAkBjG,EAAS,eAAmBA,EAAQ7C,KAAK2K,iBAAmB9H,IAMvFmD,EAAKtG,UAAUoJ,kBAAoB,SAAUjG,GACzC7C,KAAK0G,cAAgB7D,EACrB7C,KAAK4N,qBAOT5H,EAAKtG,UAAUwM,QAAU,SAAU0I,EAAM/P,GAGrC,OAFA7E,KAAKoG,OAAOwO,IAAS/P,EACrB7E,KAAK+D,UACE/D,KAAKoG,OAAOwO,IAQvB5O,EAAKtG,UAAUqJ,cAAgB,SAAUJ,GACrC3I,KAAK2G,kBAAoBgC,EACzB3I,KAAK4N,qBAQT5H,EAAKtG,UAAUmJ,YAAc,SAAUD,GACnC5I,KAAK4G,gBAAkBgC,EACvB5I,KAAK4N,qBAOT5H,EAAKtG,UAAUuJ,QAAU,SAAUD,GAC/BhJ,KAAK+I,cAAc/I,KAAK4L,qBAAqB5C,KAUjDhD,EAAKtG,UAAUkO,kBAAoB,SAAUiH,EAAsBC,GAC/D,IAAIR,EAAWtU,KAAKsK,gBAAkBtK,KAAKsM,kBAAoBwI,EAE3DH,EAAc3U,KAAK0I,aAAaE,SAAS5I,KAAK4G,gBAAiB0N,GAC/D9G,EAAOxN,KAAKyN,iBAAiBkH,GAC7BJ,EAAgBvU,KAAK0I,aAAaC,WAAW3I,KAAK2G,kBAAmB,EAAG6G,EAAM8G,GAC9ES,EAAY/U,KAAK0I,aAAa7F,OAAO7C,KAAK0G,cAAe6N,EAAe/G,EAAM8G,EAAUtU,KAAK2T,qBAAqB3T,KAAK0G,cAAe6N,EAAeI,EAAanH,IAClKxN,KAAKmJ,IAAI/B,EAAatB,YAAc6O,GACpC3U,KAAKoJ,IAAIhC,EAAatB,SAAU6O,GAEhC3U,KAAKmJ,IAAI/B,EAAavB,cAAgB0O,IACtCvU,KAAKoJ,IAAIhC,EAAavB,WAAY0O,GAClCvU,KAAKoJ,IAAI,OAAQpJ,KAAKgK,WAAW,IAEhC+K,GACA/U,KAAKmJ,IAAI/B,EAAaxB,SACtB,eAAO5F,KAAKmJ,IAAI/B,EAAaxB,QAASmP,IACvC/U,KAAKoJ,IAAIhC,EAAaxB,OAAQmP,GAE9B/U,KAAKsK,iBAAmBuK,GACxB7U,KAAKuM,mBAETvM,KAAKgH,mBAAgBrD,GAWzBqC,EAAKtG,UAAU6K,mBAAqB,SAAUyK,EAAcC,EAAyBb,GACjF,IAAI9I,OAA4B3H,IAAjBqR,EAA6BA,EAAe,IACvDE,EAAYD,GAA2B,EACvCN,EAAc3U,KAAK0I,aAAaE,SAAS5I,KAAK4G,iBAC9C4G,EAAOxN,KAAKyN,iBAAiBkH,GAC7BJ,EAAgBvU,KAAK0I,aAAaC,WAAW3I,KAAK2G,kBAAmBuO,EAAW1H,GAChFuH,EAAY/U,KAAK0I,aAAa7F,OAAO7C,KAAK0G,cAAe6N,EAAe/G,GAAM,EAAOxN,KAAK2T,qBAAqB3T,KAAK0G,cAAe6N,EAAeI,EAAanH,IACnK,GAAiB,IAAblC,IAAmBtL,KAAKgH,cAKxB,OAJAhH,KAAK2G,kBAAoB4N,EACzBvU,KAAK4G,gBAAkB+N,EACvB3U,KAAK0G,cAAgBqO,OACrB/U,KAAK4N,oBAGT,IAAIhD,EAASwJ,IAA4B,IAAb9I,EAAiBtL,KAAKgH,mBAAgBrD,GAClE3D,KAAKgH,mBAAgBrD,EACjB3D,KAAKwJ,kBAAoB+K,GACzBvU,KAAKkK,gBAAkByK,GACtB3U,KAAKiK,qBACL,eAAOjK,KAAKiK,oBAAqB8K,KAC9B/U,KAAKsK,gBACLtK,KAAKuM,mBAETvM,KAAK6K,gBAAgB,CACjBjC,SAAU+L,EACV9R,OAAQkS,EACRpM,WAAY4L,EACZjJ,SAAUA,EACVC,OAAQ,OACRX,OAAQA,MAUpB5E,EAAKtG,UAAUyV,iBAAmB,WAC9BnV,KAAKuK,mBAAmB,GACxBvK,KAAKkM,QAAQC,EAAA,KAASnN,YAAa,IAUvCgH,EAAKtG,UAAU0V,eAAiB,SAAUJ,EAAcC,EAAyBb,GAC7E,IAAIxJ,EAASwJ,GAAc,eAAmBA,EAAYpU,KAAK2K,iBAC/D3K,KAAKqV,uBAAuBL,EAAcC,EAAyBrK,IASvE5E,EAAKtG,UAAU2V,uBAAyB,SAAUL,EAAcC,EAAyBb,GACrFpU,KAAKkM,QAAQC,EAAA,KAASnN,aAAc,GACpCgB,KAAKuK,mBAAmByK,EAAcC,EAAyBb,IASnEpO,EAAKtG,UAAU4T,qBAAuB,SAAU7H,EAAc6J,GAC1D,IAAI9H,EAAOxN,KAAKyN,iBAAiBzN,KAAKkK,eACtC,OAAOlK,KAAK0I,aAAa7F,OAAO4I,EAAc6J,GAAwBtV,KAAKwJ,gBAAiBgE,IAWhGxH,EAAKtG,UAAU6V,mBAAqB,SAAUC,EAAYC,GACtD,IAAIC,EAAY1V,KAAK4L,qBAAqB4J,GAC1C,OAAOxV,KAAKuP,qBAAqBvP,KAAKwQ,yBAAyBkF,EAAWD,KAW9EzP,EAAKtG,UAAU8Q,yBAA2B,SAAU7E,EAAkB8J,GAClE,IAAIP,EAAYO,GAAiB,EAC7BjI,EAAOxN,KAAKyN,iBAAiBzN,KAAKkK,eACtC,OAAOlK,KAAK0I,aAAaC,WAAWgD,EAAkBuJ,EAAW1H,IAE9DxH,EA7zCc,CA8zCvB,QAKF,SAASqG,EAAkBvB,EAAU6K,GACjCC,YAAW,WACP9K,EAAS6K,KACV,GAMA,SAAStN,EAAuB9E,GACnC,QAAuBI,IAAnBJ,EAAQ0D,OAAsB,CAC9B,IAAI4O,OAA4ClS,IAAnCJ,EAAQuS,wBACfvS,EAAQuS,uBAEd,OAAO,eAAavS,EAAQ0D,OAAQ1D,EAAQwS,oBAAqBF,GAErE,IAAIrP,EAAa,eAAiBjD,EAAQiD,WAAY,aACtD,IAA2B,IAAvBjD,EAAQyS,YAAuBxP,EAAWyP,WAAY,CACtD,IAAIhP,EAAST,EAAWoL,YAAY1G,QAGpC,OAFAjE,EAAO,IAAMyL,IACbzL,EAAO,GAAKyL,IACL,eAAazL,GAAQ,GAAO,GAEvC,OAAO,OAOJ,SAASM,EAA2BhE,GACvC,IAAI+E,EACAb,EACAE,EAGAuO,EAAiB,GACjBC,EAAoB,EACpBhO,OAA8BxE,IAApBJ,EAAQ4E,QAAwB5E,EAAQ4E,QAAUpC,EAC5D0J,OAA8B9L,IAApBJ,EAAQkM,QAAwBlM,EAAQkM,QAAUyG,EAC5DrO,OAAoClE,IAAvBJ,EAAQsE,WAA2BtE,EAAQsE,WAAasO,EACrEH,OAAoCrS,IAAvBJ,EAAQyS,YAA2BzS,EAAQyS,WACxDH,OAAgDlS,IAAvCJ,EAAQ6S,4BACf7S,EAAQ6S,2BAEVC,OAA4C1S,IAA3BJ,EAAQ8S,gBAA+B9S,EAAQ8S,eAChE7P,EAAa,eAAiBjD,EAAQiD,WAAY,aAClD8P,EAAa9P,EAAWoL,YACxBmE,EAAsBxS,EAAQwS,oBAC9B9O,EAAS1D,EAAQ0D,OAKrB,GAJK+O,GAAe/O,IAAUT,EAAWyP,aACrCF,GAAsB,EACtB9O,EAASqP,QAEe3S,IAAxBJ,EAAQwE,YAA2B,CACnC,IAAIA,EAAcxE,EAAQwE,YAC1BN,EAAgBM,EAAYI,GAC5BR,OAC6BhE,IAAzBoE,EAAY0H,GACN1H,EAAY0H,GACZ1H,EAAYA,EAAY0C,OAAS,GAEvCnC,EADA/E,EAAQuM,oBACe,eAAwB/H,EAAa8N,GAASE,GAAuB9O,EAAQoP,GAG7E,eAAuB5O,EAAeE,EAAekO,GAASE,GAAuB9O,EAAQoP,OAGvH,CAED,IAAI7I,EAAQ8I,EAGNrT,KAAKmN,IAAI,eAASkG,GAAa,eAAUA,IADtC,IAAM,OAAgBC,EAAA,KAAMC,SAAYhQ,EAAWiQ,mBAExDC,EAAuBlJ,EAAO,OAAoBvK,KAAKyN,IAAIyF,EAAmBpQ,GAC9E4Q,EAAuBD,EACvBzT,KAAKyN,IAAIyF,EAAmBD,EAAiBnQ,GAEjD0B,EAAgBlE,EAAQkE,mBACF9D,IAAlB8D,EACAU,EAAU,EAGVV,EAAgBiP,EAAuBzT,KAAKyN,IAAI7I,EAAYM,GAGhER,EAAgBpE,EAAQoE,mBACFhE,IAAlBgE,IAGQA,OAFgBhE,IAApBJ,EAAQkM,aACsB9L,IAA1BJ,EAAQkE,cACQA,EAAgBxE,KAAKyN,IAAI7I,EAAY4H,GAGrCiH,EAAuBzT,KAAKyN,IAAI7I,EAAY4H,GAIhDkH,GAIxBlH,EACItH,EACIlF,KAAKoO,MAAMpO,KAAKC,IAAIuE,EAAgBE,GAAiB1E,KAAKC,IAAI2E,IACtEF,EAAgBF,EAAgBxE,KAAKyN,IAAI7I,EAAY4H,EAAUtH,GAE3DG,EADA/E,EAAQuM,oBACe,eAAkBjI,EAAYJ,EAAeE,EAAekO,GAASE,GAAuB9O,EAAQoP,GAGpG,eAAuB5O,EAAeE,EAAekO,GAASE,GAAuB9O,EAAQoP,GAG5H,MAAO,CACH9N,WAAYD,EACZb,cAAeA,EACfE,cAAeA,EACfQ,QAASA,EACTN,WAAYA,GAOb,SAASY,EAAyBlF,GACrC,IAAIqT,OAA4CjT,IAA3BJ,EAAQqT,gBAA+BrT,EAAQqT,eACpE,GAAIA,EAAgB,CAChB,IAAIC,EAAoBtT,EAAQsT,kBAChC,YAA0BlT,IAAtBkT,IAAyD,IAAtBA,EAC5B,kBAEoB,IAAtBA,EACE,OAE2B,kBAAtBA,EACL,eAAcA,GAGd,OAIX,OAAO,OAQR,SAAS7K,EAAgBZ,GAC5B,QAAIA,EAAUI,cAAgBJ,EAAUK,eAC/B,eAAiBL,EAAUI,aAAcJ,EAAUK,iBAIxDL,EAAUM,mBAAqBN,EAAUO,kBAGzCP,EAAUS,iBAAmBT,EAAUW,gBAa/C,SAAS+E,EAAkB0C,EAAYhG,EAAMiG,EAAU9K,EAAYC,GAE/D,IAAIuJ,EAAWlP,KAAKuL,KAAK5F,GACrBwJ,EAAWnP,KAAKwL,KAAK7F,GACrBkK,EAAOU,EAAW,GAAKrB,EAAWqB,EAAW,GAAKpB,EAClDW,EAAOS,EAAW,GAAKrB,EAAWqB,EAAW,GAAKpB,EACtDU,IAAStF,EAAK,GAAK,EAAIiG,EAAS,IAAM9K,EACtCoK,IAASU,EAAS,GAAKjG,EAAK,GAAK,GAAK7E,EAEtCyJ,GAAYA,EACZ,IAAIgB,EAAUN,EAAOX,EAAWY,EAAOX,EACnCiB,EAAUN,EAAOZ,EAAWW,EAAOV,EACvC,MAAO,CAACgB,EAASC,GAEN,U,kCCjxDA,QACXhR,KAAM,EACNgC,QAAS,EACT3C,OAAQ,EAKRC,MAAO,EACPC,MAAO,I,kCCfX,kCAOA,IAAIkV,EAA2B,WAO3B,SAASA,EAAUC,EAAMC,EAAMC,EAAMC,GAIjClX,KAAK+W,KAAOA,EAIZ/W,KAAKgX,KAAOA,EAIZhX,KAAKiX,KAAOA,EAIZjX,KAAKkX,KAAOA,EAkFhB,OA5EAJ,EAAUpX,UAAUyX,SAAW,SAAU9T,GACrC,OAAOrD,KAAKoX,WAAW/T,EAAU,GAAIA,EAAU,KAMnDyT,EAAUpX,UAAU2X,kBAAoB,SAAUC,GAC9C,OAAQtX,KAAK+W,MAAQO,EAAUP,MAC3BO,EAAUN,MAAQhX,KAAKgX,MACvBhX,KAAKiX,MAAQK,EAAUL,MACvBK,EAAUJ,MAAQlX,KAAKkX,MAO/BJ,EAAUpX,UAAU0X,WAAa,SAAU9J,EAAGC,GAC1C,OAAOvN,KAAK+W,MAAQzJ,GAAKA,GAAKtN,KAAKgX,MAAQhX,KAAKiX,MAAQ1J,GAAKA,GAAKvN,KAAKkX,MAM3EJ,EAAUpX,UAAU6X,OAAS,SAAUD,GACnC,OAAQtX,KAAK+W,MAAQO,EAAUP,MAC3B/W,KAAKiX,MAAQK,EAAUL,MACvBjX,KAAKgX,MAAQM,EAAUN,MACvBhX,KAAKkX,MAAQI,EAAUJ,MAK/BJ,EAAUpX,UAAU8X,OAAS,SAAUF,GAC/BA,EAAUP,KAAO/W,KAAK+W,OACtB/W,KAAK+W,KAAOO,EAAUP,MAEtBO,EAAUN,KAAOhX,KAAKgX,OACtBhX,KAAKgX,KAAOM,EAAUN,MAEtBM,EAAUL,KAAOjX,KAAKiX,OACtBjX,KAAKiX,KAAOK,EAAUL,MAEtBK,EAAUJ,KAAOlX,KAAKkX,OACtBlX,KAAKkX,KAAOI,EAAUJ,OAM9BJ,EAAUpX,UAAU+X,UAAY,WAC5B,OAAOzX,KAAKkX,KAAOlX,KAAKiX,KAAO,GAKnCH,EAAUpX,UAAUgY,QAAU,WAC1B,MAAO,CAAC1X,KAAK2X,WAAY3X,KAAKyX,cAKlCX,EAAUpX,UAAUiY,SAAW,WAC3B,OAAO3X,KAAKgX,KAAOhX,KAAK+W,KAAO,GAMnCD,EAAUpX,UAAUkY,WAAa,SAAUN,GACvC,OAAQtX,KAAK+W,MAAQO,EAAUN,MAC3BhX,KAAKgX,MAAQM,EAAUP,MACvB/W,KAAKiX,MAAQK,EAAUJ,MACvBlX,KAAKkX,MAAQI,EAAUL,MAExBH,EAzGmB,GAmHvB,SAASe,EAAed,EAAMC,EAAMC,EAAMC,EAAMI,GACnD,YAAkB3T,IAAd2T,GACAA,EAAUP,KAAOA,EACjBO,EAAUN,KAAOA,EACjBM,EAAUL,KAAOA,EACjBK,EAAUJ,KAAOA,EACVI,GAGA,IAAIR,EAAUC,EAAMC,EAAMC,EAAMC,GAGhC","file":"js/chunk-22009db5.64944989.js","sourcesContent":["/**\n * @module ol/ViewHint\n */\n/**\n * @enum {number}\n */\nexport default {\n    ANIMATING: 0,\n    INTERACTING: 1,\n};\n//# sourceMappingURL=ViewHint.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/TileQueue\n */\nimport EventType from './events/EventType.js';\nimport PriorityQueue, { DROP } from './structs/PriorityQueue.js';\nimport TileState from './TileState.js';\n/**\n * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\n */\nvar TileQueue = /** @class */ (function (_super) {\n    __extends(TileQueue, _super);\n    /**\n     * @param {PriorityFunction} tilePriorityFunction Tile priority function.\n     * @param {function(): ?} tileChangeCallback Function called on each tile change event.\n     */\n    function TileQueue(tilePriorityFunction, tileChangeCallback) {\n        var _this = _super.call(this, \n        /**\n         * @param {Array} element Element.\n         * @return {number} Priority.\n         */\n        function (element) {\n            return tilePriorityFunction.apply(null, element);\n        }, \n        /**\n         * @param {Array} element Element.\n         * @return {string} Key.\n         */\n        function (element) {\n            return /** @type {import(\"./Tile.js\").default} */ (element[0]).getKey();\n        }) || this;\n        /** @private */\n        _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);\n        /**\n         * @private\n         * @type {function(): ?}\n         */\n        _this.tileChangeCallback_ = tileChangeCallback;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.tilesLoading_ = 0;\n        /**\n         * @private\n         * @type {!Object<string,boolean>}\n         */\n        _this.tilesLoadingKeys_ = {};\n        return _this;\n    }\n    /**\n     * @param {Array} element Element.\n     * @return {boolean} The element was added to the queue.\n     */\n    TileQueue.prototype.enqueue = function (element) {\n        var added = _super.prototype.enqueue.call(this, element);\n        if (added) {\n            var tile = element[0];\n            tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n        }\n        return added;\n    };\n    /**\n     * @return {number} Number of tiles loading.\n     */\n    TileQueue.prototype.getTilesLoading = function () {\n        return this.tilesLoading_;\n    };\n    /**\n     * @param {import(\"./events/Event.js\").default} event Event.\n     * @protected\n     */\n    TileQueue.prototype.handleTileChange = function (event) {\n        var tile = /** @type {import(\"./Tile.js\").default} */ (event.target);\n        var state = tile.getState();\n        if (state === TileState.LOADED ||\n            state === TileState.ERROR ||\n            state === TileState.EMPTY) {\n            tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);\n            var tileKey = tile.getKey();\n            if (tileKey in this.tilesLoadingKeys_) {\n                delete this.tilesLoadingKeys_[tileKey];\n                --this.tilesLoading_;\n            }\n            this.tileChangeCallback_();\n        }\n    };\n    /**\n     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n     * @param {number} maxNewLoads Maximum number of new tiles to load.\n     */\n    TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {\n        var newLoads = 0;\n        var state, tile, tileKey;\n        while (this.tilesLoading_ < maxTotalLoading &&\n            newLoads < maxNewLoads &&\n            this.getCount() > 0) {\n            tile = /** @type {import(\"./Tile.js\").default} */ (this.dequeue()[0]);\n            tileKey = tile.getKey();\n            state = tile.getState();\n            if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n                this.tilesLoadingKeys_[tileKey] = true;\n                ++this.tilesLoading_;\n                ++newLoads;\n                tile.load();\n            }\n        }\n    };\n    return TileQueue;\n}(PriorityQueue));\nexport default TileQueue;\n/**\n * @param {import('./PluggableMap.js').FrameState} frameState Frame state.\n * @param {import(\"./Tile.js\").default} tile Tile.\n * @param {string} tileSourceKey Tile source key.\n * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n * @param {number} tileResolution Tile resolution.\n * @return {number} Tile priority.\n */\nexport function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {\n    // Filter out tiles at higher zoom levels than the current zoom level, or that\n    // are outside the visible extent.\n    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n        return DROP;\n    }\n    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n        return DROP;\n    }\n    // Prioritize the highest zoom level tiles closest to the focus.\n    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n    // Within a zoom level, tiles are prioritized by the distance in pixels between\n    // the center of the tile and the center of the viewport.  The factor of 65536\n    // means that the prioritization should behave as desired for tiles up to\n    // 65536 * Math.log(2) = 45426 pixels from the focus.\n    var center = frameState.viewState.center;\n    var deltaX = tileCenter[0] - center[0];\n    var deltaY = tileCenter[1] - center[1];\n    return (65536 * Math.log(tileResolution) +\n        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution);\n}\n//# sourceMappingURL=TileQueue.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport { abstract } from './util.js';\nimport { easeIn } from './easing.js';\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   var xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     var data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nvar Tile = /** @class */ (function (_super) {\n    __extends(Tile, _super);\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"./TileState.js\").default} state State.\n     * @param {Options} [opt_options] Tile options.\n     */\n    function Tile(tileCoord, state, opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options ? opt_options : {};\n        /**\n         * @type {import(\"./tilecoord.js\").TileCoord}\n         */\n        _this.tileCoord = tileCoord;\n        /**\n         * @protected\n         * @type {import(\"./TileState.js\").default}\n         */\n        _this.state = state;\n        /**\n         * An \"interim\" tile for this tile. The interim tile may be used while this\n         * one is loading, for \"smooth\" transitions when changing params/dimensions\n         * on the source.\n         * @type {Tile}\n         */\n        _this.interimTile = null;\n        /**\n         * A key assigned to the tile. This is used by the tile source to determine\n         * if this tile can effectively be used, or if a new tile should be created\n         * and this one be used as an interim tile for this new tile.\n         * @type {string}\n         */\n        _this.key = '';\n        /**\n         * The duration for the opacity transition.\n         * @type {number}\n         */\n        _this.transition_ =\n            options.transition === undefined ? 250 : options.transition;\n        /**\n         * Lookup of start times for rendering transitions.  If the start time is\n         * equal to -1, the transition is complete.\n         * @type {Object<string, number>}\n         */\n        _this.transitionStarts_ = {};\n        /**\n         * @type {boolean}\n         */\n        _this.interpolate = !!options.interpolate;\n        return _this;\n    }\n    /**\n     * @protected\n     */\n    Tile.prototype.changed = function () {\n        this.dispatchEvent(EventType.CHANGE);\n    };\n    /**\n     * Called by the tile cache when the tile is removed from the cache due to expiry\n     */\n    Tile.prototype.release = function () { };\n    /**\n     * @return {string} Key.\n     */\n    Tile.prototype.getKey = function () {\n        return this.key + '/' + this.tileCoord;\n    };\n    /**\n     * Get the interim tile most suitable for rendering using the chain of interim\n     * tiles. This corresponds to the  most recent tile that has been loaded, if no\n     * such tile exists, the original tile is returned.\n     * @return {!Tile} Best tile for rendering.\n     */\n    Tile.prototype.getInterimTile = function () {\n        if (!this.interimTile) {\n            //empty chain\n            return this;\n        }\n        var tile = this.interimTile;\n        // find the first loaded tile and return it. Since the chain is sorted in\n        // decreasing order of creation time, there is no need to search the remainder\n        // of the list (all those tiles correspond to older requests and will be\n        // cleaned up by refreshInterimChain)\n        do {\n            if (tile.getState() == TileState.LOADED) {\n                // Show tile immediately instead of fading it in after loading, because\n                // the interim tile is in place already\n                this.transition_ = 0;\n                return tile;\n            }\n            tile = tile.interimTile;\n        } while (tile);\n        // we can not find a better tile\n        return this;\n    };\n    /**\n     * Goes through the chain of interim tiles and discards sections of the chain\n     * that are no longer relevant.\n     */\n    Tile.prototype.refreshInterimChain = function () {\n        if (!this.interimTile) {\n            return;\n        }\n        var tile = this.interimTile;\n        /**\n         * @type {Tile}\n         */\n        var prev = this;\n        do {\n            if (tile.getState() == TileState.LOADED) {\n                //we have a loaded tile, we can discard the rest of the list\n                //we would could abort any LOADING tile request\n                //older than this tile (i.e. any LOADING tile following this entry in the chain)\n                tile.interimTile = null;\n                break;\n            }\n            else if (tile.getState() == TileState.LOADING) {\n                //keep this LOADING tile any loaded tiles later in the chain are\n                //older than this tile, so we're still interested in the request\n                prev = tile;\n            }\n            else if (tile.getState() == TileState.IDLE) {\n                //the head of the list is the most current tile, we don't need\n                //to start any other requests for this chain\n                prev.interimTile = tile.interimTile;\n            }\n            else {\n                prev = tile;\n            }\n            tile = prev.interimTile;\n        } while (tile);\n    };\n    /**\n     * Get the tile coordinate for this tile.\n     * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n     * @api\n     */\n    Tile.prototype.getTileCoord = function () {\n        return this.tileCoord;\n    };\n    /**\n     * @return {import(\"./TileState.js\").default} State.\n     */\n    Tile.prototype.getState = function () {\n        return this.state;\n    };\n    /**\n     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n     * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n     * the tile queue and will block other requests.\n     * @param {import(\"./TileState.js\").default} state State.\n     * @api\n     */\n    Tile.prototype.setState = function (state) {\n        if (this.state !== TileState.ERROR && this.state > state) {\n            throw new Error('Tile load sequence violation');\n        }\n        this.state = state;\n        this.changed();\n    };\n    /**\n     * Load the image or retry if loading previously failed.\n     * Loading is taken care of by the tile queue, and calling this method is\n     * only needed for preloading or for reloading in case of an error.\n     * @abstract\n     * @api\n     */\n    Tile.prototype.load = function () {\n        abstract();\n    };\n    /**\n     * Get the alpha value for rendering.\n     * @param {string} id An id for the renderer.\n     * @param {number} time The render frame time.\n     * @return {number} A number between 0 and 1.\n     */\n    Tile.prototype.getAlpha = function (id, time) {\n        if (!this.transition_) {\n            return 1;\n        }\n        var start = this.transitionStarts_[id];\n        if (!start) {\n            start = time;\n            this.transitionStarts_[id] = start;\n        }\n        else if (start === -1) {\n            return 1;\n        }\n        var delta = time - start + 1000 / 60; // avoid rendering at 0\n        if (delta >= this.transition_) {\n            return 1;\n        }\n        return easeIn(delta / this.transition_);\n    };\n    /**\n     * Determine if a tile is in an alpha transition.  A tile is considered in\n     * transition if tile.getAlpha() has not yet been called or has been called\n     * and returned 1.\n     * @param {string} id An id for the renderer.\n     * @return {boolean} The tile is in transition.\n     */\n    Tile.prototype.inTransition = function (id) {\n        if (!this.transition_) {\n            return false;\n        }\n        return this.transitionStarts_[id] !== -1;\n    };\n    /**\n     * Mark a transition as complete.\n     * @param {string} id An id for the renderer.\n     */\n    Tile.prototype.endTransition = function (id) {\n        if (this.transition_) {\n            this.transitionStarts_[id] = -1;\n        }\n    };\n    return Tile;\n}(EventTarget));\nexport default Tile;\n//# sourceMappingURL=Tile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\nvar TileCache = /** @class */ (function (_super) {\n    __extends(TileCache, _super);\n    function TileCache() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    TileCache.prototype.expireCache = function (usedTiles) {\n        while (this.canExpireCache()) {\n            var tile = this.peekLast();\n            if (tile.getKey() in usedTiles) {\n                break;\n            }\n            else {\n                this.pop().release();\n            }\n        }\n    };\n    /**\n     * Prune all tiles from the cache that don't have the same z as the newest tile.\n     */\n    TileCache.prototype.pruneExceptNewestZ = function () {\n        if (this.getCount() === 0) {\n            return;\n        }\n        var key = this.peekFirstKey();\n        var tileCoord = fromKey(key);\n        var z = tileCoord[0];\n        this.forEach(function (tile) {\n            if (tile.tileCoord[0] !== z) {\n                this.remove(getKey(tile.tileCoord));\n                tile.release();\n            }\n        }.bind(this));\n    };\n    return TileCache;\n}(LRUCache));\nexport default TileCache;\n//# sourceMappingURL=TileCache.js.map","/**\n * @module ol/ViewProperty\n */\n/**\n * @enum {string}\n */\nexport default {\n    CENTER: 'center',\n    RESOLUTION: 'resolution',\n    ROTATION: 'rotation',\n};\n//# sourceMappingURL=ViewProperty.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/View\n */\nimport BaseObject from './Object.js';\nimport GeometryType from './geom/GeometryType.js';\nimport Units from './proj/Units.js';\nimport ViewHint from './ViewHint.js';\nimport ViewProperty from './ViewProperty.js';\nimport { DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, createProjection, disableCoordinateWarning, fromUserCoordinate, fromUserExtent, getUserProjection, toUserCoordinate, toUserExtent, } from './proj.js';\nimport { VOID } from './functions.js';\nimport { add as addCoordinate, equals as coordinatesEqual, equals, rotate as rotateCoordinate, } from './coordinate.js';\nimport { assert } from './asserts.js';\nimport { assign } from './obj.js';\nimport { none as centerNone, createExtent } from './centerconstraint.js';\nimport { clamp, modulo } from './math.js';\nimport { createMinMaxResolution, createSnapToPower, createSnapToResolutions, } from './resolutionconstraint.js';\nimport { createSnapToN, createSnapToZero, disable, none as rotationNone, } from './rotationconstraint.js';\nimport { easeOut, inAndOut } from './easing.js';\nimport { getCenter, getForViewAndSize, getHeight, getWidth, isEmpty, } from './extent.js';\nimport { linearFindNearest } from './array.js';\nimport { fromExtent as polygonFromExtent } from './geom/Polygon.js';\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {import(\"./coordinate.js\").Coordinate} [sourceCenter] Source center.\n * @property {import(\"./coordinate.js\").Coordinate} [targetCenter] Target center.\n * @property {number} [sourceResolution] Source resolution.\n * @property {number} [targetResolution] Target resolution.\n * @property {number} [sourceRotation] Source rotation.\n * @property {number} [targetRotation] Target rotation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Anchor.\n * @property {number} start Start.\n * @property {number} duration Duration.\n * @property {boolean} complete Complete.\n * @property {function(number):number} easing Easing.\n * @property {function(boolean):void} callback Callback.\n */\n/**\n * @typedef {Object} Constraints\n * @property {import(\"./centerconstraint.js\").Type} center Center.\n * @property {import(\"./resolutionconstraint.js\").Type} resolution Resolution.\n * @property {import(\"./rotationconstraint.js\").Type} rotation Rotation.\n */\n/**\n * @typedef {Object} FitOptions\n * @property {import(\"./size.js\").Size} [size] The size in pixels of the box to fit\n * the extent into. Default is the current size of the first map in the DOM that\n * uses this view, or `[100, 100]` if no such map is found.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,\n * get the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean):void} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n/**\n * @typedef {Object} ViewOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The initial center for\n * the view. If a user projection is not set, the coordinate system for the center is\n * specified with the `projection` option. Layer sources will not be fetched if this\n * is not set, but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {import(\"./extent.js\").Extent} [extent] The extent that constrains the\n * view, in other words, nothing outside of this extent can be visible on the map.\n * @property {boolean} [constrainOnlyCenter=false] If true, the extent\n * constraint will only apply to the view center and not the whole extent.\n * @property {boolean} [smoothExtentConstraint=true] If true, the extent\n * constraint will be applied smoothly, i.e. allow the view to go slightly outside\n * of the given `extent`.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection's validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {boolean} [multiWorld=false] If `false` the view is constrained so\n * only one world is visible, and you cannot pan off the edge.  If `true` the map\n * may show multiple worlds at low zoom levels.  Only used if the `projection` is\n * global.  Note that if `extent` is also provided it is given precedence.\n * @property {boolean} [constrainResolution=false] If true, the view will always\n * animate to the closest zoom level after an interaction; false means\n * intermediary zoom levels are allowed.\n * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution\n * min/max values will be applied smoothly, i. e. allow the view to exceed slightly\n * the given resolution or zoom bounds.\n * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to\n * show the full configured extent. By default, when a view is configured with an\n * extent, users will not be able to zoom out so the viewport exceeds the extent in\n * either dimension. This means the full extent may not be visible if the viewport\n * is taller or wider than the aspect ratio of the configured extent. If\n * showFullExtent is true, the user will be able to zoom out so that the viewport\n * exceeds the height or width of the configured extent, but not both, allowing the\n * full extent to be shown.\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array<number>} [resolutions] Resolutions that determine the\n * zoom levels if specified. The index in the array corresponds to the zoom level,\n * therefore the resolution values have to be in descending order. It also constrains\n * the resolution by the minimum and maximum value. If set the `maxResolution`,\n * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view.\n * @property {number} [zoomFactor=2] The zoom factor used to compute the\n * corresponding resolution.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).\n * If the map viewport is partially covered with other content (overlays) along\n * its edges, this setting allows to shift the center of the viewport away from\n * that content. The order of the values is top, right, bottom, left.\n */\n/**\n * @typedef {Object} AnimationOptions\n * @property {import(\"./coordinate.js\").Coordinate} [center] The center of the view at the end of\n * the animation.\n * @property {number} [zoom] The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number} [resolution] The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number} [rotation] The rotation of the view at the end of\n * the animation.\n * @property {import(\"./coordinate.js\").Coordinate} [anchor] Optional anchor to remain fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing.inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation's duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n/**\n * @typedef {Object} State\n * @property {import(\"./coordinate.js\").Coordinate} center Center.\n * @property {import(\"./proj/Projection.js\").default} projection Projection.\n * @property {number} resolution Resolution.\n * @property {import(\"./coordinate.js\").Coordinate} [nextCenter] The next center during an animation series.\n * @property {number} [nextResolution] The next resolution during an animation series.\n * @property {number} [nextRotation] The next rotation during an animation series.\n * @property {number} rotation Rotation.\n * @property {number} zoom Zoom.\n */\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\nvar DEFAULT_MIN_ZOOM = 0;\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes\n */\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<ViewObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature\n */\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * A View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Web Mercator (EPSG:3857).\n *\n * ### The view states\n *\n * A View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * The `zoom` state is actually not saved on the view: all computations\n * internally use the `resolution` state. Still, the `setZoom` and `getZoom`\n * methods are available, as well as `getResolutionForZoom` and\n * `getZoomForResolution` to switch from one system to the other.\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view, but any constraint defined in the constructor will\n * be applied along the way.\n *\n * A View object can have a *resolution constraint*, a *rotation constraint*\n * and a *center constraint*.\n *\n * The *resolution constraint* typically restricts min/max values and\n * snaps to specific resolutions. It is determined by the following\n * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.\n * If `resolutions` is set, the other three options are ignored. See\n * documentation for each option for more information. By default, the view\n * only has a min/max restriction and allow intermediary zoom levels when\n * pinch-zooming for example.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default rotation is allowed and its value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the view center is not constrained at all.\n *\n * ### Changing the view state\n *\n * It is important to note that `setZoom`, `setResolution`, `setCenter` and\n * `setRotation` are subject to the above mentioned constraints. As such, it\n * may sometimes not be possible to know in advance the resulting state of the\n * View. For example, calling `setResolution(10)` does not guarantee that\n * `getResolution()` will return `10`.\n *\n * A consequence of this is that, when applying a delta on the view state, one\n * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`\n * rather than the corresponding setters. This will let view do its internal\n * computations. Besides, the `adjust*` methods also take an `opt_anchor`\n * argument which allows specifying an origin for the transformation.\n *\n * ### Interacting with the view\n *\n * View constraints are usually only applied when the view is *at rest*, meaning that\n * no interaction or animation is ongoing. As such, if the user puts the view in a\n * state that is not equivalent to a constrained one (e.g. rotating the view when\n * the snap angle is 0), an animation will be triggered at the interaction end to\n * put back the view to a stable state;\n *\n * @api\n */\nvar View = /** @class */ (function (_super) {\n    __extends(View, _super);\n    /**\n     * @param {ViewOptions} [opt_options] View options.\n     */\n    function View(opt_options) {\n        var _this = _super.call(this) || this;\n        /***\n         * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n         */\n        _this.on;\n        /***\n         * @type {ViewOnSignature<import(\"./events\").EventsKey>}\n         */\n        _this.once;\n        /***\n         * @type {ViewOnSignature<void>}\n         */\n        _this.un;\n        var options = assign({}, opt_options);\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.hints_ = [0, 0];\n        /**\n         * @private\n         * @type {Array<Array<Animation>>}\n         */\n        _this.animations_ = [];\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.updateAnimationKey_;\n        /**\n         * @private\n         * @const\n         * @type {import(\"./proj/Projection.js\").default}\n         */\n        _this.projection_ = createProjection(options.projection, 'EPSG:3857');\n        /**\n         * @private\n         * @type {import(\"./size.js\").Size}\n         */\n        _this.viewportSize_ = [100, 100];\n        /**\n         * @private\n         * @type {import(\"./coordinate.js\").Coordinate|undefined}\n         */\n        _this.targetCenter_ = null;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.targetResolution_;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.targetRotation_;\n        /**\n         * @private\n         * @type {import(\"./coordinate.js\").Coordinate}\n         */\n        _this.nextCenter_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.nextResolution_;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.nextRotation_;\n        /**\n         * @private\n         * @type {import(\"./coordinate.js\").Coordinate|undefined}\n         */\n        _this.cancelAnchor_ = undefined;\n        if (options.projection) {\n            disableCoordinateWarning();\n        }\n        if (options.center) {\n            options.center = fromUserCoordinate(options.center, _this.projection_);\n        }\n        if (options.extent) {\n            options.extent = fromUserExtent(options.extent, _this.projection_);\n        }\n        _this.applyOptions_(options);\n        return _this;\n    }\n    /**\n     * Set up the view with the given options.\n     * @param {ViewOptions} options View options.\n     */\n    View.prototype.applyOptions_ = function (options) {\n        var properties = assign({}, options);\n        for (var key in ViewProperty) {\n            delete properties[key];\n        }\n        this.setProperties(properties, true);\n        var resolutionConstraintInfo = createResolutionConstraint(options);\n        /**\n         * @private\n         * @type {number}\n         */\n        this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.minResolution_ = resolutionConstraintInfo.minResolution;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n        /**\n         * @private\n         * @type {Array<number>|undefined}\n         */\n        this.resolutions_ = options.resolutions;\n        /**\n         * @type {Array<number>|undefined}\n         * @private\n         */\n        this.padding_ = options.padding;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.minZoom_ = resolutionConstraintInfo.minZoom;\n        var centerConstraint = createCenterConstraint(options);\n        var resolutionConstraint = resolutionConstraintInfo.constraint;\n        var rotationConstraint = createRotationConstraint(options);\n        /**\n         * @private\n         * @type {Constraints}\n         */\n        this.constraints_ = {\n            center: centerConstraint,\n            resolution: resolutionConstraint,\n            rotation: rotationConstraint,\n        };\n        this.setRotation(options.rotation !== undefined ? options.rotation : 0);\n        this.setCenterInternal(options.center !== undefined ? options.center : null);\n        if (options.resolution !== undefined) {\n            this.setResolution(options.resolution);\n        }\n        else if (options.zoom !== undefined) {\n            this.setZoom(options.zoom);\n        }\n    };\n    Object.defineProperty(View.prototype, \"padding\", {\n        /**\n         * Padding (in css pixels).\n         * If the map viewport is partially covered with other content (overlays) along\n         * its edges, this setting allows to shift the center of the viewport away from that\n         * content. The order of the values in the array is top, right, bottom, left.\n         * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.\n         * @type {Array<number>|undefined}\n         * @api\n         */\n        get: function () {\n            return this.padding_;\n        },\n        set: function (padding) {\n            var oldPadding = this.padding_;\n            this.padding_ = padding;\n            var center = this.getCenter();\n            if (center) {\n                var newPadding = padding || [0, 0, 0, 0];\n                oldPadding = oldPadding || [0, 0, 0, 0];\n                var resolution = this.getResolution();\n                var offsetX = (resolution / 2) *\n                    (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);\n                var offsetY = (resolution / 2) *\n                    (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);\n                this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Get an updated version of the view options used to construct the view.  The\n     * current resolution (or zoom), center, and rotation are applied to any stored\n     * options.  The provided options can be used to apply new min/max zoom or\n     * resolution limits.\n     * @param {ViewOptions} newOptions New options to be applied.\n     * @return {ViewOptions} New options updated with the current view state.\n     */\n    View.prototype.getUpdatedOptions_ = function (newOptions) {\n        var options = this.getProperties();\n        // preserve resolution (or zoom)\n        if (options.resolution !== undefined) {\n            options.resolution = this.getResolution();\n        }\n        else {\n            options.zoom = this.getZoom();\n        }\n        // preserve center\n        options.center = this.getCenterInternal();\n        // preserve rotation\n        options.rotation = this.getRotation();\n        return assign({}, options, newOptions);\n    };\n    /**\n     * Animate the view.  The view's center, zoom (or resolution), and rotation\n     * can be animated for smooth transitions between view states.  For example,\n     * to animate the view to a new zoom level:\n     *\n     *     view.animate({zoom: view.getZoom() + 1});\n     *\n     * By default, the animation lasts one second and uses in-and-out easing.  You\n     * can customize this behavior by including `duration` (in milliseconds) and\n     * `easing` options (see {@link module:ol/easing}).\n     *\n     * To chain together multiple animations, call the method with multiple\n     * animation objects.  For example, to first zoom and then pan:\n     *\n     *     view.animate({zoom: 10}, {center: [0, 0]});\n     *\n     * If you provide a function as the last argument to the animate method, it\n     * will get called at the end of an animation series.  The callback will be\n     * called with `true` if the animation series completed on its own or `false`\n     * if it was cancelled.\n     *\n     * Animations are cancelled by user interactions (e.g. dragging the map) or by\n     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n     * (or another method that calls one of these).\n     *\n     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation\n     *     options.  Multiple animations can be run in series by passing multiple\n     *     options objects.  To run multiple animations in parallel, call the method\n     *     multiple times.  An optional callback can be provided as a final\n     *     argument.  The callback will be called with a boolean indicating whether\n     *     the animation completed without being cancelled.\n     * @api\n     */\n    View.prototype.animate = function (var_args) {\n        if (this.isDef() && !this.getAnimating()) {\n            this.resolveConstraints(0);\n        }\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i) {\n            var options = arguments[i];\n            if (options.center) {\n                options = assign({}, options);\n                options.center = fromUserCoordinate(options.center, this.getProjection());\n            }\n            if (options.anchor) {\n                options = assign({}, options);\n                options.anchor = fromUserCoordinate(options.anchor, this.getProjection());\n            }\n            args[i] = options;\n        }\n        this.animateInternal.apply(this, args);\n    };\n    /**\n     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.\n     */\n    View.prototype.animateInternal = function (var_args) {\n        var animationCount = arguments.length;\n        var callback;\n        if (animationCount > 1 &&\n            typeof arguments[animationCount - 1] === 'function') {\n            callback = arguments[animationCount - 1];\n            --animationCount;\n        }\n        var i = 0;\n        for (; i < animationCount && !this.isDef(); ++i) {\n            // if view properties are not yet set, shortcut to the final state\n            var state = arguments[i];\n            if (state.center) {\n                this.setCenterInternal(state.center);\n            }\n            if (state.zoom !== undefined) {\n                this.setZoom(state.zoom);\n            }\n            else if (state.resolution) {\n                this.setResolution(state.resolution);\n            }\n            if (state.rotation !== undefined) {\n                this.setRotation(state.rotation);\n            }\n        }\n        if (i === animationCount) {\n            if (callback) {\n                animationCallback(callback, true);\n            }\n            return;\n        }\n        var start = Date.now();\n        var center = this.targetCenter_.slice();\n        var resolution = this.targetResolution_;\n        var rotation = this.targetRotation_;\n        var series = [];\n        for (; i < animationCount; ++i) {\n            var options = /** @type {AnimationOptions} */ (arguments[i]);\n            var animation = {\n                start: start,\n                complete: false,\n                anchor: options.anchor,\n                duration: options.duration !== undefined ? options.duration : 1000,\n                easing: options.easing || inAndOut,\n                callback: callback,\n            };\n            if (options.center) {\n                animation.sourceCenter = center;\n                animation.targetCenter = options.center.slice();\n                center = animation.targetCenter;\n            }\n            if (options.zoom !== undefined) {\n                animation.sourceResolution = resolution;\n                animation.targetResolution = this.getResolutionForZoom(options.zoom);\n                resolution = animation.targetResolution;\n            }\n            else if (options.resolution) {\n                animation.sourceResolution = resolution;\n                animation.targetResolution = options.resolution;\n                resolution = animation.targetResolution;\n            }\n            if (options.rotation !== undefined) {\n                animation.sourceRotation = rotation;\n                var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n                animation.targetRotation = rotation + delta;\n                rotation = animation.targetRotation;\n            }\n            // check if animation is a no-op\n            if (isNoopAnimation(animation)) {\n                animation.complete = true;\n                // we still push it onto the series for callback handling\n            }\n            else {\n                start += animation.duration;\n            }\n            series.push(animation);\n        }\n        this.animations_.push(series);\n        this.setHint(ViewHint.ANIMATING, 1);\n        this.updateAnimations_();\n    };\n    /**\n     * Determine if the view is being animated.\n     * @return {boolean} The view is being animated.\n     * @api\n     */\n    View.prototype.getAnimating = function () {\n        return this.hints_[ViewHint.ANIMATING] > 0;\n    };\n    /**\n     * Determine if the user is interacting with the view, such as panning or zooming.\n     * @return {boolean} The view is being interacted with.\n     * @api\n     */\n    View.prototype.getInteracting = function () {\n        return this.hints_[ViewHint.INTERACTING] > 0;\n    };\n    /**\n     * Cancel any ongoing animations.\n     * @api\n     */\n    View.prototype.cancelAnimations = function () {\n        this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);\n        var anchor;\n        for (var i = 0, ii = this.animations_.length; i < ii; ++i) {\n            var series = this.animations_[i];\n            if (series[0].callback) {\n                animationCallback(series[0].callback, false);\n            }\n            if (!anchor) {\n                for (var j = 0, jj = series.length; j < jj; ++j) {\n                    var animation = series[j];\n                    if (!animation.complete) {\n                        anchor = animation.anchor;\n                        break;\n                    }\n                }\n            }\n        }\n        this.animations_.length = 0;\n        this.cancelAnchor_ = anchor;\n        this.nextCenter_ = null;\n        this.nextResolution_ = NaN;\n        this.nextRotation_ = NaN;\n    };\n    /**\n     * Update all animations.\n     */\n    View.prototype.updateAnimations_ = function () {\n        if (this.updateAnimationKey_ !== undefined) {\n            cancelAnimationFrame(this.updateAnimationKey_);\n            this.updateAnimationKey_ = undefined;\n        }\n        if (!this.getAnimating()) {\n            return;\n        }\n        var now = Date.now();\n        var more = false;\n        for (var i = this.animations_.length - 1; i >= 0; --i) {\n            var series = this.animations_[i];\n            var seriesComplete = true;\n            for (var j = 0, jj = series.length; j < jj; ++j) {\n                var animation = series[j];\n                if (animation.complete) {\n                    continue;\n                }\n                var elapsed = now - animation.start;\n                var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\n                if (fraction >= 1) {\n                    animation.complete = true;\n                    fraction = 1;\n                }\n                else {\n                    seriesComplete = false;\n                }\n                var progress = animation.easing(fraction);\n                if (animation.sourceCenter) {\n                    var x0 = animation.sourceCenter[0];\n                    var y0 = animation.sourceCenter[1];\n                    var x1 = animation.targetCenter[0];\n                    var y1 = animation.targetCenter[1];\n                    this.nextCenter_ = animation.targetCenter;\n                    var x = x0 + progress * (x1 - x0);\n                    var y = y0 + progress * (y1 - y0);\n                    this.targetCenter_ = [x, y];\n                }\n                if (animation.sourceResolution && animation.targetResolution) {\n                    var resolution = progress === 1\n                        ? animation.targetResolution\n                        : animation.sourceResolution +\n                            progress *\n                                (animation.targetResolution - animation.sourceResolution);\n                    if (animation.anchor) {\n                        var size = this.getViewportSize_(this.getRotation());\n                        var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);\n                        this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);\n                    }\n                    this.nextResolution_ = animation.targetResolution;\n                    this.targetResolution_ = resolution;\n                    this.applyTargetState_(true);\n                }\n                if (animation.sourceRotation !== undefined &&\n                    animation.targetRotation !== undefined) {\n                    var rotation = progress === 1\n                        ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -\n                            Math.PI\n                        : animation.sourceRotation +\n                            progress *\n                                (animation.targetRotation - animation.sourceRotation);\n                    if (animation.anchor) {\n                        var constrainedRotation = this.constraints_.rotation(rotation, true);\n                        this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);\n                    }\n                    this.nextRotation_ = animation.targetRotation;\n                    this.targetRotation_ = rotation;\n                }\n                this.applyTargetState_(true);\n                more = true;\n                if (!animation.complete) {\n                    break;\n                }\n            }\n            if (seriesComplete) {\n                this.animations_[i] = null;\n                this.setHint(ViewHint.ANIMATING, -1);\n                this.nextCenter_ = null;\n                this.nextResolution_ = NaN;\n                this.nextRotation_ = NaN;\n                var callback = series[0].callback;\n                if (callback) {\n                    animationCallback(callback, true);\n                }\n            }\n        }\n        // prune completed series\n        this.animations_ = this.animations_.filter(Boolean);\n        if (more && this.updateAnimationKey_ === undefined) {\n            this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));\n        }\n    };\n    /**\n     * @param {number} rotation Target rotation.\n     * @param {import(\"./coordinate.js\").Coordinate} anchor Rotation anchor.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for rotation and anchor.\n     */\n    View.prototype.calculateCenterRotate = function (rotation, anchor) {\n        var center;\n        var currentCenter = this.getCenterInternal();\n        if (currentCenter !== undefined) {\n            center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n            rotateCoordinate(center, rotation - this.getRotation());\n            addCoordinate(center, anchor);\n        }\n        return center;\n    };\n    /**\n     * @param {number} resolution Target resolution.\n     * @param {import(\"./coordinate.js\").Coordinate} anchor Zoom anchor.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center for resolution and anchor.\n     */\n    View.prototype.calculateCenterZoom = function (resolution, anchor) {\n        var center;\n        var currentCenter = this.getCenterInternal();\n        var currentResolution = this.getResolution();\n        if (currentCenter !== undefined && currentResolution !== undefined) {\n            var x = anchor[0] -\n                (resolution * (anchor[0] - currentCenter[0])) / currentResolution;\n            var y = anchor[1] -\n                (resolution * (anchor[1] - currentCenter[1])) / currentResolution;\n            center = [x, y];\n        }\n        return center;\n    };\n    /**\n     * Returns the current viewport size.\n     * @private\n     * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size\n     * @return {import(\"./size.js\").Size} Viewport size or `[100, 100]` when no viewport is found.\n     */\n    View.prototype.getViewportSize_ = function (opt_rotation) {\n        var size = this.viewportSize_;\n        if (opt_rotation) {\n            var w = size[0];\n            var h = size[1];\n            return [\n                Math.abs(w * Math.cos(opt_rotation)) +\n                    Math.abs(h * Math.sin(opt_rotation)),\n                Math.abs(w * Math.sin(opt_rotation)) +\n                    Math.abs(h * Math.cos(opt_rotation)),\n            ];\n        }\n        else {\n            return size;\n        }\n    };\n    /**\n     * Stores the viewport size on the view. The viewport size is not read every time from the DOM\n     * to avoid performance hit and layout reflow.\n     * This should be done on map size change.\n     * Note: the constraints are not resolved during an animation to avoid stopping it\n     * @param {import(\"./size.js\").Size} [opt_size] Viewport size; if undefined, [100, 100] is assumed\n     */\n    View.prototype.setViewportSize = function (opt_size) {\n        this.viewportSize_ = Array.isArray(opt_size)\n            ? opt_size.slice()\n            : [100, 100];\n        if (!this.getAnimating()) {\n            this.resolveConstraints(0);\n        }\n    };\n    /**\n     * Get the view center.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n     * @observable\n     * @api\n     */\n    View.prototype.getCenter = function () {\n        var center = this.getCenterInternal();\n        if (!center) {\n            return center;\n        }\n        return toUserCoordinate(center, this.getProjection());\n    };\n    /**\n     * Get the view center without transforming to user projection.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} The center of the view.\n     */\n    View.prototype.getCenterInternal = function () {\n        return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (this.get(ViewProperty.CENTER));\n    };\n    /**\n     * @return {Constraints} Constraints.\n     */\n    View.prototype.getConstraints = function () {\n        return this.constraints_;\n    };\n    /**\n     * @return {boolean} Resolution constraint is set\n     */\n    View.prototype.getConstrainResolution = function () {\n        return this.get('constrainResolution');\n    };\n    /**\n     * @param {Array<number>} [opt_hints] Destination array.\n     * @return {Array<number>} Hint.\n     */\n    View.prototype.getHints = function (opt_hints) {\n        if (opt_hints !== undefined) {\n            opt_hints[0] = this.hints_[0];\n            opt_hints[1] = this.hints_[1];\n            return opt_hints;\n        }\n        else {\n            return this.hints_.slice();\n        }\n    };\n    /**\n     * Calculate the extent for the current view state and the passed size.\n     * The size is the pixel dimensions of the box into which the calculated extent\n     * should fit. In most cases you want to get the extent of the entire map,\n     * that is `map.getSize()`.\n     * @param {import(\"./size.js\").Size} [opt_size] Box pixel size. If not provided, the size\n     * of the map that uses this view will be used.\n     * @return {import(\"./extent.js\").Extent} Extent.\n     * @api\n     */\n    View.prototype.calculateExtent = function (opt_size) {\n        var extent = this.calculateExtentInternal(opt_size);\n        return toUserExtent(extent, this.getProjection());\n    };\n    /**\n     * @param {import(\"./size.js\").Size} [opt_size] Box pixel size. If not provided,\n     * the map's last known viewport size will be used.\n     * @return {import(\"./extent.js\").Extent} Extent.\n     */\n    View.prototype.calculateExtentInternal = function (opt_size) {\n        var size = opt_size || this.getViewportSizeMinusPadding_();\n        var center = /** @type {!import(\"./coordinate.js\").Coordinate} */ (this.getCenterInternal());\n        assert(center, 1); // The view center is not defined\n        var resolution = /** @type {!number} */ (this.getResolution());\n        assert(resolution !== undefined, 2); // The view resolution is not defined\n        var rotation = /** @type {!number} */ (this.getRotation());\n        assert(rotation !== undefined, 3); // The view rotation is not defined\n        return getForViewAndSize(center, resolution, rotation, size);\n    };\n    /**\n     * Get the maximum resolution of the view.\n     * @return {number} The maximum resolution of the view.\n     * @api\n     */\n    View.prototype.getMaxResolution = function () {\n        return this.maxResolution_;\n    };\n    /**\n     * Get the minimum resolution of the view.\n     * @return {number} The minimum resolution of the view.\n     * @api\n     */\n    View.prototype.getMinResolution = function () {\n        return this.minResolution_;\n    };\n    /**\n     * Get the maximum zoom level for the view.\n     * @return {number} The maximum zoom level.\n     * @api\n     */\n    View.prototype.getMaxZoom = function () {\n        return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));\n    };\n    /**\n     * Set a new maximum zoom level for the view.\n     * @param {number} zoom The maximum zoom level.\n     * @api\n     */\n    View.prototype.setMaxZoom = function (zoom) {\n        this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));\n    };\n    /**\n     * Get the minimum zoom level for the view.\n     * @return {number} The minimum zoom level.\n     * @api\n     */\n    View.prototype.getMinZoom = function () {\n        return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));\n    };\n    /**\n     * Set a new minimum zoom level for the view.\n     * @param {number} zoom The minimum zoom level.\n     * @api\n     */\n    View.prototype.setMinZoom = function (zoom) {\n        this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));\n    };\n    /**\n     * Set whether the view should allow intermediary zoom levels.\n     * @param {boolean} enabled Whether the resolution is constrained.\n     * @api\n     */\n    View.prototype.setConstrainResolution = function (enabled) {\n        this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));\n    };\n    /**\n     * Get the view projection.\n     * @return {import(\"./proj/Projection.js\").default} The projection of the view.\n     * @api\n     */\n    View.prototype.getProjection = function () {\n        return this.projection_;\n    };\n    /**\n     * Get the view resolution.\n     * @return {number|undefined} The resolution of the view.\n     * @observable\n     * @api\n     */\n    View.prototype.getResolution = function () {\n        return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));\n    };\n    /**\n     * Get the resolutions for the view. This returns the array of resolutions\n     * passed to the constructor of the View, or undefined if none were given.\n     * @return {Array<number>|undefined} The resolutions of the view.\n     * @api\n     */\n    View.prototype.getResolutions = function () {\n        return this.resolutions_;\n    };\n    /**\n     * Get the resolution for a provided extent (in map units) and size (in pixels).\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {import(\"./size.js\").Size} [opt_size] Box pixel size.\n     * @return {number} The resolution at which the provided extent will render at\n     *     the given size.\n     * @api\n     */\n    View.prototype.getResolutionForExtent = function (extent, opt_size) {\n        return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);\n    };\n    /**\n     * Get the resolution for a provided extent (in map units) and size (in pixels).\n     * @param {import(\"./extent.js\").Extent} extent Extent.\n     * @param {import(\"./size.js\").Size} [opt_size] Box pixel size.\n     * @return {number} The resolution at which the provided extent will render at\n     *     the given size.\n     */\n    View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {\n        var size = opt_size || this.getViewportSizeMinusPadding_();\n        var xResolution = getWidth(extent) / size[0];\n        var yResolution = getHeight(extent) / size[1];\n        return Math.max(xResolution, yResolution);\n    };\n    /**\n     * Return a function that returns a value between 0 and 1 for a\n     * resolution. Exponential scaling is assumed.\n     * @param {number} [opt_power] Power.\n     * @return {function(number): number} Resolution for value function.\n     */\n    View.prototype.getResolutionForValueFunction = function (opt_power) {\n        var power = opt_power || 2;\n        var maxResolution = this.getConstrainedResolution(this.maxResolution_);\n        var minResolution = this.minResolution_;\n        var max = Math.log(maxResolution / minResolution) / Math.log(power);\n        return (\n        /**\n         * @param {number} value Value.\n         * @return {number} Resolution.\n         */\n        function (value) {\n            var resolution = maxResolution / Math.pow(power, value * max);\n            return resolution;\n        });\n    };\n    /**\n     * Get the view rotation.\n     * @return {number} The rotation of the view in radians.\n     * @observable\n     * @api\n     */\n    View.prototype.getRotation = function () {\n        return /** @type {number} */ (this.get(ViewProperty.ROTATION));\n    };\n    /**\n     * Return a function that returns a resolution for a value between\n     * 0 and 1. Exponential scaling is assumed.\n     * @param {number} [opt_power] Power.\n     * @return {function(number): number} Value for resolution function.\n     */\n    View.prototype.getValueForResolutionFunction = function (opt_power) {\n        var logPower = Math.log(opt_power || 2);\n        var maxResolution = this.getConstrainedResolution(this.maxResolution_);\n        var minResolution = this.minResolution_;\n        var max = Math.log(maxResolution / minResolution) / logPower;\n        return (\n        /**\n         * @param {number} resolution Resolution.\n         * @return {number} Value.\n         */\n        function (resolution) {\n            var value = Math.log(maxResolution / resolution) / logPower / max;\n            return value;\n        });\n    };\n    /**\n     * Returns the size of the viewport minus padding.\n     * @private\n     * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size\n     * @return {import(\"./size.js\").Size} Viewport size reduced by the padding.\n     */\n    View.prototype.getViewportSizeMinusPadding_ = function (opt_rotation) {\n        var size = this.getViewportSize_(opt_rotation);\n        var padding = this.padding_;\n        if (padding) {\n            size = [\n                size[0] - padding[1] - padding[3],\n                size[1] - padding[0] - padding[2],\n            ];\n        }\n        return size;\n    };\n    /**\n     * @return {State} View state.\n     */\n    View.prototype.getState = function () {\n        var projection = this.getProjection();\n        var resolution = this.getResolution();\n        var rotation = this.getRotation();\n        var center = /** @type {import(\"./coordinate.js\").Coordinate} */ (this.getCenterInternal());\n        var padding = this.padding_;\n        if (padding) {\n            var reducedSize = this.getViewportSizeMinusPadding_();\n            center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);\n        }\n        return {\n            center: center.slice(0),\n            projection: projection !== undefined ? projection : null,\n            resolution: resolution,\n            nextCenter: this.nextCenter_,\n            nextResolution: this.nextResolution_,\n            nextRotation: this.nextRotation_,\n            rotation: rotation,\n            zoom: this.getZoom(),\n        };\n    };\n    /**\n     * Get the current zoom level. This method may return non-integer zoom levels\n     * if the view does not constrain the resolution, or if an interaction or\n     * animation is underway.\n     * @return {number|undefined} Zoom.\n     * @api\n     */\n    View.prototype.getZoom = function () {\n        var zoom;\n        var resolution = this.getResolution();\n        if (resolution !== undefined) {\n            zoom = this.getZoomForResolution(resolution);\n        }\n        return zoom;\n    };\n    /**\n     * Get the zoom level for a resolution.\n     * @param {number} resolution The resolution.\n     * @return {number|undefined} The zoom level for the provided resolution.\n     * @api\n     */\n    View.prototype.getZoomForResolution = function (resolution) {\n        var offset = this.minZoom_ || 0;\n        var max, zoomFactor;\n        if (this.resolutions_) {\n            var nearest = linearFindNearest(this.resolutions_, resolution, 1);\n            offset = nearest;\n            max = this.resolutions_[nearest];\n            if (nearest == this.resolutions_.length - 1) {\n                zoomFactor = 2;\n            }\n            else {\n                zoomFactor = max / this.resolutions_[nearest + 1];\n            }\n        }\n        else {\n            max = this.maxResolution_;\n            zoomFactor = this.zoomFactor_;\n        }\n        return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n    };\n    /**\n     * Get the resolution for a zoom level.\n     * @param {number} zoom Zoom level.\n     * @return {number} The view resolution for the provided zoom level.\n     * @api\n     */\n    View.prototype.getResolutionForZoom = function (zoom) {\n        if (this.resolutions_) {\n            if (this.resolutions_.length <= 1) {\n                return 0;\n            }\n            var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);\n            var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];\n            return (this.resolutions_[baseLevel] /\n                Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1)));\n        }\n        else {\n            return (this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_));\n        }\n    };\n    /**\n     * Fit the given geometry or extent based on the given map size and border.\n     * The size is pixel dimensions of the box to fit the extent into.\n     * In most cases you will want to use the map size, that is `map.getSize()`.\n     * Takes care of the map angle.\n     * @param {import(\"./geom/SimpleGeometry.js\").default|import(\"./extent.js\").Extent} geometryOrExtent The geometry or\n     *     extent to fit the view to.\n     * @param {FitOptions} [opt_options] Options.\n     * @api\n     */\n    View.prototype.fit = function (geometryOrExtent, opt_options) {\n        /** @type {import(\"./geom/SimpleGeometry.js\").default} */\n        var geometry;\n        assert(Array.isArray(geometryOrExtent) ||\n            typeof ( /** @type {?} */(geometryOrExtent).getSimplifiedGeometry) ===\n                'function', 24); // Invalid extent or geometry provided as `geometry`\n        if (Array.isArray(geometryOrExtent)) {\n            assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`\n            var extent = fromUserExtent(geometryOrExtent, this.getProjection());\n            geometry = polygonFromExtent(extent);\n        }\n        else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {\n            var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());\n            geometry = polygonFromExtent(extent);\n            geometry.rotate(this.getRotation(), getCenter(extent));\n        }\n        else {\n            var userProjection = getUserProjection();\n            if (userProjection) {\n                geometry = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometryOrExtent\n                    .clone()\n                    .transform(userProjection, this.getProjection()));\n            }\n            else {\n                geometry = geometryOrExtent;\n            }\n        }\n        this.fitInternal(geometry, opt_options);\n    };\n    /**\n     * Calculate rotated extent\n     * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n     * @return {import(\"./extent\").Extent} The rotated extent for the geometry.\n     */\n    View.prototype.rotatedExtentForGeometry = function (geometry) {\n        var rotation = this.getRotation();\n        var cosAngle = Math.cos(rotation);\n        var sinAngle = Math.sin(-rotation);\n        var coords = geometry.getFlatCoordinates();\n        var stride = geometry.getStride();\n        var minRotX = +Infinity;\n        var minRotY = +Infinity;\n        var maxRotX = -Infinity;\n        var maxRotY = -Infinity;\n        for (var i = 0, ii = coords.length; i < ii; i += stride) {\n            var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n            var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n            minRotX = Math.min(minRotX, rotX);\n            minRotY = Math.min(minRotY, rotY);\n            maxRotX = Math.max(maxRotX, rotX);\n            maxRotY = Math.max(maxRotY, rotY);\n        }\n        return [minRotX, minRotY, maxRotX, maxRotY];\n    };\n    /**\n     * @param {import(\"./geom/SimpleGeometry.js\").default} geometry The geometry.\n     * @param {FitOptions} [opt_options] Options.\n     */\n    View.prototype.fitInternal = function (geometry, opt_options) {\n        var options = opt_options || {};\n        var size = options.size;\n        if (!size) {\n            size = this.getViewportSizeMinusPadding_();\n        }\n        var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n        var nearest = options.nearest !== undefined ? options.nearest : false;\n        var minResolution;\n        if (options.minResolution !== undefined) {\n            minResolution = options.minResolution;\n        }\n        else if (options.maxZoom !== undefined) {\n            minResolution = this.getResolutionForZoom(options.maxZoom);\n        }\n        else {\n            minResolution = 0;\n        }\n        var rotatedExtent = this.rotatedExtentForGeometry(geometry);\n        // calculate resolution\n        var resolution = this.getResolutionForExtentInternal(rotatedExtent, [\n            size[0] - padding[1] - padding[3],\n            size[1] - padding[0] - padding[2],\n        ]);\n        resolution = isNaN(resolution)\n            ? minResolution\n            : Math.max(resolution, minResolution);\n        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);\n        // calculate center\n        var rotation = this.getRotation();\n        var sinAngle = Math.sin(rotation);\n        var cosAngle = Math.cos(rotation);\n        var centerRot = getCenter(rotatedExtent);\n        centerRot[0] += ((padding[1] - padding[3]) / 2) * resolution;\n        centerRot[1] += ((padding[0] - padding[2]) / 2) * resolution;\n        var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;\n        var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;\n        var center = this.getConstrainedCenter([centerX, centerY], resolution);\n        var callback = options.callback ? options.callback : VOID;\n        if (options.duration !== undefined) {\n            this.animateInternal({\n                resolution: resolution,\n                center: center,\n                duration: options.duration,\n                easing: options.easing,\n            }, callback);\n        }\n        else {\n            this.targetResolution_ = resolution;\n            this.targetCenter_ = center;\n            this.applyTargetState_(false, true);\n            animationCallback(callback, true);\n        }\n    };\n    /**\n     * Center on coordinate and view position.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"./size.js\").Size} size Box pixel size.\n     * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n     * @api\n     */\n    View.prototype.centerOn = function (coordinate, size, position) {\n        this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);\n    };\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"./size.js\").Size} size Box pixel size.\n     * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n     */\n    View.prototype.centerOnInternal = function (coordinate, size, position) {\n        this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));\n    };\n    /**\n     * Calculates the shift between map and viewport center.\n     * @param {import(\"./coordinate.js\").Coordinate} center Center.\n     * @param {number} resolution Resolution.\n     * @param {number} rotation Rotation.\n     * @param {import(\"./size.js\").Size} size Size.\n     * @return {Array<number>|undefined} Center shift.\n     */\n    View.prototype.calculateCenterShift = function (center, resolution, rotation, size) {\n        var centerShift;\n        var padding = this.padding_;\n        if (padding && center) {\n            var reducedSize = this.getViewportSizeMinusPadding_(-rotation);\n            var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);\n            centerShift = [\n                center[0] - shiftedCenter[0],\n                center[1] - shiftedCenter[1],\n            ];\n        }\n        return centerShift;\n    };\n    /**\n     * @return {boolean} Is defined.\n     */\n    View.prototype.isDef = function () {\n        return !!this.getCenterInternal() && this.getResolution() !== undefined;\n    };\n    /**\n     * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n     * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n     * @api\n     */\n    View.prototype.adjustCenter = function (deltaCoordinates) {\n        var center = toUserCoordinate(this.targetCenter_, this.getProjection());\n        this.setCenter([\n            center[0] + deltaCoordinates[0],\n            center[1] + deltaCoordinates[1],\n        ]);\n    };\n    /**\n     * Adds relative coordinates to the center of the view. Any extent constraint will apply.\n     * @param {import(\"./coordinate.js\").Coordinate} deltaCoordinates Relative value to add.\n     */\n    View.prototype.adjustCenterInternal = function (deltaCoordinates) {\n        var center = this.targetCenter_;\n        this.setCenterInternal([\n            center[0] + deltaCoordinates[0],\n            center[1] + deltaCoordinates[1],\n        ]);\n    };\n    /**\n     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n     * constraint will apply.\n     * @param {number} ratio The ratio to apply on the view resolution.\n     * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n     * @api\n     */\n    View.prototype.adjustResolution = function (ratio, opt_anchor) {\n        var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());\n        this.adjustResolutionInternal(ratio, anchor);\n    };\n    /**\n     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution\n     * constraint will apply.\n     * @param {number} ratio The ratio to apply on the view resolution.\n     * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n     */\n    View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {\n        var isMoving = this.getAnimating() || this.getInteracting();\n        var size = this.getViewportSize_(this.getRotation());\n        var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);\n        if (opt_anchor) {\n            this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);\n        }\n        this.targetResolution_ *= ratio;\n        this.applyTargetState_();\n    };\n    /**\n     * Adds a value to the view zoom level, optionally using an anchor. Any resolution\n     * constraint will apply.\n     * @param {number} delta Relative value to add to the zoom level.\n     * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n     * @api\n     */\n    View.prototype.adjustZoom = function (delta, opt_anchor) {\n        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);\n    };\n    /**\n     * Adds a value to the view rotation, optionally using an anchor. Any rotation\n     * constraint will apply.\n     * @param {number} delta Relative value to add to the zoom rotation, in radians.\n     * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The rotation center.\n     * @api\n     */\n    View.prototype.adjustRotation = function (delta, opt_anchor) {\n        if (opt_anchor) {\n            opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());\n        }\n        this.adjustRotationInternal(delta, opt_anchor);\n    };\n    /**\n     * @param {number} delta Relative value to add to the zoom rotation, in radians.\n     * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The rotation center.\n     */\n    View.prototype.adjustRotationInternal = function (delta, opt_anchor) {\n        var isMoving = this.getAnimating() || this.getInteracting();\n        var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);\n        if (opt_anchor) {\n            this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);\n        }\n        this.targetRotation_ += delta;\n        this.applyTargetState_();\n    };\n    /**\n     * Set the center of the current view. Any extent constraint will apply.\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n     * @observable\n     * @api\n     */\n    View.prototype.setCenter = function (center) {\n        this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);\n    };\n    /**\n     * Set the center using the view projection (not the user projection).\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center The center of the view.\n     */\n    View.prototype.setCenterInternal = function (center) {\n        this.targetCenter_ = center;\n        this.applyTargetState_();\n    };\n    /**\n     * @param {import(\"./ViewHint.js\").default} hint Hint.\n     * @param {number} delta Delta.\n     * @return {number} New value.\n     */\n    View.prototype.setHint = function (hint, delta) {\n        this.hints_[hint] += delta;\n        this.changed();\n        return this.hints_[hint];\n    };\n    /**\n     * Set the resolution for this view. Any resolution constraint will apply.\n     * @param {number|undefined} resolution The resolution of the view.\n     * @observable\n     * @api\n     */\n    View.prototype.setResolution = function (resolution) {\n        this.targetResolution_ = resolution;\n        this.applyTargetState_();\n    };\n    /**\n     * Set the rotation for this view. Any rotation constraint will apply.\n     * @param {number} rotation The rotation of the view in radians.\n     * @observable\n     * @api\n     */\n    View.prototype.setRotation = function (rotation) {\n        this.targetRotation_ = rotation;\n        this.applyTargetState_();\n    };\n    /**\n     * Zoom to a specific zoom level. Any resolution constrain will apply.\n     * @param {number} zoom Zoom level.\n     * @api\n     */\n    View.prototype.setZoom = function (zoom) {\n        this.setResolution(this.getResolutionForZoom(zoom));\n    };\n    /**\n     * Recompute rotation/resolution/center based on target values.\n     * Note: we have to compute rotation first, then resolution and center considering that\n     * parameters can influence one another in case a view extent constraint is present.\n     * @param {boolean} [opt_doNotCancelAnims] Do not cancel animations.\n     * @param {boolean} [opt_forceMoving] Apply constraints as if the view is moving.\n     * @private\n     */\n    View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {\n        var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;\n        // compute rotation\n        var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);\n        var size = this.getViewportSize_(newRotation);\n        var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);\n        var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));\n        if (this.get(ViewProperty.ROTATION) !== newRotation) {\n            this.set(ViewProperty.ROTATION, newRotation);\n        }\n        if (this.get(ViewProperty.RESOLUTION) !== newResolution) {\n            this.set(ViewProperty.RESOLUTION, newResolution);\n            this.set('zoom', this.getZoom(), true);\n        }\n        if (!newCenter ||\n            !this.get(ViewProperty.CENTER) ||\n            !equals(this.get(ViewProperty.CENTER), newCenter)) {\n            this.set(ViewProperty.CENTER, newCenter);\n        }\n        if (this.getAnimating() && !opt_doNotCancelAnims) {\n            this.cancelAnimations();\n        }\n        this.cancelAnchor_ = undefined;\n    };\n    /**\n     * If any constraints need to be applied, an animation will be triggered.\n     * This is typically done on interaction end.\n     * Note: calling this with a duration of 0 will apply the constrained values straight away,\n     * without animation.\n     * @param {number} [opt_duration] The animation duration in ms.\n     * @param {number} [opt_resolutionDirection] Which direction to zoom.\n     * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n     */\n    View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {\n        var duration = opt_duration !== undefined ? opt_duration : 200;\n        var direction = opt_resolutionDirection || 0;\n        var newRotation = this.constraints_.rotation(this.targetRotation_);\n        var size = this.getViewportSize_(newRotation);\n        var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);\n        var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));\n        if (duration === 0 && !this.cancelAnchor_) {\n            this.targetResolution_ = newResolution;\n            this.targetRotation_ = newRotation;\n            this.targetCenter_ = newCenter;\n            this.applyTargetState_();\n            return;\n        }\n        var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);\n        this.cancelAnchor_ = undefined;\n        if (this.getResolution() !== newResolution ||\n            this.getRotation() !== newRotation ||\n            !this.getCenterInternal() ||\n            !equals(this.getCenterInternal(), newCenter)) {\n            if (this.getAnimating()) {\n                this.cancelAnimations();\n            }\n            this.animateInternal({\n                rotation: newRotation,\n                center: newCenter,\n                resolution: newResolution,\n                duration: duration,\n                easing: easeOut,\n                anchor: anchor,\n            });\n        }\n    };\n    /**\n     * Notify the View that an interaction has started.\n     * The view state will be resolved to a stable one if needed\n     * (depending on its constraints).\n     * @api\n     */\n    View.prototype.beginInteraction = function () {\n        this.resolveConstraints(0);\n        this.setHint(ViewHint.INTERACTING, 1);\n    };\n    /**\n     * Notify the View that an interaction has ended. The view state will be resolved\n     * to a stable one if needed (depending on its constraints).\n     * @param {number} [opt_duration] Animation duration in ms.\n     * @param {number} [opt_resolutionDirection] Which direction to zoom.\n     * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n     * @api\n     */\n    View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {\n        var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());\n        this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);\n    };\n    /**\n     * Notify the View that an interaction has ended. The view state will be resolved\n     * to a stable one if needed (depending on its constraints).\n     * @param {number} [opt_duration] Animation duration in ms.\n     * @param {number} [opt_resolutionDirection] Which direction to zoom.\n     * @param {import(\"./coordinate.js\").Coordinate} [opt_anchor] The origin of the transformation.\n     */\n    View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {\n        this.setHint(ViewHint.INTERACTING, -1);\n        this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);\n    };\n    /**\n     * Get a valid position for the view center according to the current constraints.\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} targetCenter Target center position.\n     * @param {number} [opt_targetResolution] Target resolution. If not supplied, the current one will be used.\n     * This is useful to guess a valid center position at a different zoom level.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Valid center position.\n     */\n    View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {\n        var size = this.getViewportSize_(this.getRotation());\n        return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);\n    };\n    /**\n     * Get a valid zoom level according to the current view constraints.\n     * @param {number|undefined} targetZoom Target zoom.\n     * @param {number} [opt_direction=0] Indicate which resolution should be used\n     * by a renderer if the view resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @return {number|undefined} Valid zoom level.\n     */\n    View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {\n        var targetRes = this.getResolutionForZoom(targetZoom);\n        return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));\n    };\n    /**\n     * Get a valid resolution according to the current view constraints.\n     * @param {number|undefined} targetResolution Target resolution.\n     * @param {number} [opt_direction=0] Indicate which resolution should be used\n     * by a renderer if the view resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @return {number|undefined} Valid resolution.\n     */\n    View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {\n        var direction = opt_direction || 0;\n        var size = this.getViewportSize_(this.getRotation());\n        return this.constraints_.resolution(targetResolution, direction, size);\n    };\n    return View;\n}(BaseObject));\n/**\n * @param {Function} callback Callback.\n * @param {*} returnValue Return value.\n */\nfunction animationCallback(callback, returnValue) {\n    setTimeout(function () {\n        callback(returnValue);\n    }, 0);\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./centerconstraint.js\").Type} The constraint.\n */\nexport function createCenterConstraint(options) {\n    if (options.extent !== undefined) {\n        var smooth = options.smoothExtentConstraint !== undefined\n            ? options.smoothExtentConstraint\n            : true;\n        return createExtent(options.extent, options.constrainOnlyCenter, smooth);\n    }\n    var projection = createProjection(options.projection, 'EPSG:3857');\n    if (options.multiWorld !== true && projection.isGlobal()) {\n        var extent = projection.getExtent().slice();\n        extent[0] = -Infinity;\n        extent[2] = Infinity;\n        return createExtent(extent, false, false);\n    }\n    return centerNone;\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {{constraint: import(\"./resolutionconstraint.js\").Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\nexport function createResolutionConstraint(options) {\n    var resolutionConstraint;\n    var maxResolution;\n    var minResolution;\n    // TODO: move these to be ol constants\n    // see https://github.com/openlayers/openlayers/issues/2076\n    var defaultMaxZoom = 28;\n    var defaultZoomFactor = 2;\n    var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n    var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n    var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n    var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;\n    var smooth = options.smoothResolutionConstraint !== undefined\n        ? options.smoothResolutionConstraint\n        : true;\n    var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;\n    var projection = createProjection(options.projection, 'EPSG:3857');\n    var projExtent = projection.getExtent();\n    var constrainOnlyCenter = options.constrainOnlyCenter;\n    var extent = options.extent;\n    if (!multiWorld && !extent && projection.isGlobal()) {\n        constrainOnlyCenter = false;\n        extent = projExtent;\n    }\n    if (options.resolutions !== undefined) {\n        var resolutions = options.resolutions;\n        maxResolution = resolutions[minZoom];\n        minResolution =\n            resolutions[maxZoom] !== undefined\n                ? resolutions[maxZoom]\n                : resolutions[resolutions.length - 1];\n        if (options.constrainResolution) {\n            resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);\n        }\n        else {\n            resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);\n        }\n    }\n    else {\n        // calculate the default min and max resolution\n        var size = !projExtent\n            ? // use an extent that can fit the whole world if need be\n                (360 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit()\n            : Math.max(getWidth(projExtent), getHeight(projExtent));\n        var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n        var defaultMinResolution = defaultMaxResolution /\n            Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);\n        // user provided maxResolution takes precedence\n        maxResolution = options.maxResolution;\n        if (maxResolution !== undefined) {\n            minZoom = 0;\n        }\n        else {\n            maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n        }\n        // user provided minResolution takes precedence\n        minResolution = options.minResolution;\n        if (minResolution === undefined) {\n            if (options.maxZoom !== undefined) {\n                if (options.maxResolution !== undefined) {\n                    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n                }\n                else {\n                    minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n                }\n            }\n            else {\n                minResolution = defaultMinResolution;\n            }\n        }\n        // given discrete zoom levels, minResolution may be different than provided\n        maxZoom =\n            minZoom +\n                Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\n        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n        if (options.constrainResolution) {\n            resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);\n        }\n        else {\n            resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);\n        }\n    }\n    return {\n        constraint: resolutionConstraint,\n        maxResolution: maxResolution,\n        minResolution: minResolution,\n        minZoom: minZoom,\n        zoomFactor: zoomFactor,\n    };\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {import(\"./rotationconstraint.js\").Type} Rotation constraint.\n */\nexport function createRotationConstraint(options) {\n    var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;\n    if (enableRotation) {\n        var constrainRotation = options.constrainRotation;\n        if (constrainRotation === undefined || constrainRotation === true) {\n            return createSnapToZero();\n        }\n        else if (constrainRotation === false) {\n            return rotationNone;\n        }\n        else if (typeof constrainRotation === 'number') {\n            return createSnapToN(constrainRotation);\n        }\n        else {\n            return rotationNone;\n        }\n    }\n    else {\n        return disable;\n    }\n}\n/**\n * Determine if an animation involves no view change.\n * @param {Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\nexport function isNoopAnimation(animation) {\n    if (animation.sourceCenter && animation.targetCenter) {\n        if (!coordinatesEqual(animation.sourceCenter, animation.targetCenter)) {\n            return false;\n        }\n    }\n    if (animation.sourceResolution !== animation.targetResolution) {\n        return false;\n    }\n    if (animation.sourceRotation !== animation.targetRotation) {\n        return false;\n    }\n    return true;\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {import(\"./size.js\").Size} size Box pixel size.\n * @param {import(\"./pixel.js\").Pixel} position Position on the view to center on.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {import(\"./coordinate.js\").Coordinate} Shifted center.\n */\nfunction calculateCenterOn(coordinate, size, position, resolution, rotation) {\n    // calculate rotated position\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    rotX += (size[0] / 2 - position[0]) * resolution;\n    rotY += (position[1] - size[1] / 2) * resolution;\n    // go back to original angle\n    sinAngle = -sinAngle; // go back to original rotation\n    var centerX = rotX * cosAngle - rotY * sinAngle;\n    var centerY = rotY * cosAngle + rotX * sinAngle;\n    return [centerX, centerY];\n}\nexport default View;\n//# sourceMappingURL=View.js.map","/**\n * @module ol/TileState\n */\n/**\n * @enum {number}\n */\nexport default {\n    IDLE: 0,\n    LOADING: 1,\n    LOADED: 2,\n    /**\n     * Indicates that tile loading failed\n     * @type {number}\n     */\n    ERROR: 3,\n    EMPTY: 4,\n};\n//# sourceMappingURL=TileState.js.map","/**\n * @module ol/TileRange\n */\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nvar TileRange = /** @class */ (function () {\n    /**\n     * @param {number} minX Minimum X.\n     * @param {number} maxX Maximum X.\n     * @param {number} minY Minimum Y.\n     * @param {number} maxY Maximum Y.\n     */\n    function TileRange(minX, maxX, minY, maxY) {\n        /**\n         * @type {number}\n         */\n        this.minX = minX;\n        /**\n         * @type {number}\n         */\n        this.maxX = maxX;\n        /**\n         * @type {number}\n         */\n        this.minY = minY;\n        /**\n         * @type {number}\n         */\n        this.maxY = maxY;\n    }\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {boolean} Contains tile coordinate.\n     */\n    TileRange.prototype.contains = function (tileCoord) {\n        return this.containsXY(tileCoord[1], tileCoord[2]);\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Contains.\n     */\n    TileRange.prototype.containsTileRange = function (tileRange) {\n        return (this.minX <= tileRange.minX &&\n            tileRange.maxX <= this.maxX &&\n            this.minY <= tileRange.minY &&\n            tileRange.maxY <= this.maxY);\n    };\n    /**\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @return {boolean} Contains coordinate.\n     */\n    TileRange.prototype.containsXY = function (x, y) {\n        return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Equals.\n     */\n    TileRange.prototype.equals = function (tileRange) {\n        return (this.minX == tileRange.minX &&\n            this.minY == tileRange.minY &&\n            this.maxX == tileRange.maxX &&\n            this.maxY == tileRange.maxY);\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     */\n    TileRange.prototype.extend = function (tileRange) {\n        if (tileRange.minX < this.minX) {\n            this.minX = tileRange.minX;\n        }\n        if (tileRange.maxX > this.maxX) {\n            this.maxX = tileRange.maxX;\n        }\n        if (tileRange.minY < this.minY) {\n            this.minY = tileRange.minY;\n        }\n        if (tileRange.maxY > this.maxY) {\n            this.maxY = tileRange.maxY;\n        }\n    };\n    /**\n     * @return {number} Height.\n     */\n    TileRange.prototype.getHeight = function () {\n        return this.maxY - this.minY + 1;\n    };\n    /**\n     * @return {import(\"./size.js\").Size} Size.\n     */\n    TileRange.prototype.getSize = function () {\n        return [this.getWidth(), this.getHeight()];\n    };\n    /**\n     * @return {number} Width.\n     */\n    TileRange.prototype.getWidth = function () {\n        return this.maxX - this.minX + 1;\n    };\n    /**\n     * @param {TileRange} tileRange Tile range.\n     * @return {boolean} Intersects.\n     */\n    TileRange.prototype.intersects = function (tileRange) {\n        return (this.minX <= tileRange.maxX &&\n            this.maxX >= tileRange.minX &&\n            this.minY <= tileRange.maxY &&\n            this.maxY >= tileRange.minY);\n    };\n    return TileRange;\n}());\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n    if (tileRange !== undefined) {\n        tileRange.minX = minX;\n        tileRange.maxX = maxX;\n        tileRange.minY = minY;\n        tileRange.maxY = maxY;\n        return tileRange;\n    }\n    else {\n        return new TileRange(minX, maxX, minY, maxY);\n    }\n}\nexport default TileRange;\n//# sourceMappingURL=TileRange.js.map"],"sourceRoot":""}