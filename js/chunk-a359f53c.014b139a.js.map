{"version":3,"sources":["webpack:///./node_modules/ol/renderer/vector.js","webpack:///./node_modules/ol/renderer/webgl/PointsLayer.js","webpack:///./node_modules/ol/renderer/webgl/Layer.js"],"names":["SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","resolution","pixelRatio","tolerance","getTolerance","builderGroup","geometry","style","feature","opt_declutterBuilderGroup","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","CIRCLE","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","TEXT","setTextStyle","drawText","renderFeature","replayGroup","squaredTolerance","listener","opt_transform","loading","imageStyle","getImage","imageState","getImageState","LOADED","ERROR","unlistenImageChange","IDLE","load","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","getRenderer","renderGeometry","geometryRenderer","getType","GEOMETRY_COLLECTION","replay","DEFAULT","drawCustom","getHitDetectionRenderer","geometries","getGeometries","i","ii","length","getGeometriesArray","lineStringReplay","LINE_STRING","drawLineString","drawMultiLineString","polygonReplay","POLYGON","drawMultiPolygon","declutterImageWithText","undefined","imageReplay","IMAGE","setImageStyle","drawPoint","drawMultiPoint","drawPolygon","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","WebGLPointsLayerRenderer","_super","layer","options","_this","uniforms","projectionMatrixTransform","PROJECTION_MATRIX","postProcesses","ready","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitVertexShader_","hitFragmentShader_","hitProgram_","customAttributes","attributes","map","attribute","name","size","type","FLOAT","concat","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","generateBuffersRun_","worker_","addEventListener","event","received","data","GENERATE_BUFFERS","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","helper","flushBufferData","indexBuffer","renderInstructions","generateBuffersRun","getLayer","changed","bind","featureCache_","featureCount_","source","getSource","sourceListenKeys_","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getGeometry","afterHelperCreated","getProgram","renderFrame","frameState","gl","getGL","preRender","renderCount","getSize","drawElements","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","renderHitDetection","clearCachedData","postRender","prepareFrameInternal","vectorSource","viewState","viewNotMoving","viewHints","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","renderBuffer","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","makeProjectionTransform","useProgram","prepareDraw","bindBuffer","enableAttributes","featureCache","totalInstructionsCount","totalHitInstructionsCount","hitColor","tmpCoords","tmpColor","renderIndex","hitIndex","featureUid","POINT","getFlatCoordinates","Number","value","j","callback","message","buffer","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","pixel","coordinateToPixelTransform","readPixel","color","index","opacity","uid","Math","floor","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","disposeInternal","terminate","layer_","forEach","key","WebGLWorkerMessageType","WebGLLayerRenderer","opt_options","inversePixelTransform_","pixelContext_","postProcesses_","uniforms_","addChangeListener","MAP","removeHelper","context","hasListener","PRECOMPOSE","event_1","dispatchEvent","POSTCOMPOSE","event_2","reset","setUniforms","dispose","prepareFrame","getRenderSource","incrementGroup","groupNumber","className","layerStatesArray","layerClassName","getClassName","canvasCacheKey","mapId","canvasCacheKeyMatches","dispatchRenderEvent_","event_3","PRERENDER","POSTRENDER","getDataAtPixel","renderPixel","layerExtent","getExtent","renderCoordinate","pixelToCoordinateTransform","getContextAttributes","preserveDrawingBuffer","Uint8Array","x","round","y","pixelContext","pixelCanvas","document","createElement","width","height","getContext","clearRect","drawImage","getImageData","err","colorEncodeId","id","opt_array","array","radix","divide","colorDecodeId","mult"],"mappings":"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","file":"js/chunk-a359f53c.014b139a.js","sourcesContent":["/**\n * @module ol/renderer/vector\n */\nimport BuilderType from '../render/canvas/BuilderType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport ImageState from '../ImageState.js';\nimport { getUid } from '../util.js';\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nvar SIMPLIFY_TOLERANCE = 0.5;\n/**\n * @const\n * @type {Object<import(\"../geom/GeometryType.js\").default,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nvar GEOMETRY_RENDERERS = {\n    'Point': renderPointGeometry,\n    'LineString': renderLineStringGeometry,\n    'Polygon': renderPolygonGeometry,\n    'MultiPoint': renderMultiPointGeometry,\n    'MultiLineString': renderMultiLineStringGeometry,\n    'MultiPolygon': renderMultiPolygonGeometry,\n    'GeometryCollection': renderGeometryCollectionGeometry,\n    'Circle': renderCircleGeometry,\n};\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n    return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n    var tolerance = getTolerance(resolution, pixelRatio);\n    return tolerance * tolerance;\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n    return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);\n        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        circleReplay.drawCircle(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {\n    var loading = false;\n    var imageStyle = style.getImage();\n    if (imageStyle) {\n        var imageState = imageStyle.getImageState();\n        if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n            imageStyle.unlistenImageChange(listener);\n        }\n        else {\n            if (imageState == ImageState.IDLE) {\n                imageStyle.load();\n            }\n            imageState = imageStyle.getImageState();\n            imageStyle.listenImageChange(listener);\n            loading = true;\n        }\n    }\n    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);\n    return loading;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry) {\n        return;\n    }\n    var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);\n    var renderer = style.getRenderer();\n    if (renderer) {\n        renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n    }\n    else {\n        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n    if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n        var geometries = \n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            renderGeometry(replayGroup, geometries[i], style, feature);\n        }\n        return;\n    }\n    var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);\n    replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry), feature, style.getRenderer(), style.getHitDetectionRenderer());\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n        geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawMultiLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (strokeStyle || fillStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawMultiPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawMultiPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n//# sourceMappingURL=vector.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.ready = false;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        /**\n         * @private\n         */\n        _this.vertexShader_ = options.vertexShader;\n        /**\n         * @private\n         */\n        _this.fragmentShader_ = options.fragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.program_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        /**\n         * @private\n         */\n        _this.hitVertexShader_ = options.hitVertexShader;\n        /**\n         * @private\n         */\n        _this.hitFragmentShader_ = options.hitFragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.hitProgram_;\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_;\n        /**\n         * Keep track of latest message sent to worker\n         * @type {number}\n         * @private\n         */\n        _this.generateBuffersRun_ = 0;\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                    if (received.generateBuffersRun === this.generateBuffersRun_) {\n                        this.ready = true;\n                    }\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    WebGLPointsLayerRenderer.prototype.afterHelperCreated = function () {\n        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n        if (this.hitDetectionEnabled_) {\n            this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);\n            this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n        }\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        var gl = this.helper.getGL();\n        this.preRender(gl, frameState);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n        var canvas = this.helper.getCanvas();\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(gl, frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        // apply the current projection transform with the invert of the one used to fill buffers\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== GeometryType.POINT) {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        message['generateBuffersRun'] = ++this.generateBuffersRun_;\n        this.ready = false;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { containsCoordinate } from '../../extent.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n         * set before dispatching rendering events.\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        _this.inversePixelTransform_ = createTransform();\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n        _this.pixelContext_ = null;\n        /**\n         * @private\n         */\n        _this.postProcesses_ = options.postProcesses;\n        /**\n         * @private\n         */\n        _this.uniforms_ = options.uniforms;\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper;\n        layer.addChangeListener(LayerProperty.MAP, _this.removeHelper.bind(_this));\n        _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);\n        _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);\n        return _this;\n    }\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPreComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n            var event_1 = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPostComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n            var event_2 = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_2);\n        }\n    };\n    /**\n     * Reset options (only handles uniforms).\n     * @param {Options} options Options.\n     */\n    WebGLLayerRenderer.prototype.reset = function (options) {\n        this.uniforms_ = options.uniforms;\n        if (this.helper) {\n            this.helper.setUniforms(this.uniforms_);\n        }\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.removeHelper = function () {\n        if (this.helper) {\n            this.helper.dispose();\n            delete this.helper;\n        }\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLLayerRenderer.prototype.prepareFrame = function (frameState) {\n        if (this.getLayer().getRenderSource()) {\n            var incrementGroup = true;\n            var groupNumber = -1;\n            var className = void 0;\n            for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n                var layer = frameState.layerStatesArray[i].layer;\n                var renderer = layer.getRenderer();\n                if (!(renderer instanceof WebGLLayerRenderer)) {\n                    incrementGroup = true;\n                    continue;\n                }\n                var layerClassName = layer.getClassName();\n                if (incrementGroup || layerClassName !== className) {\n                    groupNumber += 1;\n                    incrementGroup = false;\n                }\n                className = layerClassName;\n                if (renderer === this) {\n                    break;\n                }\n            }\n            var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;\n            if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n                this.removeHelper();\n                this.helper = new WebGLHelper({\n                    postProcesses: this.postProcesses_,\n                    uniforms: this.uniforms_,\n                    canvasCacheKey: canvasCacheKey,\n                });\n                if (className) {\n                    this.helper.getCanvas().className = className;\n                }\n                this.afterHelperCreated();\n            }\n        }\n        return this.prepareFrameInternal(frameState);\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.afterHelperCreated = function () { };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        return true;\n    };\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.removeHelper();\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            composeTransform(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n            var event_3 = new RenderEvent(type, this.inversePixelTransform_, frameState, context);\n            layer.dispatchEvent(event_3);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n    };\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n     *    location, null will be returned.  If there is data, but pixel values cannot be\n     *    returned, and empty array will be returned.\n     */\n    WebGLLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n        var renderPixel = applyTransform([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());\n        var gl = this.helper.getGL();\n        if (!gl) {\n            return null;\n        }\n        var layer = this.getLayer();\n        var layerExtent = layer.getExtent();\n        if (layerExtent) {\n            var renderCoordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n            /** get only data inside of the layer extent */\n            if (!containsCoordinate(layerExtent, renderCoordinate)) {\n                return null;\n            }\n        }\n        var attributes = gl.getContextAttributes();\n        if (!attributes || !attributes.preserveDrawingBuffer) {\n            // we assume there is data at the given pixel (although there might not be)\n            return new Uint8Array();\n        }\n        var x = Math.round(renderPixel[0]);\n        var y = Math.round(renderPixel[1]);\n        var pixelContext = this.pixelContext_;\n        if (!pixelContext) {\n            var pixelCanvas = document.createElement('canvas');\n            pixelCanvas.width = 1;\n            pixelCanvas.height = 1;\n            pixelContext = pixelCanvas.getContext('2d');\n            this.pixelContext_ = pixelContext;\n        }\n        pixelContext.clearRect(0, 0, 1, 1);\n        var data;\n        try {\n            pixelContext.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);\n            data = pixelContext.getImageData(0, 0, 1, 1).data;\n        }\n        catch (err) {\n            return data;\n        }\n        if (data[3] === 0) {\n            return null;\n        }\n        return data;\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map"],"sourceRoot":""}