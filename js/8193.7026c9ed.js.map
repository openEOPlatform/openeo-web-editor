{"version":3,"file":"js/8193.7026c9ed.js","mappings":"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","sources":["webpack://@openeo/web-editor/./node_modules/geotiff/node_modules/lru-cache/index.js","webpack://@openeo/web-editor/./node_modules/geotiff/node_modules/yallist/iterator.js","webpack://@openeo/web-editor/./node_modules/geotiff/node_modules/yallist/yallist.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/compression/index.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/dataview64.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/dataslice.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/httputils.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/basesource.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/utils.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/blockedsource.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/base.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/fetch.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/xhr.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/client/http.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/remote.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/source/filereader.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/geotiff.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/rgb.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/resample.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/geotiffimage.js","webpack://@openeo/web-editor/./node_modules/geotiff/dist-module/globals.js"],"sourcesContent":["'use strict'\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = require('yallist')\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js').then((m) => m.default));\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import LRUCache from 'lru-cache';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new LRUCache({ max: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const cachedBlocks = new Map();\n    const blockRequests = new Map();\n    const missingBlockIds = new Set();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      // chunk the current slice into blocks\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        // check if the block is cached, being requested or still missing\n        const blockId = Math.floor(current / this.blockSize);\n\n        if (this.blockCache.has(blockId)) {\n          cachedBlocks.set(blockId, this.blockCache.get(blockId));\n        } else if (this.blockRequests.has(blockId)) {\n          blockRequests.set(blockId, this.blockRequests.get(blockId));\n        } else if (this.blockIdsToFetch.has(blockId)) {\n          missingBlockIds.add(blockId);\n        } else {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.add(blockId);\n        }\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    for (const blockId of missingBlockIds) {\n      const block = this.blockRequests.get(blockId);\n      const cachedBlock = this.blockCache.get(blockId);\n\n      if (block) {\n        blockRequests.set(blockId, block);\n      } else if (cachedBlock) {\n        cachedBlocks.set(blockId, cachedBlock);\n      } else {\n        throw new Error(`Block ${blockId} is not in the block requests`);\n      }\n    }\n\n    // actually await all pending requests\n    let results = await Promise.allSettled(Array.from(blockRequests.values()));\n\n    // perform retries if a block was interrupted by a previous signal\n    if (results.some((result) => result.status === 'rejected')) {\n      const retriedBlockRequests = new Set();\n      for (const [blockId, result] of zip(blockRequests.keys(), results)) {\n        const { rejected, reason } = result;\n        if (rejected) {\n          // push some blocks back to the to-fetch list if they were\n          // aborted, but only when a different signal was used\n          if (reason.name === 'AbortError' && reason.signal !== signal) {\n            this.blockIdsToFetch.add(blockId);\n            retriedBlockRequests.add(blockId);\n          }\n        }\n      }\n\n      // start the retry of some blocks if required\n      if (this.blockIdsToFetch.length > 0) {\n        this.fetchBlocks(signal);\n        for (const blockId of retriedBlockRequests) {\n          const block = this.blockRequests.get(blockId);\n          if (!block) {\n            throw new Error(`Block ${blockId} is not in the block requests`);\n          }\n          blockRequests.set(blockId, block);\n        }\n        results = await Promise.allSettled(Array.from(blockRequests.values()));\n      }\n    }\n\n    // throw an error (either abort error or AggregateError if no abort was done)\n    if (results.some((result) => result.status === 'rejected')) {\n      if (signal && signal.aborted) {\n        throw new AbortError('Request was aborted');\n      }\n      throw new AggregateError(\n        results.filter((result) => result.status === 'rejected').map((result) => result.reason),\n        'Request failed',\n      );\n    }\n\n    // extract the actual block responses\n    const values = results.map((result) => result.value);\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));\n    for (const [blockId, block] of cachedBlocks) {\n      requiredBlocks.set(blockId, block);\n    }\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          const blockRequest = (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n              );\n              this.blockCache.set(blockId, block);\n              return block;\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n              }\n              throw err;\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })();\n          this.blockRequests.set(blockId, blockRequest);\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      const top = slice.offset + slice.length;\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {object} [options]\n   */\n  async request({ headers, credentials, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  async request({ headers, credentials, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          promises.push(promise);\n          promise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n"],"names":["Yallist","MAX","Symbol","LENGTH","LENGTH_CALCULATOR","ALLOW_STALE","MAX_AGE","DISPOSE","NO_DISPOSE_ON_SET","LRU_LIST","CACHE","UPDATE_AGE_ON_GET","naiveLength","LRUCache","constructor","options","max","TypeError","this","Infinity","lc","length","stale","maxAge","dispose","noDisposeOnSet","updateAgeOnGet","reset","mL","trim","allowStale","mA","lengthCalculator","lC","forEach","hit","value","key","itemCount","rforEach","fn","thisp","walker","tail","prev","forEachStep","head","next","keys","toArray","map","k","values","Map","dump","isStale","v","e","now","filter","h","dumpLru","set","Date","len","has","del","get","node","item","Entry","unshift","peek","pop","load","arr","l","expiresAt","prune","self","doUse","unshiftNode","diff","delete","removeNode","undefined","call","module","exports","prototype","iterator","list","push","arguments","i","insert","inserted","Node","create","Error","pushNode","res","shift","forEachReverse","n","getReverse","mapReverse","reduce","initial","acc","reduceReverse","Array","toArrayReverse","slice","from","to","ret","sliceReverse","splice","start","deleteCount","nodes","reverse","p","er","registry","addDecoder","cases","importFn","isArray","c","async","getDecoder","fileDirectory","Compression","Decoder","then","m","default","DataView64","arrayBuffer","_dataView","DataView","buffer","getUint64","offset","littleEndian","left","getUint32","right","combined","Number","isSafeInteger","getInt64","isNegative","getUint8","carrying","byte","getInt8","getUint16","getInt16","getInt32","getFloat16","g","getFloat32","getFloat64","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","sliceTop","byteLength","covers","readUint8","readInt8","readUint16","readInt16","readUint32","readInt32","readFloat32","readFloat64","readUint64","readInt64","readOffset","CRLFCRLF","itemsToObject","items","Object","fromEntries","obj","toLowerCase","parseHeaders","text","split","line","kv","str","parseContentType","rawContentType","type","rawParams","s","paramsItems","param","params","parseContentRange","rawContentRange","end","total","match","parseInt","parseByteRanges","responseArrayBuffer","boundary","decoder","TextDecoder","out","startBoundary","endBoundary","decode","Uint8Array","Math","min","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","data","fileSize","BaseSource","slices","signal","Promise","all","fetchSlice","wait","milliseconds","resolve","setTimeout","zip","a","b","A","B","AbortError","super","captureStackTrace","name","CustomAggregateError","errors","message","AggregateError","Block","top","BlockGroup","blockIds","BlockedSource","source","blockSize","cacheSize","blockCache","blockRequests","blockIdsToFetch","Set","cachedBlocks","missingBlockIds","firstBlockOffset","floor","current","blockId","add","fetchBlocks","block","cachedBlock","results","allSettled","some","result","status","retriedBlockRequests","rejected","reason","aborted","requiredBlocks","readSliceData","size","groups","groupBlocks","groupRequests","fetch","groupIndex","group","blockRequest","response","blockOffset","o","t","err","clear","sortedBlockIds","sort","lastBlockId","blocks","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","delta","topDelta","usedBlockLength","blockInnerOffset","rangeInnerOffset","blockView","BaseResponse","ok","getHeader","headerName","BaseClient","url","credentials","FetchResponse","FetchClient","XHRResponse","xhr","getResponseHeader","XHRClient","constructRequest","reject","XMLHttpRequest","open","responseType","entries","setRequestHeader","onload","onerror","onabort","send","abort","addEventListener","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","httpApi","protocol","request","resolveData","chunks","on","chunk","Buffer","concat","destroy","RemoteSource","client","maxRanges","allowFullFile","_fileSize","fetchSlices","Range","join","byteRanges","getData","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","FileReaderSource","file","blob","reader","FileReader","event","target","readAsArrayBuffer","makeFileReaderSource","getFieldTypeLength","fieldType","RangeError","parseGeoKeyDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","location","count","substring","subarray","getValues","dataSlice","readMethod","fieldTypeLength","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","index","GeoTIFFBase","window","imageWindow","width","height","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","getBoundingBox","oX","oY","getOrigin","rX","rY","getResolution","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","getWidth","imgResX","imgResY","getHeight","wnd","imageResX","imageResY","round","readRasters","GeoTIFF","firstIFDOffset","cache","ifdRequests","ghostValues","fallbackSize","entrySize","offsetSize","getSlice","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","parseFileDirectoryAt","requestIFD","previousIfd","ifd","dataView","hasNext","detectionString","heuristicAreaSize","valuesString","firstLine","metadataSize","fullString","static","headerData","BOM","magicNumber","offsetByteSize","close","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","requests","parseFileDirectoriesPerFile","visited","relativeIndex","imageFile","ii","imageCounts","ifds","fromUrl","fromSource","fromBlob","fromUrls","mainUrl","overviewUrls","fromWhiteIsZero","raster","rgbRaster","j","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","y","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","r","x","z","copyNewSize","array","samplesPerPixel","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","cx","lerp","v0","v1","resampleBilinear","rawY","yl","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","arrayForType","format","bitsPerSample","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","outSize","samplesToTransfer","outArray","bitMask","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","byteOffset","innerBitOffset","raw","GeoTIFFImage","geoKeys","tiles","isTiled","StripOffsets","PlanarConfiguration","getFileDirectory","getGeoKeys","ImageWidth","ImageLength","getSamplesPerPixel","SamplesPerPixel","getTileWidth","TileWidth","getTileHeight","TileLength","RowsPerStrip","getBlockWidth","getBlockHeight","getBytesPerPixel","bytes","BitsPerSample","getSampleByteSize","getReaderForSample","sampleIndex","SampleFormat","getSampleFormat","getBitsPerSample","getArrayForSample","sample","poolOrDecoder","numTilesPerRow","numTilesPerCol","byteCount","TileOffsets","TileByteCounts","StripByteCounts","sampleFormat","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","si","promise","getTileOrStrip","tile","blockHeight","firstCol","lastLine","lastCol","ymax","xmax","pixelOffset","windowCoordinate","resampled","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","apply","fill","_readRaster","enableAlpha","pi","PhotometricInterpretation","ExtraSamples","subOptions","ColorMap","red","green","blue","getTiePoints","ModelTiepoint","tiePoints","getGDALMetadata","metadata","GDAL_METADATA","string","inner","getGDALNoData","GDAL_NODATA","modelTransformation","ModelTransformation","referenceImage","modelPixelScale","ModelPixelScale","refResX","refResY","refResZ","pixelIsArea","GTRasterTypeGeoKey","origin","resolution","x1","y1","x2","y2","fieldTagNames","fieldTags","hasOwnProperty","arrayFields","StripRowCounts","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","WhiteIsZero","BlackIsZero","RGB","Palette","TransparencyMask","CMYK","YCbCr","CIELab","ICCLab","ExtraSamplesValues","Unspecified","Assocalpha","Unassalpha","LercParameters","Version","AddCompression","LercAddCompression","None","Deflate","geoKeyNames"],"sourceRoot":""}