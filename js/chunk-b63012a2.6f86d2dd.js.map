{"version":3,"sources":["webpack:///./node_modules/ol/renderer/vector.js","webpack:///./node_modules/ol/renderer/webgl/Layer.js","webpack:///./node_modules/ol/renderer/webgl/PointsLayer.js"],"names":["SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","resolution","pixelRatio","tolerance","getTolerance","builderGroup","geometry","style","feature","opt_declutterBuilderGroup","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","CIRCLE","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","TEXT","setTextStyle","drawText","renderFeature","replayGroup","squaredTolerance","listener","opt_transform","loading","imageStyle","getImage","imageState","getImageState","LOADED","ERROR","unlistenImageChange","IDLE","load","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","getRenderer","renderGeometry","geometryRenderer","getType","GEOMETRY_COLLECTION","replay","DEFAULT","drawCustom","getHitDetectionRenderer","geometries","getGeometries","i","ii","length","getGeometriesArray","lineStringReplay","LINE_STRING","drawLineString","drawMultiLineString","polygonReplay","POLYGON","drawMultiPolygon","declutterImageWithText","undefined","imageReplay","IMAGE","setImageStyle","drawPoint","drawMultiPoint","drawPolygon","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","WebGLWorkerMessageType","GENERATE_BUFFERS","_super","WebGLLayerRenderer","layer","opt_options","_this","options","inversePixelTransform_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","MAP","removeHelper_","bind","dispatchPreComposeEvent","dispatchPostComposeEvent","context","frameState","getLayer","hasListener","PRECOMPOSE","event_1","dispatchEvent","POSTCOMPOSE","event_2","reset","setUniforms","dispose","prepareFrame","getSource","incrementGroup","groupNumber","className","layerStatesArray","layerClassName","getClassName","canvasCacheKey","mapId","canvasCacheKeyMatches","getCanvas","afterHelperCreated","prepareFrameInternal","disposeInternal","dispatchRenderEvent_","type","size","event_3","preRender","PRERENDER","postRender","POSTRENDER","Layer","colorEncodeId","id","opt_array","array","radix","divide","Math","floor","colorDecodeId","color","mult","round","WebGLPointsLayerRenderer","projectionMatrixTransform","PROJECTION_MATRIX","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitVertexShader_","hitFragmentShader_","hitProgram_","customAttributes","attributes","map","attribute","name","FLOAT","concat","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","worker_","addEventListener","event","received","data","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","changed","featureCache_","featureCount_","source","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getGeometry","getProgram","renderFrame","gl","getGL","renderCount","getSize","drawElements","finalizeDraw","canvas","renderHitDetection","clearCachedData","vectorSource","viewState","viewNotMoving","viewHints","ViewHint","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","makeProjectionTransform","useProgram","prepareDraw","bindBuffer","enableAttributes","featureCache","totalInstructionsCount","totalHitInstructionsCount","hitColor","tmpCoords","tmpColor","renderIndex","hitIndex","featureUid","GeometryType","POINT","getFlatCoordinates","Number","value","j","callback","message","buffer","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","pixel","coordinateToPixelTransform","readPixel","index","opacity","uid","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","terminate","layer_","forEach","key"],"mappings":"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","file":"js/chunk-b63012a2.6f86d2dd.js","sourcesContent":["/**\n * @module ol/renderer/vector\n */\nimport BuilderType from '../render/canvas/BuilderType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport ImageState from '../ImageState.js';\nimport { getUid } from '../util.js';\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature feature} or {@link module:ol/render/Feature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nvar SIMPLIFY_TOLERANCE = 0.5;\n/**\n * @const\n * @type {Object<import(\"../geom/GeometryType.js\").default,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nvar GEOMETRY_RENDERERS = {\n    'Point': renderPointGeometry,\n    'LineString': renderLineStringGeometry,\n    'Polygon': renderPolygonGeometry,\n    'MultiPoint': renderMultiPointGeometry,\n    'MultiLineString': renderMultiLineStringGeometry,\n    'MultiPolygon': renderMultiPolygonGeometry,\n    'GeometryCollection': renderGeometryCollectionGeometry,\n    'Circle': renderCircleGeometry,\n};\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n    return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n    var tolerance = getTolerance(resolution, pixelRatio);\n    return tolerance * tolerance;\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n    return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);\n        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        circleReplay.drawCircle(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {\n    var loading = false;\n    var imageStyle = style.getImage();\n    if (imageStyle) {\n        var imageState = imageStyle.getImageState();\n        if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n            imageStyle.unlistenImageChange(listener);\n        }\n        else {\n            if (imageState == ImageState.IDLE) {\n                imageStyle.load();\n            }\n            imageState = imageStyle.getImageState();\n            imageStyle.listenImageChange(listener);\n            loading = true;\n        }\n    }\n    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);\n    return loading;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry) {\n        return;\n    }\n    var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);\n    var renderer = style.getRenderer();\n    if (renderer) {\n        renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n    }\n    else {\n        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n    if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n        var geometries = \n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            renderGeometry(replayGroup, geometries[i], style, feature);\n        }\n        return;\n    }\n    var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);\n    replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry), feature, style.getRenderer(), style.getHitDetectionRenderer());\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n        geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawMultiLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (strokeStyle || fillStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawMultiPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawMultiPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n//# sourceMappingURL=vector.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport { compose as composeTransform, create as createTransform, } from '../../transform.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n         * set before dispatching rendering events.\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        _this.inversePixelTransform_ = createTransform();\n        /**\n         * @private\n         */\n        _this.postProcesses_ = options.postProcesses;\n        /**\n         * @private\n         */\n        _this.uniforms_ = options.uniforms;\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper;\n        layer.addChangeListener(LayerProperty.MAP, _this.removeHelper_.bind(_this));\n        _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);\n        _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);\n        return _this;\n    }\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPreComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n            var event_1 = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPostComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n            var event_2 = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_2);\n        }\n    };\n    /**\n     * Reset options (only handles uniforms).\n     * @param {Options} options Options.\n     */\n    WebGLLayerRenderer.prototype.reset = function (options) {\n        this.uniforms_ = options.uniforms;\n        if (this.helper) {\n            this.helper.setUniforms(this.uniforms_);\n        }\n    };\n    WebGLLayerRenderer.prototype.removeHelper_ = function () {\n        if (this.helper) {\n            this.helper.dispose();\n            delete this.helper;\n        }\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLLayerRenderer.prototype.prepareFrame = function (frameState) {\n        if (this.getLayer().getSource()) {\n            var incrementGroup = true;\n            var groupNumber = -1;\n            var className = void 0;\n            for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n                var layer = frameState.layerStatesArray[i].layer;\n                var renderer = layer.getRenderer();\n                if (!(renderer instanceof WebGLLayerRenderer)) {\n                    incrementGroup = true;\n                    continue;\n                }\n                var layerClassName = layer.getClassName();\n                if (incrementGroup || layerClassName !== className) {\n                    groupNumber += 1;\n                    incrementGroup = false;\n                }\n                className = layerClassName;\n                if (renderer === this) {\n                    break;\n                }\n            }\n            var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;\n            if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n                if (this.helper) {\n                    this.helper.dispose();\n                }\n                this.helper = new WebGLHelper({\n                    postProcesses: this.postProcesses_,\n                    uniforms: this.uniforms_,\n                    canvasCacheKey: canvasCacheKey,\n                });\n                if (className) {\n                    this.helper.getCanvas().className = className;\n                }\n                this.afterHelperCreated();\n            }\n        }\n        return this.prepareFrameInternal(frameState);\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.afterHelperCreated = function () { };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        return true;\n    };\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.removeHelper_();\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            composeTransform(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n            var event_3 = new RenderEvent(type, this.inversePixelTransform_, frameState, context);\n            layer.dispatchEvent(event_3);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        /**\n         * @private\n         */\n        _this.vertexShader_ = options.vertexShader;\n        /**\n         * @private\n         */\n        _this.fragmentShader_ = options.fragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.program_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        /**\n         * @private\n         */\n        _this.hitVertexShader_ = options.hitVertexShader;\n        /**\n         * @private\n         */\n        _this.hitFragmentShader_ = options.hitFragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.hitProgram_;\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_;\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    WebGLPointsLayerRenderer.prototype.afterHelperCreated = function () {\n        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n        if (this.hitDetectionEnabled_) {\n            this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);\n            this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n        }\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        var gl = this.helper.getGL();\n        this.preRender(gl, frameState);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n        var canvas = this.helper.getCanvas();\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(gl, frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        // apply the current projection transform with the invert of the one used to fill buffers\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== GeometryType.POINT) {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map"],"sourceRoot":""}