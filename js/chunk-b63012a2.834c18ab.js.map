{"version":3,"sources":["webpack:///./node_modules/ol/renderer/vector.js","webpack:///./node_modules/ol/renderer/webgl/Layer.js","webpack:///./node_modules/ol/renderer/webgl/PointsLayer.js"],"names":["SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","resolution","pixelRatio","tolerance","getTolerance","builderGroup","geometry","style","feature","opt_declutterBuilderGroup","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","CIRCLE","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","TEXT","setTextStyle","drawText","renderFeature","replayGroup","squaredTolerance","listener","opt_transform","loading","imageStyle","getImage","imageState","getImageState","LOADED","ERROR","unlistenImageChange","IDLE","load","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","getRenderer","renderGeometry","geometryRenderer","getType","GEOMETRY_COLLECTION","replay","DEFAULT","drawCustom","getHitDetectionRenderer","geometries","getGeometries","i","ii","length","getGeometriesArray","lineStringReplay","LINE_STRING","drawLineString","drawMultiLineString","polygonReplay","POLYGON","drawMultiPolygon","declutterImageWithText","undefined","imageReplay","IMAGE","setImageStyle","drawPoint","drawMultiPoint","drawPolygon","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","WebGLWorkerMessageType","GENERATE_BUFFERS","_super","WebGLLayerRenderer","layer","opt_options","_this","options","inversePixelTransform_","pixelContext_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","MAP","removeHelper","bind","dispatchPreComposeEvent","dispatchPostComposeEvent","context","frameState","getLayer","hasListener","PRECOMPOSE","event_1","dispatchEvent","POSTCOMPOSE","event_2","reset","setUniforms","dispose","prepareFrame","getRenderSource","incrementGroup","groupNumber","className","layerStatesArray","layerClassName","getClassName","canvasCacheKey","mapId","canvasCacheKeyMatches","getCanvas","afterHelperCreated","prepareFrameInternal","disposeInternal","dispatchRenderEvent_","type","size","event_3","preRender","PRERENDER","postRender","POSTRENDER","getDataAtPixel","pixel","hitTolerance","renderPixel","slice","gl","getGL","layerExtent","getExtent","renderCoordinate","pixelToCoordinateTransform","attributes","getContextAttributes","preserveDrawingBuffer","Uint8Array","data","x","Math","round","y","pixelContext","pixelCanvas","document","createElement","width","height","getContext","clearRect","drawImage","canvas","getImageData","err","Layer","colorEncodeId","id","opt_array","array","radix","divide","floor","colorDecodeId","color","mult","WebGLPointsLayerRenderer","projectionMatrixTransform","PROJECTION_MATRIX","ready","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","program_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitVertexShader_","hitFragmentShader_","hitProgram_","customAttributes","map","attribute","name","FLOAT","concat","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","generateBuffersRun_","worker_","addEventListener","event","received","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","generateBuffersRun","changed","featureCache_","featureCount_","source","getSource","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getGeometry","getProgram","renderFrame","renderCount","getSize","drawElements","finalizeDraw","renderHitDetection","clearCachedData","vectorSource","viewState","viewNotMoving","viewHints","ViewHint","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","rebuildBuffers_","makeProjectionTransform","useProgram","prepareDraw","bindBuffer","enableAttributes","featureCache","totalInstructionsCount","totalHitInstructionsCount","hitColor","tmpCoords","tmpColor","renderIndex","hitIndex","featureUid","GeometryType","POINT","getFlatCoordinates","Number","value","j","callback","message","buffer","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","matches","coordinateToPixelTransform","readPixel","index","opacity","uid","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","terminate","layer_","forEach","key"],"mappings":"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","file":"js/chunk-b63012a2.834c18ab.js","sourcesContent":["/**\n * @module ol/renderer/vector\n */\nimport BuilderType from '../render/canvas/BuilderType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport ImageState from '../ImageState.js';\nimport { getUid } from '../util.js';\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nvar SIMPLIFY_TOLERANCE = 0.5;\n/**\n * @const\n * @type {Object<import(\"../geom/GeometryType.js\").default,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nvar GEOMETRY_RENDERERS = {\n    'Point': renderPointGeometry,\n    'LineString': renderLineStringGeometry,\n    'Polygon': renderPolygonGeometry,\n    'MultiPoint': renderMultiPointGeometry,\n    'MultiLineString': renderMultiLineStringGeometry,\n    'MultiPolygon': renderMultiPolygonGeometry,\n    'GeometryCollection': renderGeometryCollectionGeometry,\n    'Circle': renderCircleGeometry,\n};\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n    return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n    var tolerance = getTolerance(resolution, pixelRatio);\n    return tolerance * tolerance;\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n    return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);\n        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        circleReplay.drawCircle(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {\n    var loading = false;\n    var imageStyle = style.getImage();\n    if (imageStyle) {\n        var imageState = imageStyle.getImageState();\n        if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n            imageStyle.unlistenImageChange(listener);\n        }\n        else {\n            if (imageState == ImageState.IDLE) {\n                imageStyle.load();\n            }\n            imageState = imageStyle.getImageState();\n            imageStyle.listenImageChange(listener);\n            loading = true;\n        }\n    }\n    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);\n    return loading;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry) {\n        return;\n    }\n    var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);\n    var renderer = style.getRenderer();\n    if (renderer) {\n        renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n    }\n    else {\n        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n    if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n        var geometries = \n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            renderGeometry(replayGroup, geometries[i], style, feature);\n        }\n        return;\n    }\n    var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);\n    replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry), feature, style.getRenderer(), style.getHitDetectionRenderer());\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n        geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawMultiLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (strokeStyle || fillStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawMultiPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawMultiPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n//# sourceMappingURL=vector.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { containsCoordinate } from '../../extent.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n         * set before dispatching rendering events.\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        _this.inversePixelTransform_ = createTransform();\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n        _this.pixelContext_ = null;\n        /**\n         * @private\n         */\n        _this.postProcesses_ = options.postProcesses;\n        /**\n         * @private\n         */\n        _this.uniforms_ = options.uniforms;\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper;\n        layer.addChangeListener(LayerProperty.MAP, _this.removeHelper.bind(_this));\n        _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);\n        _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);\n        return _this;\n    }\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPreComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n            var event_1 = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPostComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n            var event_2 = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_2);\n        }\n    };\n    /**\n     * Reset options (only handles uniforms).\n     * @param {Options} options Options.\n     */\n    WebGLLayerRenderer.prototype.reset = function (options) {\n        this.uniforms_ = options.uniforms;\n        if (this.helper) {\n            this.helper.setUniforms(this.uniforms_);\n        }\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.removeHelper = function () {\n        if (this.helper) {\n            this.helper.dispose();\n            delete this.helper;\n        }\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLLayerRenderer.prototype.prepareFrame = function (frameState) {\n        if (this.getLayer().getRenderSource()) {\n            var incrementGroup = true;\n            var groupNumber = -1;\n            var className = void 0;\n            for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n                var layer = frameState.layerStatesArray[i].layer;\n                var renderer = layer.getRenderer();\n                if (!(renderer instanceof WebGLLayerRenderer)) {\n                    incrementGroup = true;\n                    continue;\n                }\n                var layerClassName = layer.getClassName();\n                if (incrementGroup || layerClassName !== className) {\n                    groupNumber += 1;\n                    incrementGroup = false;\n                }\n                className = layerClassName;\n                if (renderer === this) {\n                    break;\n                }\n            }\n            var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;\n            if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n                this.removeHelper();\n                this.helper = new WebGLHelper({\n                    postProcesses: this.postProcesses_,\n                    uniforms: this.uniforms_,\n                    canvasCacheKey: canvasCacheKey,\n                });\n                if (className) {\n                    this.helper.getCanvas().className = className;\n                }\n                this.afterHelperCreated();\n            }\n        }\n        return this.prepareFrameInternal(frameState);\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.afterHelperCreated = function () { };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        return true;\n    };\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.removeHelper();\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            composeTransform(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n            var event_3 = new RenderEvent(type, this.inversePixelTransform_, frameState, context);\n            layer.dispatchEvent(event_3);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n    };\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n     *    location, null will be returned.  If there is data, but pixel values cannot be\n     *    returned, and empty array will be returned.\n     */\n    WebGLLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n        var renderPixel = applyTransform([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());\n        var gl = this.helper.getGL();\n        if (!gl) {\n            return null;\n        }\n        var layer = this.getLayer();\n        var layerExtent = layer.getExtent();\n        if (layerExtent) {\n            var renderCoordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n            /** get only data inside of the layer extent */\n            if (!containsCoordinate(layerExtent, renderCoordinate)) {\n                return null;\n            }\n        }\n        var attributes = gl.getContextAttributes();\n        if (!attributes || !attributes.preserveDrawingBuffer) {\n            // we assume there is data at the given pixel (although there might not be)\n            return new Uint8Array();\n        }\n        var x = Math.round(renderPixel[0]);\n        var y = Math.round(renderPixel[1]);\n        var pixelContext = this.pixelContext_;\n        if (!pixelContext) {\n            var pixelCanvas = document.createElement('canvas');\n            pixelCanvas.width = 1;\n            pixelCanvas.height = 1;\n            pixelContext = pixelCanvas.getContext('2d');\n            this.pixelContext_ = pixelContext;\n        }\n        pixelContext.clearRect(0, 0, 1, 1);\n        var data;\n        try {\n            pixelContext.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);\n            data = pixelContext.getImageData(0, 0, 1, 1).data;\n        }\n        catch (err) {\n            return data;\n        }\n        if (data[3] === 0) {\n            return null;\n        }\n        return data;\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.ready = false;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        /**\n         * @private\n         */\n        _this.vertexShader_ = options.vertexShader;\n        /**\n         * @private\n         */\n        _this.fragmentShader_ = options.fragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.program_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        /**\n         * @private\n         */\n        _this.hitVertexShader_ = options.hitVertexShader;\n        /**\n         * @private\n         */\n        _this.hitFragmentShader_ = options.hitFragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.hitProgram_;\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_;\n        /**\n         * Keep track of latest message sent to worker\n         * @type {number}\n         * @private\n         */\n        _this.generateBuffersRun_ = 0;\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                    if (received.generateBuffersRun === this.generateBuffersRun_) {\n                        this.ready = true;\n                    }\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    WebGLPointsLayerRenderer.prototype.afterHelperCreated = function () {\n        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n        if (this.hitDetectionEnabled_) {\n            this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);\n            this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n        }\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        var gl = this.helper.getGL();\n        this.preRender(gl, frameState);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n        var canvas = this.helper.getCanvas();\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(gl, frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        // apply the current projection transform with the invert of the one used to fill buffers\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== GeometryType.POINT) {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        message['generateBuffersRun'] = ++this.generateBuffersRun_;\n        this.ready = false;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map"],"sourceRoot":""}