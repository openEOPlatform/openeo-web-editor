{"version":3,"sources":["webpack:///./node_modules/ol/renderer/vector.js","webpack:///./node_modules/ol/renderer/webgl/Layer.js","webpack:///./node_modules/ol/renderer/webgl/PointsLayer.js"],"names":["SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","resolution","pixelRatio","tolerance","getTolerance","builderGroup","geometry","style","feature","opt_declutterBuilderGroup","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","CIRCLE","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","TEXT","setTextStyle","drawText","renderFeature","replayGroup","squaredTolerance","listener","opt_transform","loading","imageStyle","getImage","imageState","getImageState","LOADED","ERROR","unlistenImageChange","IDLE","load","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","getRenderer","renderGeometry","geometryRenderer","getType","GEOMETRY_COLLECTION","replay","DEFAULT","drawCustom","geometries","getGeometries","i","ii","length","getGeometriesArray","lineStringReplay","LINE_STRING","drawLineString","drawMultiLineString","polygonReplay","POLYGON","drawMultiPolygon","declutterImageWithText","undefined","imageReplay","IMAGE","setImageStyle","drawPoint","drawMultiPoint","drawPolygon","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","WebGLWorkerMessageType","GENERATE_BUFFERS","_super","WebGLLayerRenderer","layer","opt_options","_this","options","helper","postProcesses","uniforms","className","getCanvas","disposeInternal","dispose","dispatchRenderEvent_","type","frameState","getLayer","hasListener","event_1","dispatchEvent","preRender","PRERENDER","postRender","POSTRENDER","Layer","colorEncodeId","id","opt_array","array","radix","divide","Math","floor","colorDecodeId","color","mult","round","WebGLPointsLayerRenderer","projectionMatrixTransform","PROJECTION_MATRIX","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","program_","getProgram","fragmentShader","vertexShader","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitProgram_","customAttributes","attributes","map","attribute","name","size","FLOAT","concat","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","worker_","addEventListener","event","received","data","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","renderInstructions","changed","bind","featureCache_","featureCount_","source","getSource","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getGeometry","renderFrame","renderCount","getSize","drawElements","finalizeDraw","canvas","layerState","layerStatesArray","layerIndex","opacity","parseFloat","renderHitDetection","clearCachedData","prepareFrame","vectorSource","viewState","viewNotMoving","viewHints","ViewHint","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","makeProjectionTransform","useProgram","prepareDraw","bindBuffer","enableAttributes","featureCache","totalInstructionsCount","totalHitInstructionsCount","hitColor","tmpCoords","tmpColor","renderIndex","hitIndex","featureUid","GeometryType","POINT","getFlatCoordinates","Number","value","j","callback","message","buffer","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","pixel","coordinateToPixelTransform","readPixel","index","uid","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","terminate","layer_","forEach","key"],"mappings":"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","file":"js/chunk-b63012a2.35cd3e90.js","sourcesContent":["/**\n * @module ol/renderer/vector\n */\nimport BuilderType from '../render/canvas/BuilderType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport ImageState from '../ImageState.js';\nimport { getUid } from '../util.js';\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature feature} or {@link module:ol/render/Feature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nvar SIMPLIFY_TOLERANCE = 0.5;\n/**\n * @const\n * @type {Object<import(\"../geom/GeometryType.js\").default,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nvar GEOMETRY_RENDERERS = {\n    'Point': renderPointGeometry,\n    'LineString': renderLineStringGeometry,\n    'Polygon': renderPolygonGeometry,\n    'MultiPoint': renderMultiPointGeometry,\n    'MultiLineString': renderMultiLineStringGeometry,\n    'MultiPolygon': renderMultiPolygonGeometry,\n    'GeometryCollection': renderGeometryCollectionGeometry,\n    'Circle': renderCircleGeometry,\n};\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n    return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n    var tolerance = getTolerance(resolution, pixelRatio);\n    return tolerance * tolerance;\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n    return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);\n        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        circleReplay.drawCircle(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {\n    var loading = false;\n    var imageStyle = style.getImage();\n    if (imageStyle) {\n        var imageState = imageStyle.getImageState();\n        if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n            imageStyle.unlistenImageChange(listener);\n        }\n        else {\n            if (imageState == ImageState.IDLE) {\n                imageStyle.load();\n            }\n            imageState = imageStyle.getImageState();\n            imageStyle.listenImageChange(listener);\n            loading = true;\n        }\n    }\n    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);\n    return loading;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry) {\n        return;\n    }\n    var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);\n    var renderer = style.getRenderer();\n    if (renderer) {\n        renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n    }\n    else {\n        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n    if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n        var geometries = \n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            renderGeometry(replayGroup, geometries[i], style, feature);\n        }\n        return;\n    }\n    var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);\n    replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry), feature, style.getRenderer());\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n        geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawMultiLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (strokeStyle || fillStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawMultiPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawMultiPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n//# sourceMappingURL=vector.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper = new WebGLHelper({\n            postProcesses: options.postProcesses,\n            uniforms: options.uniforms,\n        });\n        if (options.className !== undefined) {\n            _this.helper.getCanvas().className = options.className;\n        }\n        return _this;\n    }\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.helper.dispose();\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            // RenderEvent does not get a context or an inversePixelTransform, because WebGL allows much less direct editing than Canvas2d does.\n            var event_1 = new RenderEvent(type, null, frameState, null);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, frameState);\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, frameState);\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            className: options.className,\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        _this.hitProgram_ =\n            _this.hitDetectionEnabled_ &&\n                _this.helper.getProgram(options.hitFragmentShader, options.hitVertexShader);\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_ =\n            _this.hitDetectionEnabled_ && new WebGLRenderTarget(_this.helper);\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        this.preRender(frameState);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n        this.helper.finalizeDraw(frameState);\n        var canvas = this.helper.getCanvas();\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var opacity = layerState.opacity;\n        if (opacity !== parseFloat(canvas.style.opacity)) {\n            canvas.style.opacity = String(opacity);\n        }\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrame = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        // apply the current projection transform with the invert of the one used to fill buffers\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== GeometryType.POINT) {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map"],"sourceRoot":""}