{"version":3,"sources":["webpack:///./node_modules/geotiff/dist-module/rgb.js","webpack:///./node_modules/geotiff/dist-module/resample.js","webpack:///./node_modules/geotiff/dist-module/geotiffimage.js","webpack:///./node_modules/geotiff/dist-module/dataview64.js","webpack:///./node_modules/geotiff/dist-module/dataslice.js","webpack:///./node_modules/geotiff/dist-module/source/httputils.js","webpack:///./node_modules/geotiff/dist-module/source/blockedsource.js","webpack:///./node_modules/geotiff/dist-module/source/client/fetch.js","webpack:///./node_modules/geotiff/dist-module/source/client/xhr.js","webpack:///./node_modules/geotiff/dist-module/source/remote.js","webpack:///./node_modules/geotiff/dist-module/source/arraybuffer.js","webpack:///./node_modules/geotiff/dist-module/source/filereader.js","webpack:///./node_modules/geotiff/dist-module/geotiffwriter.js","webpack:///./node_modules/geotiff/dist-module/geotiff.js","webpack:///./node_modules/geotiff/dist-module/source/file.js","webpack:///./node_modules/geotiff/dist-module/source/client/base.js","webpack:///./node_modules/geotiff/dist-module/compression/index.js","webpack:///./node_modules/geotiff/dist-module/source/client/http.js","webpack:///./node_modules/geotiff/dist-module/pool.js","webpack:///./node_modules/geotiff/dist-module/globals.js","webpack:///./node_modules/geotiff/dist-module/utils.js","webpack:///./node_modules/geotiff/dist-module/source/basesource.js"],"names":["fromWhiteIsZero","raster","max","width","height","rgbRaster","Uint8Array","value","i","j","length","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","c","m","y","k","fromYCbCr","yCbCrRaster","Uint8ClampedArray","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","r","g","b","x","z","Math","min","copyNewSize","array","samplesPerPixel","Object","getPrototypeOf","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","cy","round","cx","lerp","v0","v1","t","resampleBilinear","rawY","yl","floor","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","Error","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","start","end","s","arrayForType","format","bitsPerSample","size","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","DataView","outSize","samplesToTransfer","outArray","bitMask","parseInt","repeat","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","byteOffset","innerBitOffset","getUint8","getUint16","raw","getUint32","buffer","fileDirectory","geoKeys","dataView","littleEndian","cache","source","this","tiles","isTiled","StripOffsets","PlanarConfiguration","ImageWidth","ImageLength","SamplesPerPixel","TileWidth","getWidth","TileLength","RowsPerStrip","getHeight","getTileWidth","getTileHeight","bytes","BitsPerSample","getSampleByteSize","RangeError","sampleIndex","SampleFormat","prototype","getInt8","getInt16","getInt32","offset","getFloat32","getFloat64","getSampleFormat","getBitsPerSample","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","byteCount","TileOffsets","TileByteCounts","StripByteCounts","slice","fetch","request","data","decode","sampleFormat","getSamplesPerPixel","getBlockHeight","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","getBytesPerPixel","srcSampleOffsets","sampleReaders","push","getReaderForSample","promises","yTile","xTile","si","promise","getTileOrStrip","then","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","call","windowCoordinate","Promise","all","resampled","window","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","reject","apply","fill","getArrayForSample","Array","isArray","result","_readRaster","enableAlpha","pi","PhotometricInterpretation","RGB","ExtraSamples","Unspecified","readRasters","WhiteIsZero","BlackIsZero","Palette","CMYK","YCbCr","CIELab","subOptions","ColorMap","red","green","blue","ModelTiepoint","tiePoints","metadata","GDAL_METADATA","string","items","filter","item","undefined","Number","inner","GDAL_NODATA","substring","modelTransformation","ModelTransformation","referenceImage","modelPixelScale","ModelPixelScale","refResX","refResY","refResZ","getResolution","GTRasterTypeGeoKey","origin","getOrigin","resolution","x1","y1","x2","y2","arrayBuffer","_dataView","left","right","combined","isSafeInteger","isNegative","carrying","byte","DataSlice","sliceOffset","bigTiff","_sliceOffset","_littleEndian","_bigTiff","byteLength","sliceTop","readUint32","readUint64","CRLFCRLF","itemsToObject","fromEntries","obj","key","parseHeaders","text","split","line","kv","str","trim","parseContentType","rawContentType","type","rawParams","paramsItems","param","params","parseContentRange","rawContentRange","total","match","parseByteRanges","responseArrayBuffer","boundary","decoder","TextDecoder","out","startBoundary","endBoundary","startsWith","innerText","substr","endOfHeaders","indexOf","headers","startOfData","fileSize","Block","BlockGroup","blockIds","blockSize","cacheSize","super","blockCache","maxSize","blockRequests","Map","blockIdsToFetch","Set","abortedBlockIds","slices","missingBlockIds","allBlockIds","top","firstBlockOffset","current","blockId","has","add","get","fetchBlocks","missingRequests","allSettled","abortedBlockRequests","id","forEach","aborted","block","blocks","failedBlocks","requiredBlocks","readSliceData","groups","groupBlocks","groupRequests","groupIndex","group","set","response","blockOffset","o","delete","err","name","clear","sortedBlockIds","from","sort","a","lastBlockId","blockIdLow","blockIdHigh","sliceData","ArrayBuffer","sliceView","delta","topDelta","usedBlockLength","blockInnerOffset","rangeInnerOffset","blockView","status","url","credentials","xhr","getResponseHeader","resolve","XMLHttpRequest","open","responseType","entries","setRequestHeader","onload","onerror","onabort","send","abort","addEventListener","constructRequest","client","maxRanges","allowFullFile","_fileSize","fetchSlices","fetchSlice","Range","join","ok","getHeader","byteRanges","getData","first","others","concat","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","tagName2Code","geoKeyName2Code","name2code","_binBE","nextZero","oincr","readUshort","buff","p","readShort","ui8","i16","readInt","i32","readUint","ui32","readASCII","l","String","fromCharCode","readFloat","fl32","readDouble","fl64","writeUshort","n","writeUint","writeASCII","charCodeAt","writeDouble","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","parseGeoKeyDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","location","count","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","readUint8","readInt8","readUint16","readInt16","readInt32","readInt64","readFloat32","readFloat64","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","options","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","getBoundingBox","oX","oY","rX","rY","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","firstIFDOffset","ifdRequests","ghostValues","fallbackSize","entrySize","offsetSize","getSlice","numDirEntries","byteSize","covers","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","readOffset","fieldDataSlice","parseFileDirectoryAt","requestIFD","e","previousIfd","ifd","hasNext","detectionString","heuristicAreaSize","valuesString","metadataSize","fullString","headerData","BOM","TypeError","magicNumber","offsetByteSize","getUint64","close","mainFile","overviewFiles","imageFiles","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","requests","file","parseFileDirectoriesPerFile","visited","relativeIndex","imageFile","ii","imageCounts","reduce","ifds","async","fromUrl","fromSource","fromUrls","mainUrl","overviewUrls","closeAsync","fd","openAsync","path","flags","mode","readAsync","args","read","bytesRead","FileSource","openRequest","Buffer","alloc","makeFileSource","BaseResponse","headerName","BaseClient","registry","addDecoder","cases","importFn","getDecoder","Compression","Decoder","default","HttpResponse","dataPromise","statusCode","HttpClient","parsedUrl","parse","httpApi","protocol","resolveData","chunks","on","chunk","destroy","defaultPoolSize","navigator","hardwareConcurrency","Pool","createWorker","workers","_awaitingDecoder","messageId","module","create","worker","idle","find","candidate","random","onMessage","decoded","removeEventListener","postMessage","terminate","fieldTagNames","fieldTags","hasOwnProperty","fieldTagTypes","256","257","258","259","262","273","274","277","278","279","282","283","284","286","287","296","297","305","306","338","339","513","514","1024","1025","2048","2049","3072","3073","33550","33922","34665","34735","34737","42113","arrayFields","StripRowCounts","SubIFDs","fieldTypeNames","fieldTypes","photometricInterpretations","TransparencyMask","ICCLab","ExtraSamplesValues","Assocalpha","Unassalpha","LercParameters","Version","AddCompression","LercAddCompression","None","Deflate","geoKeyNames","1026","2050","2051","2052","2053","2054","2055","2056","2057","2058","2059","2060","2061","2062","3074","3075","3076","3077","3078","3079","3080","3081","3082","3083","3084","3085","3086","3087","3088","3089","3090","3091","3092","3093","3094","3095","3096","4096","4097","4098","4099","assign","target","endsWith","expectedEnding","actualEnding","iterable","func","invert","oldObj","newObj","times","numTimes","results","wait","milliseconds","setTimeout","zip","A","B","AbortError","captureStackTrace","CustomAggregateError","errors","message","AggregateError","BaseSource"],"mappings":"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","file":"js/chunk-3f8798ca.f2dc78c2.js","sourcesContent":["export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {Source} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sampleIndex);\n          }\n          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal).then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * greayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<TypedArray|TypedArray[]>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox() {\n    const origin = this.getOrigin();\n    const resolution = this.getResolution();\n\n    const x1 = origin[0];\n    const y1 = origin[1];\n\n    const x2 = x1 + (resolution[0] * this.getWidth());\n    const y2 = y1 + (resolution[1] * this.getHeight());\n\n    return [\n      Math.min(x1, x2),\n      Math.min(y1, y2),\n      Math.max(x1, x2),\n      Math.max(y1, y2),\n    ];\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {Source} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({ maxSize: cacheSize });\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {basesource/Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  async request({ headers, credentials, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\nimport { AbortError } from '../utils.js';\n\nclass ArrayBufferSource extends BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nexport function makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey in geoKeys) {\n    if (geoKeys.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\n","import fs from 'fs';\nimport { BaseSource } from './basesource.js';\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nexport function makeFileSource(path) {\n  return new FileSource(path);\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {object} [options]\n   */\n  async request({ headers, credentials, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js').then((m) => m.default));\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n"],"sourceRoot":""}