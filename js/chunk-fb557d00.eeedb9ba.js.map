{"version":3,"sources":["webpack:///./node_modules/ol/renderer/webgl/TileLayer.js","webpack:///./node_modules/ol/renderer/vector.js","webpack:///./node_modules/ol/renderer/webgl/PointsLayer.js","webpack:///./node_modules/ol/renderer/webgl/Layer.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","Uniforms","TILE_TEXTURE_ARRAY","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","RENDER_EXTENT","RESOLUTION","ZOOM","Attributes","TEXTURE_COORD","attributeDescriptions","name","size","type","FLOAT","empty","depthForZ","z","addTileTextureToLookup","tileTexturesByZ","tileTexture","push","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","getCacheKey","tileCoord","concat","getKey","WebGLTileLayerRenderer","_super","tileLayer","options","_this","uniforms","renderComplete","tileTransform_","tempMat4_","tempTileRange_","tempTileCoord_","tempSize_","program_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","indices_","fromArray","cacheSize","undefined","tileTextureCache_","paletteTextures_","paletteTextures","frameState_","reset","helper","getProgram","afterHelperCreated","flushBufferData","isDrawableTile_","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","prepareFrameInternal","READY","enqueueTiles","initialZ","tileSource","tileGrid","tilePixelRatio","getTilePixelRatio","pixelRatio","gutter","getGutterForProjection","tileSourceKey","wantedTiles","tileTextureCache","minZ","Math","max","getPreload","getMinZoom","tileRange","getTileRangeForExtentAndZ","tileResolution","getResolution","x","minX","maxX","y","minY","maxY","cacheKey","containsKey","get","key","getTile","setTile","interimTile","getInterimTile","grid","set","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","renderFrame","gl","getGL","preRender","getZForResolution","resolution","zDirection","nextExtent","targetZ","nextResolution","alphaLookup","uid","time","blend","tileTextures","i","ii","length","loaded","alpha","getAlpha","endTransition","tileCoordKey","coveredByChildren","findAltTiles_","minZoom","parentZ","coveredByParent","useProgram","prepareDraw","zs","keys","map","Number","sort","centerX","center","centerY","j","jj","tileZ","tileSize","getTileSize","tileOrigin","getOrigin","centerI","centerJ","tileScale","depth","tileTextures_1","tileCenterI","tileCenterJ","rotation","setUniformMatrixValue","bindBuffer","coords","enableAttributes","textureSlot","textures","textureProperty","uniformName","activeTexture","bindTexture","TEXTURE_2D","uniform1i","getUniformLocation","paletteIndex","paletteTexture","texture","getTexture","animate","setUniformFloatValue","setUniformFloatVec4","zoom","drawElements","getSize","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","canExpireCache","pop","dispose","postRenderFunction","expireCache","postRenderFunctions","postRender","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","getTileCoordForCoordAndZ","col","row","getPixelData","altZ","getTileRangeForTileCoordAndZ","covered","removeHelper","forEach","clear","disposeInternal","deleteProgram","deleteBuffer","SIMPLIFY_TOLERANCE","GEOMETRY_RENDERERS","renderPointGeometry","renderLineStringGeometry","renderPolygonGeometry","renderMultiPointGeometry","renderMultiLineStringGeometry","renderMultiPolygonGeometry","renderGeometryCollectionGeometry","renderCircleGeometry","defaultOrder","feature1","feature2","parseInt","getSquaredTolerance","tolerance","getTolerance","builderGroup","geometry","style","feature","opt_declutterBuilderGroup","fillStyle","getFill","strokeStyle","getStroke","circleReplay","getBuilder","getZIndex","CIRCLE","setFillStrokeStyle","drawCircle","textStyle","getText","textReplay","TEXT","setTextStyle","drawText","renderFeature","replayGroup","squaredTolerance","listener","opt_transform","loading","imageStyle","getImage","imageState","getImageState","unlistenImageChange","load","listenImageChange","renderFeatureInternal","getGeometryFunction","simplifiedGeometry","simplifyTransformed","renderer","getRenderer","renderGeometry","geometryRenderer","getType","GEOMETRY_COLLECTION","replay","DEFAULT","drawCustom","getHitDetectionRenderer","geometries","getGeometries","getGeometriesArray","lineStringReplay","LINE_STRING","drawLineString","drawMultiLineString","polygonReplay","POLYGON","drawMultiPolygon","declutterImageWithText","imageReplay","IMAGE","setImageStyle","drawPoint","drawMultiPoint","drawPolygon","WebGLPointsLayerRenderer","projectionMatrixTransform","PROJECTION_MATRIX","postProcesses","ready","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitVertexShader_","hitFragmentShader_","hitProgram_","customAttributes","attributes","attribute","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","Float32Array","hitRenderInstructions_","hitRenderTarget_","generateBuffersRun_","worker_","addEventListener","event","received","data","GENERATE_BUFFERS","projectionTransform","hitDetection","fromArrayBuffer","vertexBuffer","indexBuffer","renderInstructions","generateBuffersRun","changed","bind","featureCache_","featureCount_","getSource","sourceListenKeys_","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","properties","getProperties","getGeometry","renderCount","renderHitDetection","clearCachedData","vectorSource","viewNotMoving","viewHints","ANIMATING","INTERACTING","extentChanged","sourceChanged","getRevision","renderBuffer","getRenderBuffer","loadFeatures","rebuildBuffers_","makeProjectionTransform","featureCache","totalInstructionsCount","totalHitInstructionsCount","hitColor","tmpCoords","tmpColor","renderIndex","hitIndex","featureUid","POINT","getFlatCoordinates","value","callback","message","buffer","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","hitTolerance","matches","coordinateToPixelTransform","readPixel","color","index","opacity","floor","toString","getFeatureByUid","setSize","prepareDrawToRenderTarget","terminate","layer_","WebGLWorkerMessageType","WebGLLayerRenderer","opt_options","inversePixelTransform_","pixelContext_","postProcesses_","uniforms_","addChangeListener","MAP","context","hasListener","PRECOMPOSE","event_1","dispatchEvent","POSTCOMPOSE","event_2","setUniforms","prepareFrame","incrementGroup","groupNumber","className","layerClassName","getClassName","canvasCacheKey","mapId","canvasCacheKeyMatches","dispatchRenderEvent_","event_3","PRERENDER","POSTRENDER","getDataAtPixel","renderPixel","renderCoordinate","getContextAttributes","preserveDrawingBuffer","Uint8Array","round","pixelContext","pixelCanvas","document","createElement","width","height","getContext","clearRect","drawImage","getImageData","err","colorEncodeId","id","opt_array","array","radix","divide","colorDecodeId","mult"],"mappings":"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","file":"js/chunk-fb557d00.eeedb9ba.js","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport State from '../../source/State.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport { AttributeType } from '../../webgl/Helper.js';\nimport { ELEMENT_ARRAY_BUFFER, STATIC_DRAW } from '../../webgl.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { containsCoordinate, getIntersection, isEmpty } from '../../extent.js';\nimport { create as createMat4, fromTransform as mat4FromTransform, } from '../../vec/mat4.js';\nimport { createOrUpdate as createTileCoord, getKey as getTileCoordKey, } from '../../tilecoord.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { toSize } from '../../size.js';\nexport var Uniforms = {\n    TILE_TEXTURE_ARRAY: 'u_tileTextures',\n    TILE_TRANSFORM: 'u_tileTransform',\n    TRANSITION_ALPHA: 'u_transitionAlpha',\n    DEPTH: 'u_depth',\n    TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n    TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n    TEXTURE_RESOLUTION: 'u_textureResolution',\n    TEXTURE_ORIGIN_X: 'u_textureOriginX',\n    TEXTURE_ORIGIN_Y: 'u_textureOriginY',\n    RENDER_EXTENT: 'u_renderExtent',\n    RESOLUTION: 'u_resolution',\n    ZOOM: 'u_zoom',\n};\nexport var Attributes = {\n    TEXTURE_COORD: 'a_textureCoord',\n};\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nvar attributeDescriptions = [\n    {\n        name: Attributes.TEXTURE_COORD,\n        size: 2,\n        type: AttributeType.FLOAT,\n    },\n];\n/**\n * @type {Object<string, boolean>}\n */\nvar empty = {};\n/**\n * Transform a zoom level into a depth value ranging from -1 to 1.\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n    return 2 * (1 - 1 / (z + 1)) - 1;\n}\n/**\n * Add a tile texture to the lookup.\n * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n * tile textures by zoom level.\n * @param {import(\"../../webgl/TileTexture.js\").default} tileTexture A tile texture.\n * @param {number} z The zoom level.\n */\nfunction addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {\n    if (!(z in tileTexturesByZ)) {\n        tileTexturesByZ[z] = [];\n    }\n    tileTexturesByZ[z].push(tileTexture);\n}\n/**\n * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n    var layerState = frameState.layerStatesArray[frameState.layerIndex];\n    if (layerState.extent) {\n        extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n    }\n    var source = /** @type {import(\"../../source/Tile.js\").default} */ (layerState.layer.getRenderSource());\n    if (!source.getWrapX()) {\n        var gridExtent = source\n            .getTileGridForProjection(frameState.viewState.projection)\n            .getExtent();\n        if (gridExtent) {\n            extent = getIntersection(extent, gridExtent);\n        }\n    }\n    return extent;\n}\nfunction getCacheKey(source, tileCoord) {\n    return \"\".concat(source.getKey(), \",\").concat(getTileCoordKey(tileCoord));\n}\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLLayerRenderer<LayerType>}\n * @api\n */\nvar WebGLTileLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLTileLayerRenderer, _super);\n    /**\n     * @param {LayerType} tileLayer Tile layer.\n     * @param {Options} options Options.\n     */\n    function WebGLTileLayerRenderer(tileLayer, options) {\n        var _this = _super.call(this, tileLayer, {\n            uniforms: options.uniforms,\n        }) || this;\n        /**\n         * The last call to `renderFrame` was completed with all tiles loaded\n         * @type {boolean}\n         */\n        _this.renderComplete = false;\n        /**\n         * This transform converts texture coordinates to screen coordinates.\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.tileTransform_ = createTransform();\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.tempMat4_ = createMat4();\n        /**\n         * @type {import(\"../../TileRange.js\").default}\n         * @private\n         */\n        _this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n        /**\n         * @type {import(\"../../tilecoord.js\").TileCoord}\n         * @private\n         */\n        _this.tempTileCoord_ = createTileCoord(0, 0, 0);\n        /**\n         * @type {import(\"../../size.js\").Size}\n         * @private\n         */\n        _this.tempSize_ = [0, 0];\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.program_;\n        /**\n         * @private\n         */\n        _this.vertexShader_ = options.vertexShader;\n        /**\n         * @private\n         */\n        _this.fragmentShader_ = options.fragmentShader;\n        /**\n         * Tiles are rendered as a quad with the following structure:\n         *\n         *  [P3]---------[P2]\n         *   |`           |\n         *   |  `     B   |\n         *   |    `       |\n         *   |      `     |\n         *   |   A    `   |\n         *   |          ` |\n         *  [P0]---------[P1]\n         *\n         * Triangle A: P0, P1, P3\n         * Triangle B: P1, P2, P3\n         *\n         * @private\n         */\n        _this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n        _this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n        var cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n        /**\n         * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../webgl/TileTexture.js\").default>}\n         * @private\n         */\n        _this.tileTextureCache_ = new LRUCache(cacheSize);\n        /**\n         * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n         * @private\n         */\n        _this.paletteTextures_ = options.paletteTextures || [];\n        /**\n         * @private\n         * @type {import(\"../../PluggableMap.js\").FrameState|null}\n         */\n        _this.frameState_ = null;\n        return _this;\n    }\n    /**\n     * @param {Options} options Options.\n     */\n    WebGLTileLayerRenderer.prototype.reset = function (options) {\n        _super.prototype.reset.call(this, {\n            uniforms: options.uniforms,\n        });\n        this.vertexShader_ = options.vertexShader;\n        this.fragmentShader_ = options.fragmentShader;\n        this.paletteTextures_ = options.paletteTextures || [];\n        if (this.helper) {\n            this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n        }\n    };\n    WebGLTileLayerRenderer.prototype.afterHelperCreated = function () {\n        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n        this.helper.flushBufferData(this.indices_);\n    };\n    /**\n     * @param {import(\"../../webgl/TileTexture\").TileType} tile Tile.\n     * @return {boolean} Tile is drawable.\n     * @private\n     */\n    WebGLTileLayerRenderer.prototype.isDrawableTile_ = function (tile) {\n        var tileLayer = this.getLayer();\n        var tileState = tile.getState();\n        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n        return (tileState == TileState.LOADED ||\n            tileState == TileState.EMPTY ||\n            (tileState == TileState.ERROR && !useInterimTilesOnError));\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLTileLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        var layer = this.getLayer();\n        var source = layer.getRenderSource();\n        if (!source) {\n            return false;\n        }\n        if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n            return false;\n        }\n        return source.getState() === State.READY;\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n     * @param {number} initialZ The zoom level.\n     * @param {Object<number, Array<TileTexture>>} tileTexturesByZ The zoom level.\n     */\n    WebGLTileLayerRenderer.prototype.enqueueTiles = function (frameState, extent, initialZ, tileTexturesByZ) {\n        var viewState = frameState.viewState;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getRenderSource();\n        var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n        var tilePixelRatio = tileSource.getTilePixelRatio(frameState.pixelRatio);\n        var gutter = tileSource.getGutterForProjection(viewState.projection);\n        var tileSourceKey = getUid(tileSource);\n        if (!(tileSourceKey in frameState.wantedTiles)) {\n            frameState.wantedTiles[tileSourceKey] = {};\n        }\n        var wantedTiles = frameState.wantedTiles[tileSourceKey];\n        var tileTextureCache = this.tileTextureCache_;\n        var minZ = Math.max(initialZ - tileLayer.getPreload(), tileGrid.getMinZoom(), tileLayer.getMinZoom());\n        for (var z = initialZ; z >= minZ; --z) {\n            var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n            var tileResolution = tileGrid.getResolution(z);\n            for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n                for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                    var tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n                    var cacheKey = getCacheKey(tileSource, tileCoord);\n                    /** @type {TileTexture} */\n                    var tileTexture = void 0;\n                    /** @type {import(\"../../webgl/TileTexture\").TileType} */\n                    var tile = void 0;\n                    if (tileTextureCache.containsKey(cacheKey)) {\n                        tileTexture = tileTextureCache.get(cacheKey);\n                        tile = tileTexture.tile;\n                    }\n                    if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {\n                        tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);\n                        if (!tileTexture) {\n                            tileTexture = new TileTexture({\n                                tile: tile,\n                                grid: tileGrid,\n                                helper: this.helper,\n                                tilePixelRatio: tilePixelRatio,\n                                gutter: gutter,\n                            });\n                            tileTextureCache.set(cacheKey, tileTexture);\n                        }\n                        else {\n                            if (this.isDrawableTile_(tile)) {\n                                tileTexture.setTile(tile);\n                            }\n                            else {\n                                var interimTile = \n                                /** @type {import(\"../../webgl/TileTexture\").TileType} */ (tile.getInterimTile());\n                                tileTexture.setTile(interimTile);\n                            }\n                        }\n                    }\n                    addTileTextureToLookup(tileTexturesByZ, tileTexture, z);\n                    var tileQueueKey = tile.getKey();\n                    wantedTiles[tileQueueKey] = true;\n                    if (tile.getState() === TileState.IDLE) {\n                        if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n                            frameState.tileQueue.enqueue([\n                                tile,\n                                tileSourceKey,\n                                tileGrid.getTileCoordCenter(tileCoord),\n                                tileResolution,\n                            ]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLTileLayerRenderer.prototype.renderFrame = function (frameState) {\n        this.frameState_ = frameState;\n        this.renderComplete = true;\n        var gl = this.helper.getGL();\n        this.preRender(gl, frameState);\n        var viewState = frameState.viewState;\n        var tileLayer = this.getLayer();\n        var tileSource = tileLayer.getRenderSource();\n        var tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n        var extent = getRenderExtent(frameState, frameState.extent);\n        var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n        /**\n         * @type {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>}\n         */\n        var tileTexturesByZ = {};\n        if (frameState.nextExtent) {\n            var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n            var nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n            this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);\n        }\n        this.enqueueTiles(frameState, extent, z, tileTexturesByZ);\n        /**\n         * A lookup of alpha values for tiles at the target rendering resolution\n         * for tiles that are in transition.  If a tile coord key is absent from\n         * this lookup, the tile should be rendered at alpha 1.\n         * @type {Object<string, number>}\n         */\n        var alphaLookup = {};\n        var uid = getUid(this);\n        var time = frameState.time;\n        var blend = false;\n        // look for cached tiles to use if a target tile is not ready\n        var tileTextures = tileTexturesByZ[z];\n        for (var i = 0, ii = tileTextures.length; i < ii; ++i) {\n            var tileTexture = tileTextures[i];\n            var tile = tileTexture.tile;\n            var tileCoord = tile.tileCoord;\n            if (tileTexture.loaded) {\n                var alpha = tile.getAlpha(uid, time);\n                if (alpha === 1) {\n                    // no need to look for alt tiles\n                    tile.endTransition(uid);\n                    continue;\n                }\n                blend = true;\n                var tileCoordKey = getTileCoordKey(tileCoord);\n                alphaLookup[tileCoordKey] = alpha;\n            }\n            this.renderComplete = false;\n            // first look for child tiles (at z + 1)\n            var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);\n            if (coveredByChildren) {\n                continue;\n            }\n            // next look for parent tiles\n            var minZoom = tileGrid.getMinZoom();\n            for (var parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n                var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);\n                if (coveredByParent) {\n                    break;\n                }\n            }\n        }\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState, !blend);\n        var zs = Object.keys(tileTexturesByZ)\n            .map(Number)\n            .sort(numberSafeCompareFunction);\n        var centerX = viewState.center[0];\n        var centerY = viewState.center[1];\n        for (var j = 0, jj = zs.length; j < jj; ++j) {\n            var tileZ = zs[j];\n            var tileResolution = tileGrid.getResolution(tileZ);\n            var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n            var tileOrigin = tileGrid.getOrigin(tileZ);\n            var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n            var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n            var tileScale = viewState.resolution / tileResolution;\n            var depth = depthForZ(tileZ);\n            var tileTextures_1 = tileTexturesByZ[tileZ];\n            for (var i = 0, ii = tileTextures_1.length; i < ii; ++i) {\n                var tileTexture = tileTextures_1[i];\n                if (!tileTexture.loaded) {\n                    continue;\n                }\n                var tile = tileTexture.tile;\n                var tileCoord = tile.tileCoord;\n                var tileCoordKey = getTileCoordKey(tileCoord);\n                var tileCenterI = tileCoord[1];\n                var tileCenterJ = tileCoord[2];\n                composeTransform(this.tileTransform_, 0, 0, 2 / ((frameState.size[0] * tileScale) / tileSize[0]), -2 / ((frameState.size[1] * tileScale) / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));\n                this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, mat4FromTransform(this.tempMat4_, this.tileTransform_));\n                this.helper.bindBuffer(tileTexture.coords);\n                this.helper.bindBuffer(this.indices_);\n                this.helper.enableAttributes(attributeDescriptions);\n                var textureSlot = 0;\n                while (textureSlot < tileTexture.textures.length) {\n                    var textureProperty = 'TEXTURE' + textureSlot;\n                    var uniformName = \"\".concat(Uniforms.TILE_TEXTURE_ARRAY, \"[\").concat(textureSlot, \"]\");\n                    gl.activeTexture(gl[textureProperty]);\n                    gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureSlot]);\n                    gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);\n                    ++textureSlot;\n                }\n                for (var paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {\n                    var paletteTexture = this.paletteTextures_[paletteIndex];\n                    gl.activeTexture(gl['TEXTURE' + textureSlot]);\n                    var texture = paletteTexture.getTexture(gl);\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);\n                    ++textureSlot;\n                }\n                var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n                if (alpha < 1) {\n                    frameState.animate = true;\n                }\n                this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n                this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n                this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);\n                this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);\n                this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);\n                this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution);\n                this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution);\n                this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, extent);\n                this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n                this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n                this.helper.drawElements(0, this.indices_.getSize());\n            }\n        }\n        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n        var canvas = this.helper.getCanvas();\n        var tileTextureCache = this.tileTextureCache_;\n        while (tileTextureCache.canExpireCache()) {\n            var tileTexture = tileTextureCache.pop();\n            tileTexture.dispose();\n        }\n        // TODO: let the renderers manage their own cache instead of managing the source cache\n        /**\n         * Here we unconditionally expire the source cache since the renderer maintains\n         * its own cache.\n         * @param {import(\"../../PluggableMap.js\").default} map Map.\n         * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n         */\n        var postRenderFunction = function (map, frameState) {\n            tileSource.expireCache(frameState.viewState.projection, empty);\n        };\n        frameState.postRenderFunctions.push(postRenderFunction);\n        this.postRender(gl, frameState);\n        return canvas;\n    };\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n     */\n    WebGLTileLayerRenderer.prototype.getData = function (pixel) {\n        var gl = this.helper.getGL();\n        if (!gl) {\n            return null;\n        }\n        var frameState = this.frameState_;\n        if (!frameState) {\n            return null;\n        }\n        var layer = this.getLayer();\n        var coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n        var viewState = frameState.viewState;\n        var layerExtent = layer.getExtent();\n        if (layerExtent) {\n            if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {\n                return null;\n            }\n        }\n        var source = layer.getRenderSource();\n        var tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (!source.getWrapX()) {\n            var gridExtent = tileGrid.getExtent();\n            if (gridExtent) {\n                if (!containsCoordinate(gridExtent, coordinate)) {\n                    return null;\n                }\n            }\n        }\n        var tileTextureCache = this.tileTextureCache_;\n        for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n            var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n            var cacheKey = getCacheKey(source, tileCoord);\n            if (!tileTextureCache.containsKey(cacheKey)) {\n                continue;\n            }\n            var tileTexture = tileTextureCache.get(cacheKey);\n            if (!tileTexture.loaded) {\n                continue;\n            }\n            var tileOrigin = tileGrid.getOrigin(z);\n            var tileSize = toSize(tileGrid.getTileSize(z));\n            var tileResolution = tileGrid.getResolution(z);\n            var col = (coordinate[0] - tileOrigin[0]) / tileResolution -\n                tileCoord[1] * tileSize[0];\n            var row = (tileOrigin[1] - coordinate[1]) / tileResolution -\n                tileCoord[2] * tileSize[1];\n            return tileTexture.getPixelData(col, row);\n        }\n        return null;\n    };\n    /**\n     * Look for tiles covering the provided tile coordinate at an alternate\n     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n     * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n     * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n     * @param {number} altZ The alternate zoom level.\n     * @param {Object<number, Array<import(\"../../webgl/TileTexture.js\").default>>} tileTexturesByZ Lookup of\n     * tile textures by zoom level.\n     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n     * @private\n     */\n    WebGLTileLayerRenderer.prototype.findAltTiles_ = function (tileGrid, tileCoord, altZ, tileTexturesByZ) {\n        var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n        if (!tileRange) {\n            return false;\n        }\n        var covered = true;\n        var tileTextureCache = this.tileTextureCache_;\n        var source = this.getLayer().getRenderSource();\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                var cacheKey = getCacheKey(source, [altZ, x, y]);\n                var loaded = false;\n                if (tileTextureCache.containsKey(cacheKey)) {\n                    var tileTexture = tileTextureCache.get(cacheKey);\n                    if (tileTexture.loaded) {\n                        addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);\n                        loaded = true;\n                    }\n                }\n                if (!loaded) {\n                    covered = false;\n                }\n            }\n        }\n        return covered;\n    };\n    WebGLTileLayerRenderer.prototype.removeHelper = function () {\n        if (this.helper) {\n            var tileTextureCache = this.tileTextureCache_;\n            tileTextureCache.forEach(function (tileTexture) { return tileTexture.dispose(); });\n            tileTextureCache.clear();\n        }\n        _super.prototype.removeHelper.call(this);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLTileLayerRenderer.prototype.disposeInternal = function () {\n        var helper = this.helper;\n        if (helper) {\n            var gl = helper.getGL();\n            gl.deleteProgram(this.program_);\n            delete this.program_;\n            helper.deleteBuffer(this.indices_);\n        }\n        _super.prototype.disposeInternal.call(this);\n        delete this.indices_;\n        delete this.tileTextureCache_;\n        delete this.frameState_;\n    };\n    return WebGLTileLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLTileLayerRenderer;\n//# sourceMappingURL=TileLayer.js.map","/**\n * @module ol/renderer/vector\n */\nimport BuilderType from '../render/canvas/BuilderType.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport ImageState from '../ImageState.js';\nimport { getUid } from '../util.js';\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nvar SIMPLIFY_TOLERANCE = 0.5;\n/**\n * @const\n * @type {Object<import(\"../geom/GeometryType.js\").default,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nvar GEOMETRY_RENDERERS = {\n    'Point': renderPointGeometry,\n    'LineString': renderLineStringGeometry,\n    'Polygon': renderPolygonGeometry,\n    'MultiPoint': renderMultiPointGeometry,\n    'MultiLineString': renderMultiLineStringGeometry,\n    'MultiPolygon': renderMultiPolygonGeometry,\n    'GeometryCollection': renderGeometryCollectionGeometry,\n    'Circle': renderCircleGeometry,\n};\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n    return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n    var tolerance = getTolerance(resolution, pixelRatio);\n    return tolerance * tolerance;\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n    return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);\n        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        circleReplay.drawCircle(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Transform from user to view projection.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {\n    var loading = false;\n    var imageStyle = style.getImage();\n    if (imageStyle) {\n        var imageState = imageStyle.getImageState();\n        if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n            imageStyle.unlistenImageChange(listener);\n        }\n        else {\n            if (imageState == ImageState.IDLE) {\n                imageStyle.load();\n            }\n            imageState = imageStyle.getImageState();\n            imageStyle.listenImageChange(listener);\n            loading = true;\n        }\n    }\n    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);\n    return loading;\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {\n    var geometry = style.getGeometryFunction()(feature);\n    if (!geometry) {\n        return;\n    }\n    var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);\n    var renderer = style.getRenderer();\n    if (renderer) {\n        renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n    }\n    else {\n        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n    if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {\n        var geometries = \n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            renderGeometry(replayGroup, geometries[i], style, feature);\n        }\n        return;\n    }\n    var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);\n    replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry), feature, style.getRenderer(), style.getHitDetectionRenderer());\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var geometries = geometry.getGeometriesArray();\n    var i, ii;\n    for (i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n        geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var strokeStyle = style.getStroke();\n    if (strokeStyle) {\n        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);\n        lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n        lineStringReplay.drawMultiLineString(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (strokeStyle || fillStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawMultiPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var imageStyle = style.getImage();\n    var textStyle = style.getText();\n    /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n    var declutterImageWithText;\n    if (opt_declutterBuilderGroup) {\n        builderGroup = opt_declutterBuilderGroup;\n        declutterImageWithText =\n            imageStyle && textStyle && textStyle.getText() ? {} : undefined;\n    }\n    if (imageStyle) {\n        if (imageStyle.getImageState() != ImageState.LOADED) {\n            return;\n        }\n        var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);\n        imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n        imageReplay.drawMultiPoint(geometry, feature);\n    }\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle, declutterImageWithText);\n        textReplay.drawText(geometry, feature);\n    }\n}\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [opt_declutterBuilderGroup] Builder for decluttering.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {\n    var fillStyle = style.getFill();\n    var strokeStyle = style.getStroke();\n    if (fillStyle || strokeStyle) {\n        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);\n        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n        polygonReplay.drawPolygon(geometry, feature);\n    }\n    var textStyle = style.getText();\n    if (textStyle && textStyle.getText()) {\n        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);\n        textReplay.setTextStyle(textStyle);\n        textReplay.drawText(geometry, feature);\n    }\n}\n//# sourceMappingURL=vector.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot and `u_opacity` is reserved for the layer opacity.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder~ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n * The following uniform is used for the layer opacity: `u_opacity`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.ready = false;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        /**\n         * @private\n         */\n        _this.vertexShader_ = options.vertexShader;\n        /**\n         * @private\n         */\n        _this.fragmentShader_ = options.fragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.program_;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        /**\n         * @private\n         */\n        _this.hitVertexShader_ = options.hitVertexShader;\n        /**\n         * @private\n         */\n        _this.hitFragmentShader_ = options.hitFragmentShader;\n        /**\n         * @type {WebGLProgram}\n         * @private\n         */\n        _this.hitProgram_;\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_;\n        /**\n         * Keep track of latest message sent to worker\n         * @type {number}\n         * @private\n         */\n        _this.generateBuffersRun_ = 0;\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                    if (received.generateBuffersRun === this.generateBuffersRun_) {\n                        this.ready = true;\n                    }\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    WebGLPointsLayerRenderer.prototype.afterHelperCreated = function () {\n        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n        if (this.hitDetectionEnabled_) {\n            this.hitProgram_ = this.helper.getProgram(this.hitFragmentShader_, this.hitVertexShader_);\n            this.hitRenderTarget_ = new WebGLRenderTarget(this.helper);\n        }\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        var gl = this.helper.getGL();\n        this.preRender(gl, frameState);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n        var canvas = this.helper.getCanvas();\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(gl, frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        // apply the current projection transform with the invert of the one used to fill buffers\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== GeometryType.POINT) {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        message['generateBuffersRun'] = ++this.generateBuffersRun_;\n        this.ready = false;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, } from '../../transform.js';\nimport { containsCoordinate } from '../../extent.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n         * set before dispatching rendering events.\n         * @private\n         * @type {import(\"../../transform.js\").Transform}\n         */\n        _this.inversePixelTransform_ = createTransform();\n        /**\n         * @private\n         * @type {CanvasRenderingContext2D}\n         */\n        _this.pixelContext_ = null;\n        /**\n         * @private\n         */\n        _this.postProcesses_ = options.postProcesses;\n        /**\n         * @private\n         */\n        _this.uniforms_ = options.uniforms;\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper;\n        layer.addChangeListener(LayerProperty.MAP, _this.removeHelper.bind(_this));\n        _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_this);\n        _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_this);\n        return _this;\n    }\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPreComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n            var event_1 = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The WebGL rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.dispatchPostComposeEvent = function (context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n            var event_2 = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);\n            layer.dispatchEvent(event_2);\n        }\n    };\n    /**\n     * Reset options (only handles uniforms).\n     * @param {Options} options Options.\n     */\n    WebGLLayerRenderer.prototype.reset = function (options) {\n        this.uniforms_ = options.uniforms;\n        if (this.helper) {\n            this.helper.setUniforms(this.uniforms_);\n        }\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.removeHelper = function () {\n        if (this.helper) {\n            this.helper.dispose();\n            delete this.helper;\n        }\n    };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLLayerRenderer.prototype.prepareFrame = function (frameState) {\n        if (this.getLayer().getRenderSource()) {\n            var incrementGroup = true;\n            var groupNumber = -1;\n            var className = void 0;\n            for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n                var layer = frameState.layerStatesArray[i].layer;\n                var renderer = layer.getRenderer();\n                if (!(renderer instanceof WebGLLayerRenderer)) {\n                    incrementGroup = true;\n                    continue;\n                }\n                var layerClassName = layer.getClassName();\n                if (incrementGroup || layerClassName !== className) {\n                    groupNumber += 1;\n                    incrementGroup = false;\n                }\n                className = layerClassName;\n                if (renderer === this) {\n                    break;\n                }\n            }\n            var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;\n            if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {\n                this.removeHelper();\n                this.helper = new WebGLHelper({\n                    postProcesses: this.postProcesses_,\n                    uniforms: this.uniforms_,\n                    canvasCacheKey: canvasCacheKey,\n                });\n                if (className) {\n                    this.helper.getCanvas().className = className;\n                }\n                this.afterHelperCreated();\n            }\n        }\n        return this.prepareFrameInternal(frameState);\n    };\n    /**\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.afterHelperCreated = function () { };\n    /**\n     * Determine whether renderFrame should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.prepareFrameInternal = function (frameState) {\n        return true;\n    };\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.removeHelper();\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            composeTransform(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n            var event_3 = new RenderEvent(type, this.inversePixelTransform_, frameState, context);\n            layer.dispatchEvent(event_3);\n        }\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n    };\n    /**\n     * @param {WebGLRenderingContext} context The rendering context.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (context, frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n    };\n    /**\n     * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n     *    location, null will be returned.  If there is data, but pixel values cannot be\n     *    returned, and empty array will be returned.\n     */\n    WebGLLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n        var renderPixel = applyTransform([frameState.pixelRatio, 0, 0, frameState.pixelRatio, 0, 0], pixel.slice());\n        var gl = this.helper.getGL();\n        if (!gl) {\n            return null;\n        }\n        var layer = this.getLayer();\n        var layerExtent = layer.getExtent();\n        if (layerExtent) {\n            var renderCoordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n            /** get only data inside of the layer extent */\n            if (!containsCoordinate(layerExtent, renderCoordinate)) {\n                return null;\n            }\n        }\n        var attributes = gl.getContextAttributes();\n        if (!attributes || !attributes.preserveDrawingBuffer) {\n            // we assume there is data at the given pixel (although there might not be)\n            return new Uint8Array();\n        }\n        var x = Math.round(renderPixel[0]);\n        var y = Math.round(renderPixel[1]);\n        var pixelContext = this.pixelContext_;\n        if (!pixelContext) {\n            var pixelCanvas = document.createElement('canvas');\n            pixelCanvas.width = 1;\n            pixelCanvas.height = 1;\n            pixelContext = pixelCanvas.getContext('2d');\n            this.pixelContext_ = pixelContext;\n        }\n        pixelContext.clearRect(0, 0, 1, 1);\n        var data;\n        try {\n            pixelContext.drawImage(gl.canvas, x, y, 1, 1, 0, 0, 1, 1);\n            data = pixelContext.getImageData(0, 0, 1, 1).data;\n        }\n        catch (err) {\n            return data;\n        }\n        if (data[3] === 0) {\n            return null;\n        }\n        return data;\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map"],"sourceRoot":""}